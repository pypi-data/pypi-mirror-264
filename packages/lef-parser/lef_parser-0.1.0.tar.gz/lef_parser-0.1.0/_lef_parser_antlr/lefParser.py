# Generated from lef.g by ANTLR 4.10.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,186,974,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,1,0,4,0,134,8,0,11,0,12,0,135,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,155,8,1,1,2,1,2,1,2,1,2,
        1,3,1,3,1,3,1,3,1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,
        1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,5,9,189,8,9,10,9,
        12,9,192,9,9,1,9,1,9,1,10,1,10,1,10,1,11,1,11,5,11,201,8,11,10,11,
        12,11,204,9,11,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,13,1,13,
        5,13,216,8,13,10,13,12,13,219,9,13,1,13,1,13,1,13,1,14,1,14,1,14,
        1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
        1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
        1,14,1,14,1,14,3,14,256,8,14,1,15,1,15,1,15,5,15,261,8,15,10,15,
        12,15,264,9,15,1,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
        1,16,1,16,1,16,1,16,1,16,1,16,3,16,282,8,16,1,17,1,17,1,18,1,18,
        1,18,5,18,289,8,18,10,18,12,18,292,9,18,1,18,1,18,1,18,1,19,1,19,
        1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
        1,19,1,19,1,19,1,19,1,19,1,19,3,19,318,8,19,1,20,1,20,1,21,1,21,
        1,21,1,21,1,21,1,22,1,22,1,22,4,22,330,8,22,11,22,12,22,331,1,22,
        1,22,1,22,4,22,337,8,22,11,22,12,22,338,1,22,3,22,342,8,22,1,22,
        1,22,4,22,346,8,22,11,22,12,22,347,3,22,350,8,22,1,23,1,23,1,23,
        1,23,1,23,1,24,1,24,1,24,4,24,360,8,24,11,24,12,24,361,1,24,1,24,
        1,24,4,24,367,8,24,11,24,12,24,368,3,24,371,8,24,1,25,1,25,3,25,
        375,8,25,1,25,1,25,3,25,379,8,25,1,25,1,25,1,25,1,25,1,25,1,25,4,
        25,387,8,25,11,25,12,25,388,1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,
        26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,3,26,406,8,26,1,27,1,27,1,
        27,1,27,1,28,1,28,1,28,3,28,415,8,28,1,28,1,28,1,29,1,29,1,29,1,
        29,3,29,423,8,29,1,29,1,29,1,29,1,29,1,29,3,29,430,8,29,1,29,1,29,
        1,29,1,29,1,29,1,29,1,29,1,29,1,29,3,29,441,8,29,3,29,443,8,29,3,
        29,445,8,29,1,30,1,30,1,30,1,30,1,30,1,30,3,30,453,8,30,1,30,1,30,
        1,30,3,30,458,8,30,1,31,1,31,1,31,3,31,463,8,31,1,31,1,31,1,31,1,
        31,1,31,3,31,470,8,31,1,31,1,31,1,31,3,31,475,8,31,1,32,1,32,1,32,
        1,32,1,33,1,33,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,
        492,8,34,1,35,1,35,1,35,1,35,1,36,1,36,1,36,1,36,1,37,1,37,3,37,
        504,8,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,512,8,37,3,37,514,8,
        37,1,37,1,37,3,37,518,8,37,1,37,1,37,1,37,3,37,523,8,37,1,37,1,37,
        1,37,1,37,3,37,529,8,37,1,37,3,37,532,8,37,1,38,1,38,1,38,1,38,1,
        39,1,39,1,39,1,39,3,39,542,8,39,1,39,1,39,1,39,1,39,1,39,3,39,549,
        8,39,1,39,3,39,552,8,39,1,40,1,40,1,40,1,40,3,40,558,8,40,1,40,1,
        40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,569,8,41,1,42,1,42,1,
        42,1,42,1,42,1,42,1,42,3,42,578,8,42,1,43,1,43,1,43,1,43,1,44,1,
        44,1,44,1,44,1,44,1,44,1,44,3,44,591,8,44,1,44,1,44,1,44,1,44,1,
        44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,
        44,610,8,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,1,44,3,
        44,622,8,44,1,44,1,44,1,44,1,44,1,44,3,44,629,8,44,1,44,1,44,1,44,
        1,44,1,44,3,44,636,8,44,1,44,3,44,639,8,44,1,45,1,45,1,45,4,45,644,
        8,45,11,45,12,45,645,1,45,1,45,1,45,1,45,1,45,4,45,653,8,45,11,45,
        12,45,654,1,45,4,45,658,8,45,11,45,12,45,659,1,45,1,45,1,45,1,45,
        3,45,666,8,45,1,45,1,45,1,45,1,45,1,45,3,45,673,8,45,1,45,4,45,676,
        8,45,11,45,12,45,677,4,45,680,8,45,11,45,12,45,681,1,45,3,45,685,
        8,45,1,46,1,46,1,46,1,46,1,46,1,46,1,47,1,47,1,47,4,47,696,8,47,
        11,47,12,47,697,1,48,1,48,1,48,4,48,703,8,48,11,48,12,48,704,1,49,
        1,49,1,49,1,49,1,49,1,49,1,49,1,50,1,50,1,50,3,50,717,8,50,1,50,
        5,50,720,8,50,10,50,12,50,723,9,50,1,50,1,50,1,50,1,51,1,51,1,51,
        1,51,1,51,1,51,1,51,4,51,735,8,51,11,51,12,51,736,1,51,3,51,740,
        8,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,4,52,751,8,52,
        11,52,12,52,752,1,52,1,52,3,52,757,8,52,1,53,1,53,1,53,1,53,3,53,
        763,8,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
        1,53,3,53,777,8,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
        1,53,1,53,1,53,3,53,791,8,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,
        1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,808,8,53,1,53,1,53,
        1,53,1,54,1,54,1,54,5,54,816,8,54,10,54,12,54,819,9,54,1,54,1,54,
        1,54,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,
        1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,
        3,55,849,8,55,1,56,1,56,3,56,853,8,56,1,56,1,56,1,56,3,56,858,8,
        56,1,56,1,56,3,56,862,8,56,1,56,1,56,3,56,866,8,56,1,56,1,56,3,56,
        870,8,56,3,56,872,8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
        57,1,57,3,57,884,8,57,1,58,1,58,1,58,5,58,889,8,58,10,58,12,58,892,
        9,58,1,58,1,58,1,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,
        1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,915,8,59,10,59,
        12,59,918,9,59,1,59,3,59,921,8,59,1,60,1,60,1,60,3,60,926,8,60,1,
        60,1,60,3,60,930,8,60,1,61,1,61,5,61,934,8,61,10,61,12,61,937,9,
        61,1,61,1,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,5,62,950,
        8,62,10,62,12,62,953,9,62,1,63,1,63,1,63,1,64,1,64,1,64,1,64,1,64,
        4,64,963,8,64,11,64,12,64,964,1,64,1,64,1,65,1,65,1,65,1,65,1,65,
        1,65,0,0,66,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
        38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
        82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,
        120,122,124,126,128,130,0,13,1,0,83,84,1,0,27,28,1,0,156,157,1,0,
        36,38,1,0,87,90,1,0,110,114,1,0,65,66,1,0,152,153,3,0,124,124,136,
        138,158,159,1,0,159,164,1,0,166,171,2,0,124,126,144,144,2,0,2,2,
        176,176,1074,0,133,1,0,0,0,2,154,1,0,0,0,4,156,1,0,0,0,6,160,1,0,
        0,0,8,164,1,0,0,0,10,168,1,0,0,0,12,172,1,0,0,0,14,176,1,0,0,0,16,
        180,1,0,0,0,18,185,1,0,0,0,20,195,1,0,0,0,22,198,1,0,0,0,24,208,
        1,0,0,0,26,213,1,0,0,0,28,255,1,0,0,0,30,257,1,0,0,0,32,281,1,0,
        0,0,34,283,1,0,0,0,36,285,1,0,0,0,38,317,1,0,0,0,40,319,1,0,0,0,
        42,321,1,0,0,0,44,349,1,0,0,0,46,351,1,0,0,0,48,370,1,0,0,0,50,372,
        1,0,0,0,52,405,1,0,0,0,54,407,1,0,0,0,56,411,1,0,0,0,58,444,1,0,
        0,0,60,457,1,0,0,0,62,474,1,0,0,0,64,476,1,0,0,0,66,480,1,0,0,0,
        68,491,1,0,0,0,70,493,1,0,0,0,72,497,1,0,0,0,74,531,1,0,0,0,76,533,
        1,0,0,0,78,551,1,0,0,0,80,553,1,0,0,0,82,568,1,0,0,0,84,577,1,0,
        0,0,86,579,1,0,0,0,88,638,1,0,0,0,90,684,1,0,0,0,92,686,1,0,0,0,
        94,692,1,0,0,0,96,699,1,0,0,0,98,706,1,0,0,0,100,713,1,0,0,0,102,
        739,1,0,0,0,104,756,1,0,0,0,106,758,1,0,0,0,108,812,1,0,0,0,110,
        848,1,0,0,0,112,871,1,0,0,0,114,883,1,0,0,0,116,885,1,0,0,0,118,
        920,1,0,0,0,120,929,1,0,0,0,122,931,1,0,0,0,124,940,1,0,0,0,126,
        954,1,0,0,0,128,957,1,0,0,0,130,968,1,0,0,0,132,134,3,2,1,0,133,
        132,1,0,0,0,134,135,1,0,0,0,135,133,1,0,0,0,135,136,1,0,0,0,136,
        137,1,0,0,0,137,138,5,12,0,0,138,139,5,26,0,0,139,1,1,0,0,0,140,
        155,3,6,3,0,141,155,3,8,4,0,142,155,3,10,5,0,143,155,3,12,6,0,144,
        155,3,26,13,0,145,155,3,16,8,0,146,155,3,14,7,0,147,155,3,22,11,
        0,148,155,3,4,2,0,149,155,3,30,15,0,150,155,3,36,18,0,151,155,3,
        100,50,0,152,155,3,108,54,0,153,155,3,106,53,0,154,140,1,0,0,0,154,
        141,1,0,0,0,154,142,1,0,0,0,154,143,1,0,0,0,154,144,1,0,0,0,154,
        145,1,0,0,0,154,146,1,0,0,0,154,147,1,0,0,0,154,148,1,0,0,0,154,
        149,1,0,0,0,154,150,1,0,0,0,154,151,1,0,0,0,154,152,1,0,0,0,154,
        153,1,0,0,0,155,3,1,0,0,0,156,157,5,145,0,0,157,158,7,0,0,0,158,
        159,5,3,0,0,159,5,1,0,0,0,160,161,5,13,0,0,161,162,5,176,0,0,162,
        163,5,3,0,0,163,7,1,0,0,0,164,165,5,14,0,0,165,166,5,2,0,0,166,167,
        5,3,0,0,167,9,1,0,0,0,168,169,5,19,0,0,169,170,7,1,0,0,170,171,5,
        3,0,0,171,11,1,0,0,0,172,173,5,15,0,0,173,174,5,2,0,0,174,175,5,
        3,0,0,175,13,1,0,0,0,176,177,5,17,0,0,177,178,5,176,0,0,178,179,
        5,3,0,0,179,15,1,0,0,0,180,181,5,18,0,0,181,182,5,25,0,0,182,183,
        7,0,0,0,183,184,5,3,0,0,184,17,1,0,0,0,185,186,5,24,0,0,186,190,
        5,182,0,0,187,189,3,20,10,0,188,187,1,0,0,0,189,192,1,0,0,0,190,
        188,1,0,0,0,190,191,1,0,0,0,191,193,1,0,0,0,192,190,1,0,0,0,193,
        194,5,186,0,0,194,19,1,0,0,0,195,196,5,185,0,0,196,197,5,182,0,0,
        197,21,1,0,0,0,198,202,5,20,0,0,199,201,3,24,12,0,200,199,1,0,0,
        0,201,204,1,0,0,0,202,200,1,0,0,0,202,203,1,0,0,0,203,205,1,0,0,
        0,204,202,1,0,0,0,205,206,5,12,0,0,206,207,5,20,0,0,207,23,1,0,0,
        0,208,209,5,5,0,0,209,210,5,180,0,0,210,211,5,85,0,0,211,212,5,3,
        0,0,212,25,1,0,0,0,213,217,5,16,0,0,214,216,3,28,14,0,215,214,1,
        0,0,0,216,219,1,0,0,0,217,215,1,0,0,0,217,218,1,0,0,0,218,220,1,
        0,0,0,219,217,1,0,0,0,220,221,5,12,0,0,221,222,5,16,0,0,222,27,1,
        0,0,0,223,224,5,116,0,0,224,225,5,117,0,0,225,226,5,176,0,0,226,
        256,5,3,0,0,227,228,5,118,0,0,228,229,5,119,0,0,229,230,5,176,0,
        0,230,256,5,3,0,0,231,232,5,121,0,0,232,233,5,122,0,0,233,234,5,
        176,0,0,234,256,5,3,0,0,235,236,5,124,0,0,236,237,5,127,0,0,237,
        238,5,176,0,0,238,256,5,3,0,0,239,240,5,128,0,0,240,241,5,129,0,
        0,241,242,5,176,0,0,242,256,5,3,0,0,243,244,5,130,0,0,244,245,5,
        131,0,0,245,246,5,176,0,0,246,256,5,3,0,0,247,248,5,132,0,0,248,
        249,5,133,0,0,249,250,5,176,0,0,250,256,5,3,0,0,251,252,5,134,0,
        0,252,253,5,135,0,0,253,254,5,176,0,0,254,256,5,3,0,0,255,223,1,
        0,0,0,255,227,1,0,0,0,255,231,1,0,0,0,255,235,1,0,0,0,255,239,1,
        0,0,0,255,243,1,0,0,0,255,247,1,0,0,0,255,251,1,0,0,0,256,29,1,0,
        0,0,257,258,5,6,0,0,258,262,5,180,0,0,259,261,3,32,16,0,260,259,
        1,0,0,0,261,264,1,0,0,0,262,260,1,0,0,0,262,263,1,0,0,0,263,265,
        1,0,0,0,264,262,1,0,0,0,265,266,5,12,0,0,266,267,5,180,0,0,267,31,
        1,0,0,0,268,269,5,82,0,0,269,270,3,114,57,0,270,271,5,3,0,0,271,
        282,1,0,0,0,272,273,5,78,0,0,273,274,3,34,17,0,274,275,5,3,0,0,275,
        282,1,0,0,0,276,277,5,79,0,0,277,278,5,176,0,0,278,279,5,80,0,0,
        279,280,5,176,0,0,280,282,5,3,0,0,281,268,1,0,0,0,281,272,1,0,0,
        0,281,276,1,0,0,0,282,33,1,0,0,0,283,284,7,2,0,0,284,35,1,0,0,0,
        285,286,5,5,0,0,286,290,5,180,0,0,287,289,3,38,19,0,288,287,1,0,
        0,0,289,292,1,0,0,0,290,288,1,0,0,0,290,291,1,0,0,0,291,293,1,0,
        0,0,292,290,1,0,0,0,293,294,5,12,0,0,294,295,5,180,0,0,295,37,1,
        0,0,0,296,318,3,40,20,0,297,318,3,42,21,0,298,318,3,46,23,0,299,
        318,3,88,44,0,300,318,3,50,25,0,301,318,3,74,37,0,302,318,3,130,
        65,0,303,318,3,56,28,0,304,318,3,64,32,0,305,318,3,54,27,0,306,318,
        3,78,39,0,307,318,3,80,40,0,308,318,3,68,34,0,309,318,3,90,45,0,
        310,318,3,70,35,0,311,318,3,72,36,0,312,318,3,82,41,0,313,318,3,
        84,42,0,314,318,3,86,43,0,315,318,3,76,38,0,316,318,3,52,26,0,317,
        296,1,0,0,0,317,297,1,0,0,0,317,298,1,0,0,0,317,299,1,0,0,0,317,
        300,1,0,0,0,317,301,1,0,0,0,317,302,1,0,0,0,317,303,1,0,0,0,317,
        304,1,0,0,0,317,305,1,0,0,0,317,306,1,0,0,0,317,307,1,0,0,0,317,
        308,1,0,0,0,317,309,1,0,0,0,317,310,1,0,0,0,317,311,1,0,0,0,317,
        312,1,0,0,0,317,313,1,0,0,0,317,314,1,0,0,0,317,315,1,0,0,0,317,
        316,1,0,0,0,318,39,1,0,0,0,319,320,3,130,65,0,320,41,1,0,0,0,321,
        322,5,34,0,0,322,323,7,3,0,0,323,324,3,44,22,0,324,325,5,3,0,0,325,
        43,1,0,0,0,326,350,5,176,0,0,327,329,5,132,0,0,328,330,5,176,0,0,
        329,328,1,0,0,0,330,331,1,0,0,0,331,329,1,0,0,0,331,332,1,0,0,0,
        332,333,1,0,0,0,333,341,5,3,0,0,334,336,5,40,0,0,335,337,5,176,0,
        0,336,335,1,0,0,0,337,338,1,0,0,0,338,336,1,0,0,0,338,339,1,0,0,
        0,339,340,1,0,0,0,340,342,5,3,0,0,341,334,1,0,0,0,341,342,1,0,0,
        0,342,343,1,0,0,0,343,345,5,42,0,0,344,346,5,176,0,0,345,344,1,0,
        0,0,346,347,1,0,0,0,347,345,1,0,0,0,347,348,1,0,0,0,348,350,1,0,
        0,0,349,326,1,0,0,0,349,327,1,0,0,0,350,45,1,0,0,0,351,352,5,35,
        0,0,352,353,5,37,0,0,353,354,3,48,24,0,354,355,5,3,0,0,355,47,1,
        0,0,0,356,371,5,176,0,0,357,359,5,59,0,0,358,360,5,176,0,0,359,358,
        1,0,0,0,360,361,1,0,0,0,361,359,1,0,0,0,361,362,1,0,0,0,362,363,
        1,0,0,0,363,364,5,3,0,0,364,366,5,42,0,0,365,367,5,176,0,0,366,365,
        1,0,0,0,367,368,1,0,0,0,368,366,1,0,0,0,368,369,1,0,0,0,369,371,
        1,0,0,0,370,356,1,0,0,0,370,357,1,0,0,0,371,49,1,0,0,0,372,374,5,
        55,0,0,373,375,5,58,0,0,374,373,1,0,0,0,374,375,1,0,0,0,375,378,
        1,0,0,0,376,377,5,59,0,0,377,379,5,176,0,0,378,376,1,0,0,0,378,379,
        1,0,0,0,379,380,1,0,0,0,380,381,5,41,0,0,381,386,5,176,0,0,382,383,
        5,39,0,0,383,384,5,176,0,0,384,385,5,31,0,0,385,387,5,176,0,0,386,
        382,1,0,0,0,387,388,1,0,0,0,388,386,1,0,0,0,388,389,1,0,0,0,389,
        390,1,0,0,0,390,391,5,3,0,0,391,51,1,0,0,0,392,393,5,98,0,0,393,
        394,5,176,0,0,394,406,5,3,0,0,395,396,5,99,0,0,396,397,5,176,0,0,
        397,398,5,176,0,0,398,406,5,3,0,0,399,400,5,100,0,0,400,401,5,176,
        0,0,401,406,5,3,0,0,402,403,5,148,0,0,403,404,5,176,0,0,404,406,
        5,3,0,0,405,392,1,0,0,0,405,395,1,0,0,0,405,399,1,0,0,0,405,402,
        1,0,0,0,406,53,1,0,0,0,407,408,5,86,0,0,408,409,7,4,0,0,409,410,
        5,3,0,0,410,55,1,0,0,0,411,412,5,31,0,0,412,414,5,176,0,0,413,415,
        3,58,29,0,414,413,1,0,0,0,414,415,1,0,0,0,415,416,1,0,0,0,416,417,
        5,3,0,0,417,57,1,0,0,0,418,419,5,149,0,0,419,420,5,176,0,0,420,422,
        5,176,0,0,421,423,3,60,30,0,422,421,1,0,0,0,422,423,1,0,0,0,423,
        445,1,0,0,0,424,425,5,106,0,0,425,429,5,176,0,0,426,427,5,149,0,
        0,427,428,5,176,0,0,428,430,5,176,0,0,429,426,1,0,0,0,429,430,1,
        0,0,0,430,445,1,0,0,0,431,432,5,107,0,0,432,433,5,176,0,0,433,434,
        5,72,0,0,434,442,5,176,0,0,435,436,5,108,0,0,436,437,5,176,0,0,437,
        438,5,72,0,0,438,440,5,176,0,0,439,441,5,109,0,0,440,439,1,0,0,0,
        440,441,1,0,0,0,441,443,1,0,0,0,442,435,1,0,0,0,442,443,1,0,0,0,
        443,445,1,0,0,0,444,418,1,0,0,0,444,424,1,0,0,0,444,431,1,0,0,0,
        445,59,1,0,0,0,446,458,5,105,0,0,447,448,5,94,0,0,448,452,5,176,
        0,0,449,450,5,149,0,0,450,451,5,176,0,0,451,453,5,176,0,0,452,449,
        1,0,0,0,452,453,1,0,0,0,453,458,1,0,0,0,454,455,5,149,0,0,455,456,
        5,176,0,0,456,458,5,176,0,0,457,446,1,0,0,0,457,447,1,0,0,0,457,
        454,1,0,0,0,458,61,1,0,0,0,459,460,5,5,0,0,460,462,5,180,0,0,461,
        463,5,70,0,0,462,461,1,0,0,0,462,463,1,0,0,0,463,475,1,0,0,0,464,
        465,5,71,0,0,465,466,5,176,0,0,466,467,5,72,0,0,467,469,5,176,0,
        0,468,470,5,73,0,0,469,468,1,0,0,0,469,470,1,0,0,0,470,475,1,0,0,
        0,471,475,5,74,0,0,472,473,5,76,0,0,473,475,5,176,0,0,474,459,1,
        0,0,0,474,464,1,0,0,0,474,471,1,0,0,0,474,472,1,0,0,0,475,63,1,0,
        0,0,476,477,5,29,0,0,477,478,3,66,33,0,478,479,5,3,0,0,479,65,1,
        0,0,0,480,481,7,5,0,0,481,67,1,0,0,0,482,483,5,59,0,0,483,484,5,
        176,0,0,484,492,5,3,0,0,485,486,5,60,0,0,486,487,5,176,0,0,487,492,
        5,3,0,0,488,489,5,61,0,0,489,490,5,176,0,0,490,492,5,3,0,0,491,482,
        1,0,0,0,491,485,1,0,0,0,491,488,1,0,0,0,492,69,1,0,0,0,493,494,5,
        76,0,0,494,495,5,176,0,0,495,496,5,3,0,0,496,71,1,0,0,0,497,498,
        5,77,0,0,498,499,5,176,0,0,499,500,5,3,0,0,500,73,1,0,0,0,501,503,
        5,63,0,0,502,504,7,6,0,0,503,502,1,0,0,0,503,504,1,0,0,0,504,505,
        1,0,0,0,505,506,5,176,0,0,506,513,5,176,0,0,507,508,5,59,0,0,508,
        511,5,176,0,0,509,510,5,67,0,0,510,512,5,176,0,0,511,509,1,0,0,0,
        511,512,1,0,0,0,512,514,1,0,0,0,513,507,1,0,0,0,513,514,1,0,0,0,
        514,517,1,0,0,0,515,516,5,62,0,0,516,518,5,176,0,0,517,515,1,0,0,
        0,517,518,1,0,0,0,518,519,1,0,0,0,519,532,5,3,0,0,520,522,5,64,0,
        0,521,523,7,6,0,0,522,521,1,0,0,0,522,523,1,0,0,0,523,524,1,0,0,
        0,524,525,5,176,0,0,525,528,5,176,0,0,526,527,5,59,0,0,527,529,5,
        176,0,0,528,526,1,0,0,0,528,529,1,0,0,0,529,530,1,0,0,0,530,532,
        5,3,0,0,531,501,1,0,0,0,531,520,1,0,0,0,532,75,1,0,0,0,533,534,5,
        97,0,0,534,535,5,176,0,0,535,536,5,3,0,0,536,77,1,0,0,0,537,541,
        5,91,0,0,538,542,5,176,0,0,539,540,5,176,0,0,540,542,5,176,0,0,541,
        538,1,0,0,0,541,539,1,0,0,0,542,543,1,0,0,0,543,552,5,3,0,0,544,
        548,5,92,0,0,545,549,5,176,0,0,546,547,5,176,0,0,547,549,5,176,0,
        0,548,545,1,0,0,0,548,546,1,0,0,0,549,550,1,0,0,0,550,552,5,3,0,
        0,551,537,1,0,0,0,551,544,1,0,0,0,552,79,1,0,0,0,553,557,5,93,0,
        0,554,558,5,176,0,0,555,556,5,176,0,0,556,558,5,176,0,0,557,554,
        1,0,0,0,557,555,1,0,0,0,558,559,1,0,0,0,559,560,5,3,0,0,560,81,1,
        0,0,0,561,562,5,121,0,0,562,563,5,176,0,0,563,569,5,3,0,0,564,565,
        5,121,0,0,565,566,5,123,0,0,566,567,5,176,0,0,567,569,5,3,0,0,568,
        561,1,0,0,0,568,564,1,0,0,0,569,83,1,0,0,0,570,571,5,118,0,0,571,
        572,5,176,0,0,572,578,5,3,0,0,573,574,5,118,0,0,574,575,5,120,0,
        0,575,576,5,176,0,0,576,578,5,3,0,0,577,570,1,0,0,0,577,573,1,0,
        0,0,578,85,1,0,0,0,579,580,5,115,0,0,580,581,5,176,0,0,581,582,5,
        3,0,0,582,87,1,0,0,0,583,584,5,43,0,0,584,585,3,128,64,0,585,586,
        5,3,0,0,586,639,1,0,0,0,587,588,5,44,0,0,588,590,5,176,0,0,589,591,
        5,56,0,0,590,589,1,0,0,0,590,591,1,0,0,0,591,592,1,0,0,0,592,639,
        5,3,0,0,593,594,5,46,0,0,594,595,5,176,0,0,595,639,5,3,0,0,596,597,
        5,47,0,0,597,598,5,176,0,0,598,639,5,3,0,0,599,600,5,48,0,0,600,
        601,5,176,0,0,601,639,5,3,0,0,602,603,5,51,0,0,603,604,5,176,0,0,
        604,639,5,3,0,0,605,609,5,52,0,0,606,610,5,176,0,0,607,608,5,57,
        0,0,608,610,3,128,64,0,609,606,1,0,0,0,609,607,1,0,0,0,610,611,1,
        0,0,0,611,639,5,3,0,0,612,613,5,53,0,0,613,614,5,176,0,0,614,639,
        5,3,0,0,615,616,5,54,0,0,616,617,5,175,0,0,617,639,5,3,0,0,618,619,
        5,45,0,0,619,621,5,176,0,0,620,622,5,56,0,0,621,620,1,0,0,0,621,
        622,1,0,0,0,622,623,1,0,0,0,623,639,5,3,0,0,624,628,5,49,0,0,625,
        629,5,176,0,0,626,627,5,57,0,0,627,629,3,128,64,0,628,625,1,0,0,
        0,628,626,1,0,0,0,629,630,1,0,0,0,630,639,5,3,0,0,631,635,5,50,0,
        0,632,636,5,176,0,0,633,634,5,57,0,0,634,636,3,128,64,0,635,632,
        1,0,0,0,635,633,1,0,0,0,636,637,1,0,0,0,637,639,5,3,0,0,638,583,
        1,0,0,0,638,587,1,0,0,0,638,593,1,0,0,0,638,596,1,0,0,0,638,599,
        1,0,0,0,638,602,1,0,0,0,638,605,1,0,0,0,638,612,1,0,0,0,638,615,
        1,0,0,0,638,618,1,0,0,0,638,624,1,0,0,0,638,631,1,0,0,0,639,89,1,
        0,0,0,640,641,5,32,0,0,641,643,5,33,0,0,642,644,3,92,46,0,643,642,
        1,0,0,0,644,645,1,0,0,0,645,643,1,0,0,0,645,646,1,0,0,0,646,647,
        1,0,0,0,647,648,5,3,0,0,648,685,1,0,0,0,649,650,5,32,0,0,650,652,
        5,75,0,0,651,653,5,176,0,0,652,651,1,0,0,0,653,654,1,0,0,0,654,652,
        1,0,0,0,654,655,1,0,0,0,655,657,1,0,0,0,656,658,3,94,47,0,657,656,
        1,0,0,0,658,659,1,0,0,0,659,657,1,0,0,0,659,660,1,0,0,0,660,661,
        1,0,0,0,661,665,5,3,0,0,662,663,3,96,48,0,663,664,5,3,0,0,664,666,
        1,0,0,0,665,662,1,0,0,0,665,666,1,0,0,0,666,685,1,0,0,0,667,679,
        5,95,0,0,668,669,5,59,0,0,669,672,5,176,0,0,670,671,5,96,0,0,671,
        673,5,176,0,0,672,670,1,0,0,0,672,673,1,0,0,0,673,675,1,0,0,0,674,
        676,5,31,0,0,675,674,1,0,0,0,676,677,1,0,0,0,677,675,1,0,0,0,677,
        678,1,0,0,0,678,680,1,0,0,0,679,668,1,0,0,0,680,681,1,0,0,0,681,
        679,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,685,5,3,0,0,684,
        640,1,0,0,0,684,649,1,0,0,0,684,667,1,0,0,0,685,91,1,0,0,0,686,687,
        5,72,0,0,687,688,5,176,0,0,688,689,5,31,0,0,689,690,5,176,0,0,690,
        691,5,3,0,0,691,93,1,0,0,0,692,693,5,59,0,0,693,695,5,176,0,0,694,
        696,5,176,0,0,695,694,1,0,0,0,696,697,1,0,0,0,697,695,1,0,0,0,697,
        698,1,0,0,0,698,95,1,0,0,0,699,700,5,32,0,0,700,702,5,94,0,0,701,
        703,3,98,49,0,702,701,1,0,0,0,703,704,1,0,0,0,704,702,1,0,0,0,704,
        705,1,0,0,0,705,97,1,0,0,0,706,707,5,59,0,0,707,708,5,176,0,0,708,
        709,5,72,0,0,709,710,5,176,0,0,710,711,5,31,0,0,711,712,5,176,0,
        0,712,99,1,0,0,0,713,714,5,7,0,0,714,716,5,180,0,0,715,717,5,101,
        0,0,716,715,1,0,0,0,716,717,1,0,0,0,717,721,1,0,0,0,718,720,3,102,
        51,0,719,718,1,0,0,0,720,723,1,0,0,0,721,719,1,0,0,0,721,722,1,0,
        0,0,722,724,1,0,0,0,723,721,1,0,0,0,724,725,5,12,0,0,725,726,5,180,
        0,0,726,101,1,0,0,0,727,728,5,121,0,0,728,729,5,176,0,0,729,740,
        5,3,0,0,730,731,5,5,0,0,731,732,5,180,0,0,732,734,5,3,0,0,733,735,
        3,104,52,0,734,733,1,0,0,0,735,736,1,0,0,0,736,734,1,0,0,0,736,737,
        1,0,0,0,737,740,1,0,0,0,738,740,3,130,65,0,739,727,1,0,0,0,739,730,
        1,0,0,0,739,738,1,0,0,0,740,103,1,0,0,0,741,742,5,102,0,0,742,743,
        3,126,63,0,743,744,3,126,63,0,744,745,5,3,0,0,745,757,1,0,0,0,746,
        747,5,103,0,0,747,748,3,126,63,0,748,750,3,126,63,0,749,751,3,126,
        63,0,750,749,1,0,0,0,751,752,1,0,0,0,752,750,1,0,0,0,752,753,1,0,
        0,0,753,754,1,0,0,0,754,755,5,3,0,0,755,757,1,0,0,0,756,741,1,0,
        0,0,756,746,1,0,0,0,757,105,1,0,0,0,758,759,5,8,0,0,759,760,5,180,
        0,0,760,762,5,22,0,0,761,763,5,101,0,0,762,761,1,0,0,0,762,763,1,
        0,0,0,763,764,1,0,0,0,764,765,5,5,0,0,765,766,5,180,0,0,766,767,
        5,3,0,0,767,768,5,63,0,0,768,769,5,176,0,0,769,770,5,176,0,0,770,
        776,5,3,0,0,771,772,5,59,0,0,772,773,5,176,0,0,773,774,5,81,0,0,
        774,775,5,176,0,0,775,777,5,3,0,0,776,771,1,0,0,0,776,777,1,0,0,
        0,777,778,1,0,0,0,778,779,5,5,0,0,779,780,5,180,0,0,780,781,5,3,
        0,0,781,782,5,63,0,0,782,783,5,176,0,0,783,784,5,176,0,0,784,790,
        5,3,0,0,785,786,5,59,0,0,786,787,5,176,0,0,787,788,5,81,0,0,788,
        789,5,176,0,0,789,791,5,3,0,0,790,785,1,0,0,0,790,791,1,0,0,0,791,
        792,1,0,0,0,792,793,5,5,0,0,793,794,5,180,0,0,794,795,5,3,0,0,795,
        796,5,102,0,0,796,797,3,126,63,0,797,798,3,126,63,0,798,799,5,3,
        0,0,799,800,5,31,0,0,800,801,5,176,0,0,801,802,5,80,0,0,802,803,
        5,176,0,0,803,807,5,3,0,0,804,805,5,121,0,0,805,806,5,176,0,0,806,
        808,5,3,0,0,807,804,1,0,0,0,807,808,1,0,0,0,808,809,1,0,0,0,809,
        810,5,12,0,0,810,811,5,180,0,0,811,107,1,0,0,0,812,813,5,9,0,0,813,
        817,5,180,0,0,814,816,3,110,55,0,815,814,1,0,0,0,816,819,1,0,0,0,
        817,815,1,0,0,0,817,818,1,0,0,0,818,820,1,0,0,0,819,817,1,0,0,0,
        820,821,5,12,0,0,821,822,5,180,0,0,822,109,1,0,0,0,823,824,5,78,
        0,0,824,825,3,112,56,0,825,826,5,3,0,0,826,849,1,0,0,0,827,828,5,
        10,0,0,828,829,5,180,0,0,829,849,5,3,0,0,830,831,5,104,0,0,831,832,
        3,126,63,0,832,833,5,3,0,0,833,849,1,0,0,0,834,835,5,79,0,0,835,
        836,5,176,0,0,836,837,5,80,0,0,837,838,5,176,0,0,838,849,5,3,0,0,
        839,840,5,82,0,0,840,841,3,114,57,0,841,842,5,3,0,0,842,849,1,0,
        0,0,843,844,5,6,0,0,844,845,5,180,0,0,845,849,5,3,0,0,846,849,3,
        116,58,0,847,849,3,122,61,0,848,823,1,0,0,0,848,827,1,0,0,0,848,
        830,1,0,0,0,848,834,1,0,0,0,848,839,1,0,0,0,848,843,1,0,0,0,848,
        846,1,0,0,0,848,847,1,0,0,0,849,111,1,0,0,0,850,852,5,150,0,0,851,
        853,5,154,0,0,852,851,1,0,0,0,852,853,1,0,0,0,853,872,1,0,0,0,854,
        872,5,155,0,0,855,857,5,151,0,0,856,858,7,7,0,0,857,856,1,0,0,0,
        857,858,1,0,0,0,858,872,1,0,0,0,859,861,5,157,0,0,860,862,7,8,0,
        0,861,860,1,0,0,0,861,862,1,0,0,0,862,872,1,0,0,0,863,865,5,156,
        0,0,864,866,7,9,0,0,865,864,1,0,0,0,865,866,1,0,0,0,866,872,1,0,
        0,0,867,869,5,165,0,0,868,870,7,10,0,0,869,868,1,0,0,0,869,870,1,
        0,0,0,870,872,1,0,0,0,871,850,1,0,0,0,871,854,1,0,0,0,871,855,1,
        0,0,0,871,859,1,0,0,0,871,863,1,0,0,0,871,867,1,0,0,0,872,113,1,
        0,0,0,873,884,5,173,0,0,874,884,5,174,0,0,875,884,5,172,0,0,876,
        877,5,173,0,0,877,884,5,174,0,0,878,879,5,174,0,0,879,884,5,172,
        0,0,880,881,5,173,0,0,881,882,5,174,0,0,882,884,5,172,0,0,883,873,
        1,0,0,0,883,874,1,0,0,0,883,875,1,0,0,0,883,876,1,0,0,0,883,878,
        1,0,0,0,883,880,1,0,0,0,884,115,1,0,0,0,885,886,5,11,0,0,886,890,
        5,180,0,0,887,889,3,118,59,0,888,887,1,0,0,0,889,892,1,0,0,0,890,
        888,1,0,0,0,890,891,1,0,0,0,891,893,1,0,0,0,892,890,1,0,0,0,893,
        894,5,12,0,0,894,895,5,180,0,0,895,117,1,0,0,0,896,897,5,86,0,0,
        897,898,3,120,60,0,898,899,5,3,0,0,899,921,1,0,0,0,900,901,5,140,
        0,0,901,902,7,11,0,0,902,921,5,3,0,0,903,904,5,141,0,0,904,905,5,
        142,0,0,905,921,5,3,0,0,906,907,5,146,0,0,907,908,5,176,0,0,908,
        921,5,3,0,0,909,910,5,147,0,0,910,911,5,176,0,0,911,921,5,3,0,0,
        912,916,5,143,0,0,913,915,3,124,62,0,914,913,1,0,0,0,915,918,1,0,
        0,0,916,914,1,0,0,0,916,917,1,0,0,0,917,919,1,0,0,0,918,916,1,0,
        0,0,919,921,5,12,0,0,920,896,1,0,0,0,920,900,1,0,0,0,920,903,1,0,
        0,0,920,906,1,0,0,0,920,909,1,0,0,0,920,912,1,0,0,0,921,119,1,0,
        0,0,922,930,5,136,0,0,923,925,5,137,0,0,924,926,5,139,0,0,925,924,
        1,0,0,0,925,926,1,0,0,0,926,930,1,0,0,0,927,930,5,138,0,0,928,930,
        5,162,0,0,929,922,1,0,0,0,929,923,1,0,0,0,929,927,1,0,0,0,929,928,
        1,0,0,0,930,121,1,0,0,0,931,935,5,25,0,0,932,934,3,124,62,0,933,
        932,1,0,0,0,934,937,1,0,0,0,935,933,1,0,0,0,935,936,1,0,0,0,936,
        938,1,0,0,0,937,935,1,0,0,0,938,939,5,12,0,0,939,123,1,0,0,0,940,
        941,5,5,0,0,941,942,5,180,0,0,942,951,5,3,0,0,943,944,5,102,0,0,
        944,945,5,176,0,0,945,946,5,176,0,0,946,947,5,176,0,0,947,948,5,
        176,0,0,948,950,5,3,0,0,949,943,1,0,0,0,950,953,1,0,0,0,951,949,
        1,0,0,0,951,952,1,0,0,0,952,125,1,0,0,0,953,951,1,0,0,0,954,955,
        5,176,0,0,955,956,5,176,0,0,956,127,1,0,0,0,957,962,5,177,0,0,958,
        959,5,177,0,0,959,960,5,176,0,0,960,961,5,176,0,0,961,963,5,178,
        0,0,962,958,1,0,0,0,963,964,1,0,0,0,964,962,1,0,0,0,964,965,1,0,
        0,0,965,966,1,0,0,0,966,967,5,178,0,0,967,129,1,0,0,0,968,969,5,
        30,0,0,969,970,5,180,0,0,970,971,7,12,0,0,971,972,5,3,0,0,972,131,
        1,0,0,0,90,135,154,190,202,217,255,262,281,290,317,331,338,341,347,
        349,361,368,370,374,378,388,405,414,422,429,440,442,444,452,457,
        462,469,474,491,503,511,513,517,522,528,531,541,548,551,557,568,
        577,590,609,621,628,635,638,645,654,659,665,672,677,681,684,697,
        704,716,721,736,739,752,756,762,776,790,807,817,848,852,857,861,
        865,869,871,883,890,916,920,925,929,935,951,964
    ]

class lefParser ( Parser ):

    grammarFileName = "lef.g"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'LAYER'", "'SITE'", "'VIA'", "'VIARULE'", 
                     "'MACRO'", "'FOREIGN'", "'PIN'", "'END'", "'VERSION'", 
                     "'BUSBITCHARS'", "'DIVIDERCHAR'", "'UNITS'", "'MANUFACTURINGGRID'", 
                     "'USEMINSPACING'", "'CLEARANCEMEASURE'", "'PROPERTYDEFINITIONS'", 
                     "'MAXVIASTACK'", "'GENERATE'", "'NONDEFAULTRULE'", 
                     "'BEGINEXT'", "'OBS'", "'LIBRARY'", "'MAXXY'", "'EUCLIDEAN'", 
                     "'TYPE'", "'PROPERTY'", "'SPACING'", "'SPACINGTABLE'", 
                     "'ORTHOGNAL'", "'ACCURRENTDENSITY'", "'DCCURRENTDENSITY'", 
                     "'PEAK'", "'AVERAGE'", "'RMS'", "'ARRAYCUTS'", "'CUTAREA'", 
                     "'CUTSPACING'", "'TABLEENTRIES'", "'ANTENNAAREADIFFREDUCEPWL'", 
                     "'ANTENNAAREAFACTOR'", "'ANTENNASIDEAREAFACTOR'", "'ANTENNAAREAMINUSDIFF'", 
                     "'ANTENNAAREARATIO'", "'ANTENNASIDEAREARATIO'", "'ANTENNADIFFAREARATIO'", 
                     "'ANTENNADIFFSIDEAREARATIO'", "'ANTENNACUMAREARATIO'", 
                     "'ANTENNACUMDIFFAREARATIO'", "'ANTENNAGATEPLUSDIFF'", 
                     "'ANTENNAMODEL'", "'ARRAYSPACING'", "'DIFFUSEONLY'", 
                     "'PWL'", "'LONGARRAY'", "'WIDTH'", "'MINWIDTH'", "'MAXWIDTH'", 
                     "'LENGTH'", "'ENCLOSURE'", "'PREFERENCLOSURE'", "'ABOVE'", 
                     "'BELOW'", "'EXCEPTEXTRACUT'", "'CENTERTOCENTER'", 
                     "'SAMENET'", "'STACK'", "'ADJACENTCUTS'", "'WITHIN'", 
                     "'EXCEPTSAMEPGNET'", "'PARALLELOVERLAP'", "'PARALLELRUNLENGTH'", 
                     "'AREA'", "'THICKNESS'", "'CLASS'", "'SIZE'", "'BY'", 
                     "'TO'", "'SYMMETRY'", "'ON'", "'OFF'", "'STRING'", 
                     "'DIRECTION'", "'VERTICAL'", "'HORIZONTAL'", "'DIAG45'", 
                     "'DIAG135'", "'PITCH'", "'DIAGPITCH'", "'OFFSET'", 
                     "'INFLUENCE'", "'TWOWIDTHS'", "'PRL'", "'MINENCLOSEDAREA'", 
                     "'MAXIMUMDENSITY'", "'DENSITYCHECKWINDOW'", "'DENSITYCHECKSTEP'", 
                     "'DEFAULT'", "'RECT'", "'POLYGON'", "'ORIGIN'", "'USERANGETHRESHOLD'", 
                     "'LENGTHTHRESHOLD'", "'ENDOFLINE'", "'PARALLELEDGE'", 
                     "'TWOEDGES'", "'CUT'", "'IMPLANT'", "'MASTERSLICE'", 
                     "'OVERLAP'", "'ROUTING'", "'EDGECAPACITANCE'", "'TIME'", 
                     "'NANOSECONDS'", "'CAPACITANCE'", "'PICOFARADS'", "'CPERSQDIST'", 
                     "'RESISTANCE'", "'OHMS'", "'RPERSQ'", "'POWER'", "'GROUND'", 
                     "'SIGNAL'", "'MILLIWATTS'", "'VOLTAGE'", "'VOLTS'", 
                     "'DATABASE'", "'MICRONS'", "'FREQUENCY'", "'MEGAHERTZ'", 
                     "'CURRENT'", "'MILLIAMPS'", "'INPUT'", "'OUTPUT'", 
                     "'INOUT'", "'TRISTATE'", "'USE'", "'SHAPE'", "'ABUTMENT'", 
                     "'PORT'", "'CLOCK'", "'NOWIREEXTENSIONATPIN'", "'ANTENNAGATEAREA'", 
                     "'ANTENNADIFFAREA'", "'MINIMUMDENSITY'", "'RANGE'", 
                     "'COVER'", "'BLOCK'", "'BLACKBOX'", "'SOFT'", "'BUMP'", 
                     "'RING'", "<INVALID>", "<INVALID>", "'AREAIO'", "'SPACER'", 
                     "'ANTENNACELL'", "'WELLTAP'", "'FEEDTHRU'", "'TIEHIGH'", 
                     "'TIELOW'", "'ENDCAP'", "'PRE'", "'POST'", "'TOPLEFT'", 
                     "'TOPRIGHT'", "'BOTTOMLEFT'", "'BOTTOMRIGHT'", "'R90'", 
                     "'X'", "'Y'", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'ENDEXT'" ]

    symbolicNames = [ "<INVALID>", "Comment", "String", "Semicolon", "Ws", 
                      "KW_Layer", "KW_Site", "KW_Via", "KW_ViaRule", "KW_Macro", 
                      "KW_Foreign", "KW_Pin", "KW_End", "KW_Version", "KW_BusBitChars", 
                      "KW_DividerChar", "KW_Units", "KW_ManufacturingGrid", 
                      "KW_UseMinSpacing", "KW_ClearanceMeasure", "KW_PropertyDefinitions", 
                      "KW_MaxViaStack", "KW_Generate", "KW_NonDefaultRule", 
                      "KW_BeginExt", "KW_Obs", "KW_Library", "KW_MaxXY", 
                      "KW_Euclidean", "KW_Type", "KW_Property", "KW_Spacing", 
                      "KW_SpacingTable", "KW_Orthognal", "KW_ACCurrentDensity", 
                      "KW_DCCurrentDensity", "KW_Peak", "KW_Average", "KW_RMS", 
                      "KW_ArrayCuts", "KW_CutArea", "KW_CutSpacing", "KW_TableEntries", 
                      "KW_AntennaAreaDiffReducePWL", "KW_AntennaAreaFactor", 
                      "KW_AntennaSideAreaFactor", "KW_AntennaAreaMinusDiff", 
                      "KW_AntennaAreaRatio", "KW_AntennaSideAreaRatio", 
                      "KW_AntennaDiffAreaRatio", "KW_AntennaDiffSideAreaRatio", 
                      "KW_AntennaCumAreaRatio", "KW_AntennaCumDiffAreaRatio", 
                      "KW_AntennaGatePlusDiff", "KW_AntennaModel", "KW_ArraySpacing", 
                      "KW_DiffuseOnly", "KW_PWL", "KW_LongArray", "KW_Width", 
                      "KW_MinWidth", "KW_MaxWidth", "KW_Length", "KW_Enclosure", 
                      "KW_PreferEnclosure", "KW_Above", "KW_Below", "KW_ExceptExtraCut", 
                      "KW_CenterToCenter", "KW_SameNet", "KW_Stack", "KW_AdjacentCuts", 
                      "KW_Within", "KW_ExceptSamePGNet", "KW_ParallelOverlap", 
                      "KW_ParallelRunLength", "KW_Area", "KW_Thickness", 
                      "KW_Class", "KW_Size", "KW_By", "KW_To", "KW_Symmetry", 
                      "KW_On", "KW_Off", "KW_String", "KW_Direction", "KW_Vertical", 
                      "KW_Horizontal", "KW_Diag45", "KW_Diag135", "KW_Pitch", 
                      "KW_DiagPitch", "KW_Offset", "KW_Influence", "KW_TwoWidths", 
                      "KW_PRL", "KW_MinEnclosedArea", "KW_MaximumDensity", 
                      "KW_DensityCheckWindow", "KW_DensityCheckStep", "KW_Default", 
                      "KW_Rect", "KW_Polygon", "KW_Origin", "KW_UseRangeThreshold", 
                      "KW_LengthThreshold", "KW_EndOfLine", "KW_ParallelEdge", 
                      "KW_TwoEdges", "KW_Cut", "KW_Implant", "KW_Masterslice", 
                      "KW_Overlap", "KW_Routing", "KW_EdgeCapacitance", 
                      "KW_Time", "KW_Nanoseconds", "KW_Capacitance", "KW_PicoFarads", 
                      "KW_CPerSqDist", "KW_Resistance", "KW_Ohms", "KW_RPerSq", 
                      "KW_Power", "KW_Ground", "KW_Signal", "KW_Milliwatts", 
                      "KW_Voltage", "KW_Volts", "KW_Database", "KW_Microns", 
                      "KW_Frequency", "KW_Megahertz", "KW_Current", "KW_Milliamps", 
                      "KW_Input", "KW_Output", "KW_Inout", "KW_Tristate", 
                      "KW_Use", "KW_Shape", "KW_Abutment", "KW_Port", "KW_Clock", 
                      "KW_NoWireExtensionAtPin", "KW_AntennaGateArea", "KW_AntennaDiffArea", 
                      "KW_MinimumDensity", "KW_Range", "KW_Cover", "KW_Block", 
                      "KW_Blackbox", "KW_Soft", "KW_Bump", "KW_Ring", "KW_Core", 
                      "KW_Pad", "KW_AreaIO", "KW_Spacer", "KW_AntennaCell", 
                      "KW_Welltap", "KW_Feedthru", "KW_TieHigh", "KW_TieLow", 
                      "KW_Endcap", "KW_Pre", "KW_Post", "KW_TopLeft", "KW_TopRight", 
                      "KW_BottomLeft", "KW_BottomRight", "KW_R90", "KW_X", 
                      "KW_Y", "Oxide", "Number", "LParen", "RParen", "NAME_MODE_WS", 
                      "Name", "EM_Comment", "EM_String", "EM_Semicolon", 
                      "EM_Ws", "EM_Name", "EM_KW_EndExt" ]

    RULE_top = 0
    RULE_statement = 1
    RULE_nowireextensionatpin_statement = 2
    RULE_version_statement = 3
    RULE_busbitchar_statement = 4
    RULE_clearancemeasure_statement = 5
    RULE_dividerchar_statement = 6
    RULE_mfg_grid_statement = 7
    RULE_useminspacing_statement = 8
    RULE_ext_statement = 9
    RULE_extension = 10
    RULE_propertydefinitions_statement = 11
    RULE_property_definition = 12
    RULE_units_statement = 13
    RULE_unit_declaration = 14
    RULE_site_statement = 15
    RULE_site_rule = 16
    RULE_site_class = 17
    RULE_layer_statement = 18
    RULE_layer_rule = 19
    RULE_lef58_property_rule = 20
    RULE_ac_density_rule = 21
    RULE_ac_density_value = 22
    RULE_dc_density_rule = 23
    RULE_dc_density_value = 24
    RULE_array_spacing_rule = 25
    RULE_density_rule = 26
    RULE_direction_rule = 27
    RULE_spacing_rule = 28
    RULE_spacing_subrule = 29
    RULE_spacing_range_subrule = 30
    RULE_spacing_c2c_subrule = 31
    RULE_layer_type_rule = 32
    RULE_layer_type = 33
    RULE_width_rule = 34
    RULE_area_rule = 35
    RULE_thickness_rule = 36
    RULE_enclosure_rule = 37
    RULE_minenclosedarea_rule = 38
    RULE_pitch_rule = 39
    RULE_offset_rule = 40
    RULE_resistance_rule = 41
    RULE_capacitance_rule = 42
    RULE_edgecapacitance_rule = 43
    RULE_antenna_area_rule = 44
    RULE_spacing_table_rule = 45
    RULE_spacing_table_cut_row = 46
    RULE_spacing_table_routing_prl_row = 47
    RULE_spacing_table_routing_prl_influence = 48
    RULE_spacing_table_routing_prl_influence_row = 49
    RULE_via_statement = 50
    RULE_via_element = 51
    RULE_polygon = 52
    RULE_viarule_generate_statement = 53
    RULE_macro_statement = 54
    RULE_macro_property = 55
    RULE_macro_class = 56
    RULE_symmetry = 57
    RULE_pin_declaration = 58
    RULE_pin_property = 59
    RULE_pin_direction = 60
    RULE_obs_declaration = 61
    RULE_macro_layer_declaration = 62
    RULE_pt = 63
    RULE_tuple_list = 64
    RULE_property = 65

    ruleNames =  [ "top", "statement", "nowireextensionatpin_statement", 
                   "version_statement", "busbitchar_statement", "clearancemeasure_statement", 
                   "dividerchar_statement", "mfg_grid_statement", "useminspacing_statement", 
                   "ext_statement", "extension", "propertydefinitions_statement", 
                   "property_definition", "units_statement", "unit_declaration", 
                   "site_statement", "site_rule", "site_class", "layer_statement", 
                   "layer_rule", "lef58_property_rule", "ac_density_rule", 
                   "ac_density_value", "dc_density_rule", "dc_density_value", 
                   "array_spacing_rule", "density_rule", "direction_rule", 
                   "spacing_rule", "spacing_subrule", "spacing_range_subrule", 
                   "spacing_c2c_subrule", "layer_type_rule", "layer_type", 
                   "width_rule", "area_rule", "thickness_rule", "enclosure_rule", 
                   "minenclosedarea_rule", "pitch_rule", "offset_rule", 
                   "resistance_rule", "capacitance_rule", "edgecapacitance_rule", 
                   "antenna_area_rule", "spacing_table_rule", "spacing_table_cut_row", 
                   "spacing_table_routing_prl_row", "spacing_table_routing_prl_influence", 
                   "spacing_table_routing_prl_influence_row", "via_statement", 
                   "via_element", "polygon", "viarule_generate_statement", 
                   "macro_statement", "macro_property", "macro_class", "symmetry", 
                   "pin_declaration", "pin_property", "pin_direction", "obs_declaration", 
                   "macro_layer_declaration", "pt", "tuple_list", "property" ]

    EOF = Token.EOF
    Comment=1
    String=2
    Semicolon=3
    Ws=4
    KW_Layer=5
    KW_Site=6
    KW_Via=7
    KW_ViaRule=8
    KW_Macro=9
    KW_Foreign=10
    KW_Pin=11
    KW_End=12
    KW_Version=13
    KW_BusBitChars=14
    KW_DividerChar=15
    KW_Units=16
    KW_ManufacturingGrid=17
    KW_UseMinSpacing=18
    KW_ClearanceMeasure=19
    KW_PropertyDefinitions=20
    KW_MaxViaStack=21
    KW_Generate=22
    KW_NonDefaultRule=23
    KW_BeginExt=24
    KW_Obs=25
    KW_Library=26
    KW_MaxXY=27
    KW_Euclidean=28
    KW_Type=29
    KW_Property=30
    KW_Spacing=31
    KW_SpacingTable=32
    KW_Orthognal=33
    KW_ACCurrentDensity=34
    KW_DCCurrentDensity=35
    KW_Peak=36
    KW_Average=37
    KW_RMS=38
    KW_ArrayCuts=39
    KW_CutArea=40
    KW_CutSpacing=41
    KW_TableEntries=42
    KW_AntennaAreaDiffReducePWL=43
    KW_AntennaAreaFactor=44
    KW_AntennaSideAreaFactor=45
    KW_AntennaAreaMinusDiff=46
    KW_AntennaAreaRatio=47
    KW_AntennaSideAreaRatio=48
    KW_AntennaDiffAreaRatio=49
    KW_AntennaDiffSideAreaRatio=50
    KW_AntennaCumAreaRatio=51
    KW_AntennaCumDiffAreaRatio=52
    KW_AntennaGatePlusDiff=53
    KW_AntennaModel=54
    KW_ArraySpacing=55
    KW_DiffuseOnly=56
    KW_PWL=57
    KW_LongArray=58
    KW_Width=59
    KW_MinWidth=60
    KW_MaxWidth=61
    KW_Length=62
    KW_Enclosure=63
    KW_PreferEnclosure=64
    KW_Above=65
    KW_Below=66
    KW_ExceptExtraCut=67
    KW_CenterToCenter=68
    KW_SameNet=69
    KW_Stack=70
    KW_AdjacentCuts=71
    KW_Within=72
    KW_ExceptSamePGNet=73
    KW_ParallelOverlap=74
    KW_ParallelRunLength=75
    KW_Area=76
    KW_Thickness=77
    KW_Class=78
    KW_Size=79
    KW_By=80
    KW_To=81
    KW_Symmetry=82
    KW_On=83
    KW_Off=84
    KW_String=85
    KW_Direction=86
    KW_Vertical=87
    KW_Horizontal=88
    KW_Diag45=89
    KW_Diag135=90
    KW_Pitch=91
    KW_DiagPitch=92
    KW_Offset=93
    KW_Influence=94
    KW_TwoWidths=95
    KW_PRL=96
    KW_MinEnclosedArea=97
    KW_MaximumDensity=98
    KW_DensityCheckWindow=99
    KW_DensityCheckStep=100
    KW_Default=101
    KW_Rect=102
    KW_Polygon=103
    KW_Origin=104
    KW_UseRangeThreshold=105
    KW_LengthThreshold=106
    KW_EndOfLine=107
    KW_ParallelEdge=108
    KW_TwoEdges=109
    KW_Cut=110
    KW_Implant=111
    KW_Masterslice=112
    KW_Overlap=113
    KW_Routing=114
    KW_EdgeCapacitance=115
    KW_Time=116
    KW_Nanoseconds=117
    KW_Capacitance=118
    KW_PicoFarads=119
    KW_CPerSqDist=120
    KW_Resistance=121
    KW_Ohms=122
    KW_RPerSq=123
    KW_Power=124
    KW_Ground=125
    KW_Signal=126
    KW_Milliwatts=127
    KW_Voltage=128
    KW_Volts=129
    KW_Database=130
    KW_Microns=131
    KW_Frequency=132
    KW_Megahertz=133
    KW_Current=134
    KW_Milliamps=135
    KW_Input=136
    KW_Output=137
    KW_Inout=138
    KW_Tristate=139
    KW_Use=140
    KW_Shape=141
    KW_Abutment=142
    KW_Port=143
    KW_Clock=144
    KW_NoWireExtensionAtPin=145
    KW_AntennaGateArea=146
    KW_AntennaDiffArea=147
    KW_MinimumDensity=148
    KW_Range=149
    KW_Cover=150
    KW_Block=151
    KW_Blackbox=152
    KW_Soft=153
    KW_Bump=154
    KW_Ring=155
    KW_Core=156
    KW_Pad=157
    KW_AreaIO=158
    KW_Spacer=159
    KW_AntennaCell=160
    KW_Welltap=161
    KW_Feedthru=162
    KW_TieHigh=163
    KW_TieLow=164
    KW_Endcap=165
    KW_Pre=166
    KW_Post=167
    KW_TopLeft=168
    KW_TopRight=169
    KW_BottomLeft=170
    KW_BottomRight=171
    KW_R90=172
    KW_X=173
    KW_Y=174
    Oxide=175
    Number=176
    LParen=177
    RParen=178
    NAME_MODE_WS=179
    Name=180
    EM_Comment=181
    EM_String=182
    EM_Semicolon=183
    EM_Ws=184
    EM_Name=185
    EM_KW_EndExt=186

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.10.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def KW_Library(self):
            return self.getToken(lefParser.KW_Library, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.StatementContext)
            else:
                return self.getTypedRuleContext(lefParser.StatementContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_top

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTop" ):
                listener.enterTop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTop" ):
                listener.exitTop(self)




    def top(self):

        localctx = lefParser.TopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_top)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 132
                self.statement()
                self.state = 135 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lefParser.KW_Layer) | (1 << lefParser.KW_Site) | (1 << lefParser.KW_Via) | (1 << lefParser.KW_ViaRule) | (1 << lefParser.KW_Macro) | (1 << lefParser.KW_Version) | (1 << lefParser.KW_BusBitChars) | (1 << lefParser.KW_DividerChar) | (1 << lefParser.KW_Units) | (1 << lefParser.KW_ManufacturingGrid) | (1 << lefParser.KW_UseMinSpacing) | (1 << lefParser.KW_ClearanceMeasure) | (1 << lefParser.KW_PropertyDefinitions))) != 0) or _la==lefParser.KW_NoWireExtensionAtPin):
                    break

            self.state = 137
            self.match(lefParser.KW_End)
            self.state = 138
            self.match(lefParser.KW_Library)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def version_statement(self):
            return self.getTypedRuleContext(lefParser.Version_statementContext,0)


        def busbitchar_statement(self):
            return self.getTypedRuleContext(lefParser.Busbitchar_statementContext,0)


        def clearancemeasure_statement(self):
            return self.getTypedRuleContext(lefParser.Clearancemeasure_statementContext,0)


        def dividerchar_statement(self):
            return self.getTypedRuleContext(lefParser.Dividerchar_statementContext,0)


        def units_statement(self):
            return self.getTypedRuleContext(lefParser.Units_statementContext,0)


        def useminspacing_statement(self):
            return self.getTypedRuleContext(lefParser.Useminspacing_statementContext,0)


        def mfg_grid_statement(self):
            return self.getTypedRuleContext(lefParser.Mfg_grid_statementContext,0)


        def propertydefinitions_statement(self):
            return self.getTypedRuleContext(lefParser.Propertydefinitions_statementContext,0)


        def nowireextensionatpin_statement(self):
            return self.getTypedRuleContext(lefParser.Nowireextensionatpin_statementContext,0)


        def site_statement(self):
            return self.getTypedRuleContext(lefParser.Site_statementContext,0)


        def layer_statement(self):
            return self.getTypedRuleContext(lefParser.Layer_statementContext,0)


        def via_statement(self):
            return self.getTypedRuleContext(lefParser.Via_statementContext,0)


        def macro_statement(self):
            return self.getTypedRuleContext(lefParser.Macro_statementContext,0)


        def viarule_generate_statement(self):
            return self.getTypedRuleContext(lefParser.Viarule_generate_statementContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = lefParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Version]:
                self.enterOuterAlt(localctx, 1)
                self.state = 140
                self.version_statement()
                pass
            elif token in [lefParser.KW_BusBitChars]:
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.busbitchar_statement()
                pass
            elif token in [lefParser.KW_ClearanceMeasure]:
                self.enterOuterAlt(localctx, 3)
                self.state = 142
                self.clearancemeasure_statement()
                pass
            elif token in [lefParser.KW_DividerChar]:
                self.enterOuterAlt(localctx, 4)
                self.state = 143
                self.dividerchar_statement()
                pass
            elif token in [lefParser.KW_Units]:
                self.enterOuterAlt(localctx, 5)
                self.state = 144
                self.units_statement()
                pass
            elif token in [lefParser.KW_UseMinSpacing]:
                self.enterOuterAlt(localctx, 6)
                self.state = 145
                self.useminspacing_statement()
                pass
            elif token in [lefParser.KW_ManufacturingGrid]:
                self.enterOuterAlt(localctx, 7)
                self.state = 146
                self.mfg_grid_statement()
                pass
            elif token in [lefParser.KW_PropertyDefinitions]:
                self.enterOuterAlt(localctx, 8)
                self.state = 147
                self.propertydefinitions_statement()
                pass
            elif token in [lefParser.KW_NoWireExtensionAtPin]:
                self.enterOuterAlt(localctx, 9)
                self.state = 148
                self.nowireextensionatpin_statement()
                pass
            elif token in [lefParser.KW_Site]:
                self.enterOuterAlt(localctx, 10)
                self.state = 149
                self.site_statement()
                pass
            elif token in [lefParser.KW_Layer]:
                self.enterOuterAlt(localctx, 11)
                self.state = 150
                self.layer_statement()
                pass
            elif token in [lefParser.KW_Via]:
                self.enterOuterAlt(localctx, 12)
                self.state = 151
                self.via_statement()
                pass
            elif token in [lefParser.KW_Macro]:
                self.enterOuterAlt(localctx, 13)
                self.state = 152
                self.macro_statement()
                pass
            elif token in [lefParser.KW_ViaRule]:
                self.enterOuterAlt(localctx, 14)
                self.state = 153
                self.viarule_generate_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nowireextensionatpin_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_NoWireExtensionAtPin(self):
            return self.getToken(lefParser.KW_NoWireExtensionAtPin, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_On(self):
            return self.getToken(lefParser.KW_On, 0)

        def KW_Off(self):
            return self.getToken(lefParser.KW_Off, 0)

        def getRuleIndex(self):
            return lefParser.RULE_nowireextensionatpin_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNowireextensionatpin_statement" ):
                listener.enterNowireextensionatpin_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNowireextensionatpin_statement" ):
                listener.exitNowireextensionatpin_statement(self)




    def nowireextensionatpin_statement(self):

        localctx = lefParser.Nowireextensionatpin_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_nowireextensionatpin_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 156
            self.match(lefParser.KW_NoWireExtensionAtPin)
            self.state = 157
            _la = self._input.LA(1)
            if not(_la==lefParser.KW_On or _la==lefParser.KW_Off):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 158
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Version_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Version(self):
            return self.getToken(lefParser.KW_Version, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_version_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersion_statement" ):
                listener.enterVersion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersion_statement" ):
                listener.exitVersion_statement(self)




    def version_statement(self):

        localctx = lefParser.Version_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_version_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(lefParser.KW_Version)
            self.state = 161
            self.match(lefParser.Number)
            self.state = 162
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Busbitchar_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_BusBitChars(self):
            return self.getToken(lefParser.KW_BusBitChars, 0)

        def String(self):
            return self.getToken(lefParser.String, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_busbitchar_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBusbitchar_statement" ):
                listener.enterBusbitchar_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBusbitchar_statement" ):
                listener.exitBusbitchar_statement(self)




    def busbitchar_statement(self):

        localctx = lefParser.Busbitchar_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_busbitchar_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(lefParser.KW_BusBitChars)
            self.state = 165
            self.match(lefParser.String)
            self.state = 166
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Clearancemeasure_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_ClearanceMeasure(self):
            return self.getToken(lefParser.KW_ClearanceMeasure, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_MaxXY(self):
            return self.getToken(lefParser.KW_MaxXY, 0)

        def KW_Euclidean(self):
            return self.getToken(lefParser.KW_Euclidean, 0)

        def getRuleIndex(self):
            return lefParser.RULE_clearancemeasure_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClearancemeasure_statement" ):
                listener.enterClearancemeasure_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClearancemeasure_statement" ):
                listener.exitClearancemeasure_statement(self)




    def clearancemeasure_statement(self):

        localctx = lefParser.Clearancemeasure_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_clearancemeasure_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(lefParser.KW_ClearanceMeasure)
            self.state = 169
            _la = self._input.LA(1)
            if not(_la==lefParser.KW_MaxXY or _la==lefParser.KW_Euclidean):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 170
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dividerchar_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_DividerChar(self):
            return self.getToken(lefParser.KW_DividerChar, 0)

        def String(self):
            return self.getToken(lefParser.String, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_dividerchar_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDividerchar_statement" ):
                listener.enterDividerchar_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDividerchar_statement" ):
                listener.exitDividerchar_statement(self)




    def dividerchar_statement(self):

        localctx = lefParser.Dividerchar_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_dividerchar_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(lefParser.KW_DividerChar)
            self.state = 173
            self.match(lefParser.String)
            self.state = 174
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mfg_grid_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_ManufacturingGrid(self):
            return self.getToken(lefParser.KW_ManufacturingGrid, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_mfg_grid_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMfg_grid_statement" ):
                listener.enterMfg_grid_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMfg_grid_statement" ):
                listener.exitMfg_grid_statement(self)




    def mfg_grid_statement(self):

        localctx = lefParser.Mfg_grid_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_mfg_grid_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(lefParser.KW_ManufacturingGrid)
            self.state = 177
            self.match(lefParser.Number)
            self.state = 178
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Useminspacing_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_UseMinSpacing(self):
            return self.getToken(lefParser.KW_UseMinSpacing, 0)

        def KW_Obs(self):
            return self.getToken(lefParser.KW_Obs, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_On(self):
            return self.getToken(lefParser.KW_On, 0)

        def KW_Off(self):
            return self.getToken(lefParser.KW_Off, 0)

        def getRuleIndex(self):
            return lefParser.RULE_useminspacing_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUseminspacing_statement" ):
                listener.enterUseminspacing_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUseminspacing_statement" ):
                listener.exitUseminspacing_statement(self)




    def useminspacing_statement(self):

        localctx = lefParser.Useminspacing_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_useminspacing_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(lefParser.KW_UseMinSpacing)
            self.state = 181
            self.match(lefParser.KW_Obs)
            self.state = 182
            _la = self._input.LA(1)
            if not(_la==lefParser.KW_On or _la==lefParser.KW_Off):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 183
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ext_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_BeginExt(self):
            return self.getToken(lefParser.KW_BeginExt, 0)

        def EM_String(self):
            return self.getToken(lefParser.EM_String, 0)

        def EM_KW_EndExt(self):
            return self.getToken(lefParser.EM_KW_EndExt, 0)

        def extension(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.ExtensionContext)
            else:
                return self.getTypedRuleContext(lefParser.ExtensionContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_ext_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExt_statement" ):
                listener.enterExt_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExt_statement" ):
                listener.exitExt_statement(self)




    def ext_statement(self):

        localctx = lefParser.Ext_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ext_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(lefParser.KW_BeginExt)
            self.state = 186
            self.match(lefParser.EM_String)
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lefParser.EM_Name:
                self.state = 187
                self.extension()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 193
            self.match(lefParser.EM_KW_EndExt)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EM_Name(self):
            return self.getToken(lefParser.EM_Name, 0)

        def EM_String(self):
            return self.getToken(lefParser.EM_String, 0)

        def getRuleIndex(self):
            return lefParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)




    def extension(self):

        localctx = lefParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_extension)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(lefParser.EM_Name)
            self.state = 196
            self.match(lefParser.EM_String)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propertydefinitions_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_PropertyDefinitions(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_PropertyDefinitions)
            else:
                return self.getToken(lefParser.KW_PropertyDefinitions, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def property_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Property_definitionContext)
            else:
                return self.getTypedRuleContext(lefParser.Property_definitionContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_propertydefinitions_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertydefinitions_statement" ):
                listener.enterPropertydefinitions_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertydefinitions_statement" ):
                listener.exitPropertydefinitions_statement(self)




    def propertydefinitions_statement(self):

        localctx = lefParser.Propertydefinitions_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_propertydefinitions_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(lefParser.KW_PropertyDefinitions)
            self.state = 202
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lefParser.KW_Layer:
                self.state = 199
                self.property_definition()
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 205
            self.match(lefParser.KW_End)
            self.state = 206
            self.match(lefParser.KW_PropertyDefinitions)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Property_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Layer(self):
            return self.getToken(lefParser.KW_Layer, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def KW_String(self):
            return self.getToken(lefParser.KW_String, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_property_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProperty_definition" ):
                listener.enterProperty_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProperty_definition" ):
                listener.exitProperty_definition(self)




    def property_definition(self):

        localctx = lefParser.Property_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_property_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(lefParser.KW_Layer)
            self.state = 209
            self.match(lefParser.Name)
            self.state = 210
            self.match(lefParser.KW_String)
            self.state = 211
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Units_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Units(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Units)
            else:
                return self.getToken(lefParser.KW_Units, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def unit_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Unit_declarationContext)
            else:
                return self.getTypedRuleContext(lefParser.Unit_declarationContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_units_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnits_statement" ):
                listener.enterUnits_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnits_statement" ):
                listener.exitUnits_statement(self)




    def units_statement(self):

        localctx = lefParser.Units_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_units_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(lefParser.KW_Units)
            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 116)) & ~0x3f) == 0 and ((1 << (_la - 116)) & ((1 << (lefParser.KW_Time - 116)) | (1 << (lefParser.KW_Capacitance - 116)) | (1 << (lefParser.KW_Resistance - 116)) | (1 << (lefParser.KW_Power - 116)) | (1 << (lefParser.KW_Voltage - 116)) | (1 << (lefParser.KW_Database - 116)) | (1 << (lefParser.KW_Frequency - 116)) | (1 << (lefParser.KW_Current - 116)))) != 0):
                self.state = 214
                self.unit_declaration()
                self.state = 219
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 220
            self.match(lefParser.KW_End)
            self.state = 221
            self.match(lefParser.KW_Units)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unit_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Time(self):
            return self.getToken(lefParser.KW_Time, 0)

        def KW_Nanoseconds(self):
            return self.getToken(lefParser.KW_Nanoseconds, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Capacitance(self):
            return self.getToken(lefParser.KW_Capacitance, 0)

        def KW_PicoFarads(self):
            return self.getToken(lefParser.KW_PicoFarads, 0)

        def KW_Resistance(self):
            return self.getToken(lefParser.KW_Resistance, 0)

        def KW_Ohms(self):
            return self.getToken(lefParser.KW_Ohms, 0)

        def KW_Power(self):
            return self.getToken(lefParser.KW_Power, 0)

        def KW_Milliwatts(self):
            return self.getToken(lefParser.KW_Milliwatts, 0)

        def KW_Voltage(self):
            return self.getToken(lefParser.KW_Voltage, 0)

        def KW_Volts(self):
            return self.getToken(lefParser.KW_Volts, 0)

        def KW_Database(self):
            return self.getToken(lefParser.KW_Database, 0)

        def KW_Microns(self):
            return self.getToken(lefParser.KW_Microns, 0)

        def KW_Frequency(self):
            return self.getToken(lefParser.KW_Frequency, 0)

        def KW_Megahertz(self):
            return self.getToken(lefParser.KW_Megahertz, 0)

        def KW_Current(self):
            return self.getToken(lefParser.KW_Current, 0)

        def KW_Milliamps(self):
            return self.getToken(lefParser.KW_Milliamps, 0)

        def getRuleIndex(self):
            return lefParser.RULE_unit_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_declaration" ):
                listener.enterUnit_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_declaration" ):
                listener.exitUnit_declaration(self)




    def unit_declaration(self):

        localctx = lefParser.Unit_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_unit_declaration)
        try:
            self.state = 255
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Time]:
                self.enterOuterAlt(localctx, 1)
                self.state = 223
                self.match(lefParser.KW_Time)
                self.state = 224
                self.match(lefParser.KW_Nanoseconds)
                self.state = 225
                self.match(lefParser.Number)
                self.state = 226
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Capacitance]:
                self.enterOuterAlt(localctx, 2)
                self.state = 227
                self.match(lefParser.KW_Capacitance)
                self.state = 228
                self.match(lefParser.KW_PicoFarads)
                self.state = 229
                self.match(lefParser.Number)
                self.state = 230
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Resistance]:
                self.enterOuterAlt(localctx, 3)
                self.state = 231
                self.match(lefParser.KW_Resistance)
                self.state = 232
                self.match(lefParser.KW_Ohms)
                self.state = 233
                self.match(lefParser.Number)
                self.state = 234
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Power]:
                self.enterOuterAlt(localctx, 4)
                self.state = 235
                self.match(lefParser.KW_Power)
                self.state = 236
                self.match(lefParser.KW_Milliwatts)
                self.state = 237
                self.match(lefParser.Number)
                self.state = 238
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Voltage]:
                self.enterOuterAlt(localctx, 5)
                self.state = 239
                self.match(lefParser.KW_Voltage)
                self.state = 240
                self.match(lefParser.KW_Volts)
                self.state = 241
                self.match(lefParser.Number)
                self.state = 242
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Database]:
                self.enterOuterAlt(localctx, 6)
                self.state = 243
                self.match(lefParser.KW_Database)
                self.state = 244
                self.match(lefParser.KW_Microns)
                self.state = 245
                self.match(lefParser.Number)
                self.state = 246
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Frequency]:
                self.enterOuterAlt(localctx, 7)
                self.state = 247
                self.match(lefParser.KW_Frequency)
                self.state = 248
                self.match(lefParser.KW_Megahertz)
                self.state = 249
                self.match(lefParser.Number)
                self.state = 250
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Current]:
                self.enterOuterAlt(localctx, 8)
                self.state = 251
                self.match(lefParser.KW_Current)
                self.state = 252
                self.match(lefParser.KW_Milliamps)
                self.state = 253
                self.match(lefParser.Number)
                self.state = 254
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Site_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Site(self):
            return self.getToken(lefParser.KW_Site, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def site_rule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Site_ruleContext)
            else:
                return self.getTypedRuleContext(lefParser.Site_ruleContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_site_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSite_statement" ):
                listener.enterSite_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSite_statement" ):
                listener.exitSite_statement(self)




    def site_statement(self):

        localctx = lefParser.Site_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_site_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(lefParser.KW_Site)
            self.state = 258
            self.match(lefParser.Name)
            self.state = 262
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & ((1 << (lefParser.KW_Class - 78)) | (1 << (lefParser.KW_Size - 78)) | (1 << (lefParser.KW_Symmetry - 78)))) != 0):
                self.state = 259
                self.site_rule()
                self.state = 264
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 265
            self.match(lefParser.KW_End)
            self.state = 266
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Site_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Symmetry(self):
            return self.getToken(lefParser.KW_Symmetry, 0)

        def symmetry(self):
            return self.getTypedRuleContext(lefParser.SymmetryContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Class(self):
            return self.getToken(lefParser.KW_Class, 0)

        def site_class(self):
            return self.getTypedRuleContext(lefParser.Site_classContext,0)


        def KW_Size(self):
            return self.getToken(lefParser.KW_Size, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_By(self):
            return self.getToken(lefParser.KW_By, 0)

        def getRuleIndex(self):
            return lefParser.RULE_site_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSite_rule" ):
                listener.enterSite_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSite_rule" ):
                listener.exitSite_rule(self)




    def site_rule(self):

        localctx = lefParser.Site_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_site_rule)
        try:
            self.state = 281
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Symmetry]:
                self.enterOuterAlt(localctx, 1)
                self.state = 268
                self.match(lefParser.KW_Symmetry)
                self.state = 269
                self.symmetry()
                self.state = 270
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Class]:
                self.enterOuterAlt(localctx, 2)
                self.state = 272
                self.match(lefParser.KW_Class)
                self.state = 273
                self.site_class()
                self.state = 274
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Size]:
                self.enterOuterAlt(localctx, 3)
                self.state = 276
                self.match(lefParser.KW_Size)
                self.state = 277
                self.match(lefParser.Number)
                self.state = 278
                self.match(lefParser.KW_By)
                self.state = 279
                self.match(lefParser.Number)
                self.state = 280
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Site_classContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Pad(self):
            return self.getToken(lefParser.KW_Pad, 0)

        def KW_Core(self):
            return self.getToken(lefParser.KW_Core, 0)

        def getRuleIndex(self):
            return lefParser.RULE_site_class

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSite_class" ):
                listener.enterSite_class(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSite_class" ):
                listener.exitSite_class(self)




    def site_class(self):

        localctx = lefParser.Site_classContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_site_class)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            _la = self._input.LA(1)
            if not(_la==lefParser.KW_Core or _la==lefParser.KW_Pad):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Layer_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Layer(self):
            return self.getToken(lefParser.KW_Layer, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def layer_rule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Layer_ruleContext)
            else:
                return self.getTypedRuleContext(lefParser.Layer_ruleContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_layer_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLayer_statement" ):
                listener.enterLayer_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLayer_statement" ):
                listener.exitLayer_statement(self)




    def layer_statement(self):

        localctx = lefParser.Layer_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_layer_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(lefParser.KW_Layer)
            self.state = 286
            self.match(lefParser.Name)
            self.state = 290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & ((1 << (lefParser.KW_Type - 29)) | (1 << (lefParser.KW_Property - 29)) | (1 << (lefParser.KW_Spacing - 29)) | (1 << (lefParser.KW_SpacingTable - 29)) | (1 << (lefParser.KW_ACCurrentDensity - 29)) | (1 << (lefParser.KW_DCCurrentDensity - 29)) | (1 << (lefParser.KW_AntennaAreaDiffReducePWL - 29)) | (1 << (lefParser.KW_AntennaAreaFactor - 29)) | (1 << (lefParser.KW_AntennaSideAreaFactor - 29)) | (1 << (lefParser.KW_AntennaAreaMinusDiff - 29)) | (1 << (lefParser.KW_AntennaAreaRatio - 29)) | (1 << (lefParser.KW_AntennaSideAreaRatio - 29)) | (1 << (lefParser.KW_AntennaDiffAreaRatio - 29)) | (1 << (lefParser.KW_AntennaDiffSideAreaRatio - 29)) | (1 << (lefParser.KW_AntennaCumAreaRatio - 29)) | (1 << (lefParser.KW_AntennaCumDiffAreaRatio - 29)) | (1 << (lefParser.KW_AntennaGatePlusDiff - 29)) | (1 << (lefParser.KW_AntennaModel - 29)) | (1 << (lefParser.KW_ArraySpacing - 29)) | (1 << (lefParser.KW_Width - 29)) | (1 << (lefParser.KW_MinWidth - 29)) | (1 << (lefParser.KW_MaxWidth - 29)) | (1 << (lefParser.KW_Enclosure - 29)) | (1 << (lefParser.KW_PreferEnclosure - 29)) | (1 << (lefParser.KW_Area - 29)) | (1 << (lefParser.KW_Thickness - 29)) | (1 << (lefParser.KW_Direction - 29)) | (1 << (lefParser.KW_Pitch - 29)) | (1 << (lefParser.KW_DiagPitch - 29)))) != 0) or ((((_la - 93)) & ~0x3f) == 0 and ((1 << (_la - 93)) & ((1 << (lefParser.KW_Offset - 93)) | (1 << (lefParser.KW_TwoWidths - 93)) | (1 << (lefParser.KW_MinEnclosedArea - 93)) | (1 << (lefParser.KW_MaximumDensity - 93)) | (1 << (lefParser.KW_DensityCheckWindow - 93)) | (1 << (lefParser.KW_DensityCheckStep - 93)) | (1 << (lefParser.KW_EdgeCapacitance - 93)) | (1 << (lefParser.KW_Capacitance - 93)) | (1 << (lefParser.KW_Resistance - 93)) | (1 << (lefParser.KW_MinimumDensity - 93)))) != 0):
                self.state = 287
                self.layer_rule()
                self.state = 292
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 293
            self.match(lefParser.KW_End)
            self.state = 294
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Layer_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lef58_property_rule(self):
            return self.getTypedRuleContext(lefParser.Lef58_property_ruleContext,0)


        def ac_density_rule(self):
            return self.getTypedRuleContext(lefParser.Ac_density_ruleContext,0)


        def dc_density_rule(self):
            return self.getTypedRuleContext(lefParser.Dc_density_ruleContext,0)


        def antenna_area_rule(self):
            return self.getTypedRuleContext(lefParser.Antenna_area_ruleContext,0)


        def array_spacing_rule(self):
            return self.getTypedRuleContext(lefParser.Array_spacing_ruleContext,0)


        def enclosure_rule(self):
            return self.getTypedRuleContext(lefParser.Enclosure_ruleContext,0)


        def property_(self):
            return self.getTypedRuleContext(lefParser.PropertyContext,0)


        def spacing_rule(self):
            return self.getTypedRuleContext(lefParser.Spacing_ruleContext,0)


        def layer_type_rule(self):
            return self.getTypedRuleContext(lefParser.Layer_type_ruleContext,0)


        def direction_rule(self):
            return self.getTypedRuleContext(lefParser.Direction_ruleContext,0)


        def pitch_rule(self):
            return self.getTypedRuleContext(lefParser.Pitch_ruleContext,0)


        def offset_rule(self):
            return self.getTypedRuleContext(lefParser.Offset_ruleContext,0)


        def width_rule(self):
            return self.getTypedRuleContext(lefParser.Width_ruleContext,0)


        def spacing_table_rule(self):
            return self.getTypedRuleContext(lefParser.Spacing_table_ruleContext,0)


        def area_rule(self):
            return self.getTypedRuleContext(lefParser.Area_ruleContext,0)


        def thickness_rule(self):
            return self.getTypedRuleContext(lefParser.Thickness_ruleContext,0)


        def resistance_rule(self):
            return self.getTypedRuleContext(lefParser.Resistance_ruleContext,0)


        def capacitance_rule(self):
            return self.getTypedRuleContext(lefParser.Capacitance_ruleContext,0)


        def edgecapacitance_rule(self):
            return self.getTypedRuleContext(lefParser.Edgecapacitance_ruleContext,0)


        def minenclosedarea_rule(self):
            return self.getTypedRuleContext(lefParser.Minenclosedarea_ruleContext,0)


        def density_rule(self):
            return self.getTypedRuleContext(lefParser.Density_ruleContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_layer_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLayer_rule" ):
                listener.enterLayer_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLayer_rule" ):
                listener.exitLayer_rule(self)




    def layer_rule(self):

        localctx = lefParser.Layer_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_layer_rule)
        try:
            self.state = 317
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 296
                self.lef58_property_rule()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 297
                self.ac_density_rule()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 298
                self.dc_density_rule()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 299
                self.antenna_area_rule()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 300
                self.array_spacing_rule()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 301
                self.enclosure_rule()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 302
                self.property_()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 303
                self.spacing_rule()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 304
                self.layer_type_rule()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 305
                self.direction_rule()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 306
                self.pitch_rule()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 307
                self.offset_rule()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 308
                self.width_rule()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 309
                self.spacing_table_rule()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 310
                self.area_rule()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 311
                self.thickness_rule()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 312
                self.resistance_rule()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 313
                self.capacitance_rule()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 314
                self.edgecapacitance_rule()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 315
                self.minenclosedarea_rule()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 316
                self.density_rule()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lef58_property_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def property_(self):
            return self.getTypedRuleContext(lefParser.PropertyContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_lef58_property_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLef58_property_rule" ):
                listener.enterLef58_property_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLef58_property_rule" ):
                listener.exitLef58_property_rule(self)




    def lef58_property_rule(self):

        localctx = lefParser.Lef58_property_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_lef58_property_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.property_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ac_density_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_ACCurrentDensity(self):
            return self.getToken(lefParser.KW_ACCurrentDensity, 0)

        def ac_density_value(self):
            return self.getTypedRuleContext(lefParser.Ac_density_valueContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Peak(self):
            return self.getToken(lefParser.KW_Peak, 0)

        def KW_Average(self):
            return self.getToken(lefParser.KW_Average, 0)

        def KW_RMS(self):
            return self.getToken(lefParser.KW_RMS, 0)

        def getRuleIndex(self):
            return lefParser.RULE_ac_density_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAc_density_rule" ):
                listener.enterAc_density_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAc_density_rule" ):
                listener.exitAc_density_rule(self)




    def ac_density_rule(self):

        localctx = lefParser.Ac_density_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_ac_density_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            self.match(lefParser.KW_ACCurrentDensity)
            self.state = 322
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lefParser.KW_Peak) | (1 << lefParser.KW_Average) | (1 << lefParser.KW_RMS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 323
            self.ac_density_value()
            self.state = 324
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ac_density_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Frequency(self):
            return self.getToken(lefParser.KW_Frequency, 0)

        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Semicolon)
            else:
                return self.getToken(lefParser.Semicolon, i)

        def KW_TableEntries(self):
            return self.getToken(lefParser.KW_TableEntries, 0)

        def KW_CutArea(self):
            return self.getToken(lefParser.KW_CutArea, 0)

        def getRuleIndex(self):
            return lefParser.RULE_ac_density_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAc_density_value" ):
                listener.enterAc_density_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAc_density_value" ):
                listener.exitAc_density_value(self)




    def ac_density_value(self):

        localctx = lefParser.Ac_density_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_ac_density_value)
        self._la = 0 # Token type
        try:
            self.state = 349
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.Number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.match(lefParser.Number)
                pass
            elif token in [lefParser.KW_Frequency]:
                self.enterOuterAlt(localctx, 2)
                self.state = 327
                self.match(lefParser.KW_Frequency)
                self.state = 329 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 328
                    self.match(lefParser.Number)
                    self.state = 331 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                self.state = 333
                self.match(lefParser.Semicolon)
                self.state = 341
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_CutArea:
                    self.state = 334
                    self.match(lefParser.KW_CutArea)
                    self.state = 336 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 335
                        self.match(lefParser.Number)
                        self.state = 338 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==lefParser.Number):
                            break

                    self.state = 340
                    self.match(lefParser.Semicolon)


                self.state = 343
                self.match(lefParser.KW_TableEntries)
                self.state = 345 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 344
                    self.match(lefParser.Number)
                    self.state = 347 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dc_density_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_DCCurrentDensity(self):
            return self.getToken(lefParser.KW_DCCurrentDensity, 0)

        def KW_Average(self):
            return self.getToken(lefParser.KW_Average, 0)

        def dc_density_value(self):
            return self.getTypedRuleContext(lefParser.Dc_density_valueContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_dc_density_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDc_density_rule" ):
                listener.enterDc_density_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDc_density_rule" ):
                listener.exitDc_density_rule(self)




    def dc_density_rule(self):

        localctx = lefParser.Dc_density_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_dc_density_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.match(lefParser.KW_DCCurrentDensity)
            self.state = 352
            self.match(lefParser.KW_Average)
            self.state = 353
            self.dc_density_value()
            self.state = 354
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dc_density_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_TableEntries(self):
            return self.getToken(lefParser.KW_TableEntries, 0)

        def getRuleIndex(self):
            return lefParser.RULE_dc_density_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDc_density_value" ):
                listener.enterDc_density_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDc_density_value" ):
                listener.exitDc_density_value(self)




    def dc_density_value(self):

        localctx = lefParser.Dc_density_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_dc_density_value)
        self._la = 0 # Token type
        try:
            self.state = 370
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.Number]:
                self.enterOuterAlt(localctx, 1)
                self.state = 356
                self.match(lefParser.Number)
                pass
            elif token in [lefParser.KW_Width]:
                self.enterOuterAlt(localctx, 2)
                self.state = 357
                self.match(lefParser.KW_Width)
                self.state = 359 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 358
                    self.match(lefParser.Number)
                    self.state = 361 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                self.state = 363
                self.match(lefParser.Semicolon)
                self.state = 364
                self.match(lefParser.KW_TableEntries)
                self.state = 366 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 365
                    self.match(lefParser.Number)
                    self.state = 368 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_spacing_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_ArraySpacing(self):
            return self.getToken(lefParser.KW_ArraySpacing, 0)

        def KW_CutSpacing(self):
            return self.getToken(lefParser.KW_CutSpacing, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_LongArray(self):
            return self.getToken(lefParser.KW_LongArray, 0)

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def KW_ArrayCuts(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_ArrayCuts)
            else:
                return self.getToken(lefParser.KW_ArrayCuts, i)

        def KW_Spacing(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Spacing)
            else:
                return self.getToken(lefParser.KW_Spacing, i)

        def getRuleIndex(self):
            return lefParser.RULE_array_spacing_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_spacing_rule" ):
                listener.enterArray_spacing_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_spacing_rule" ):
                listener.exitArray_spacing_rule(self)




    def array_spacing_rule(self):

        localctx = lefParser.Array_spacing_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_array_spacing_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(lefParser.KW_ArraySpacing)
            self.state = 374
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_LongArray:
                self.state = 373
                self.match(lefParser.KW_LongArray)


            self.state = 378
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Width:
                self.state = 376
                self.match(lefParser.KW_Width)
                self.state = 377
                self.match(lefParser.Number)


            self.state = 380
            self.match(lefParser.KW_CutSpacing)
            self.state = 381
            self.match(lefParser.Number)
            self.state = 386 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 382
                self.match(lefParser.KW_ArrayCuts)
                self.state = 383
                self.match(lefParser.Number)
                self.state = 384
                self.match(lefParser.KW_Spacing)
                self.state = 385
                self.match(lefParser.Number)
                self.state = 388 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==lefParser.KW_ArrayCuts):
                    break

            self.state = 390
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Density_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_MaximumDensity(self):
            return self.getToken(lefParser.KW_MaximumDensity, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_DensityCheckWindow(self):
            return self.getToken(lefParser.KW_DensityCheckWindow, 0)

        def KW_DensityCheckStep(self):
            return self.getToken(lefParser.KW_DensityCheckStep, 0)

        def KW_MinimumDensity(self):
            return self.getToken(lefParser.KW_MinimumDensity, 0)

        def getRuleIndex(self):
            return lefParser.RULE_density_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDensity_rule" ):
                listener.enterDensity_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDensity_rule" ):
                listener.exitDensity_rule(self)




    def density_rule(self):

        localctx = lefParser.Density_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_density_rule)
        try:
            self.state = 405
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_MaximumDensity]:
                self.enterOuterAlt(localctx, 1)
                self.state = 392
                self.match(lefParser.KW_MaximumDensity)
                self.state = 393
                self.match(lefParser.Number)
                self.state = 394
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_DensityCheckWindow]:
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self.match(lefParser.KW_DensityCheckWindow)
                self.state = 396
                self.match(lefParser.Number)
                self.state = 397
                self.match(lefParser.Number)
                self.state = 398
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_DensityCheckStep]:
                self.enterOuterAlt(localctx, 3)
                self.state = 399
                self.match(lefParser.KW_DensityCheckStep)
                self.state = 400
                self.match(lefParser.Number)
                self.state = 401
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_MinimumDensity]:
                self.enterOuterAlt(localctx, 4)
                self.state = 402
                self.match(lefParser.KW_MinimumDensity)
                self.state = 403
                self.match(lefParser.Number)
                self.state = 404
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direction_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Direction(self):
            return self.getToken(lefParser.KW_Direction, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Vertical(self):
            return self.getToken(lefParser.KW_Vertical, 0)

        def KW_Horizontal(self):
            return self.getToken(lefParser.KW_Horizontal, 0)

        def KW_Diag45(self):
            return self.getToken(lefParser.KW_Diag45, 0)

        def KW_Diag135(self):
            return self.getToken(lefParser.KW_Diag135, 0)

        def getRuleIndex(self):
            return lefParser.RULE_direction_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirection_rule" ):
                listener.enterDirection_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirection_rule" ):
                listener.exitDirection_rule(self)




    def direction_rule(self):

        localctx = lefParser.Direction_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_direction_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(lefParser.KW_Direction)
            self.state = 408
            _la = self._input.LA(1)
            if not(((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (lefParser.KW_Vertical - 87)) | (1 << (lefParser.KW_Horizontal - 87)) | (1 << (lefParser.KW_Diag45 - 87)) | (1 << (lefParser.KW_Diag135 - 87)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 409
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Spacing(self):
            return self.getToken(lefParser.KW_Spacing, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def spacing_subrule(self):
            return self.getTypedRuleContext(lefParser.Spacing_subruleContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_spacing_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_rule" ):
                listener.enterSpacing_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_rule" ):
                listener.exitSpacing_rule(self)




    def spacing_rule(self):

        localctx = lefParser.Spacing_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_spacing_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 411
            self.match(lefParser.KW_Spacing)
            self.state = 412
            self.match(lefParser.Number)
            self.state = 414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 106)) & ~0x3f) == 0 and ((1 << (_la - 106)) & ((1 << (lefParser.KW_LengthThreshold - 106)) | (1 << (lefParser.KW_EndOfLine - 106)) | (1 << (lefParser.KW_Range - 106)))) != 0):
                self.state = 413
                self.spacing_subrule()


            self.state = 416
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_subruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Range(self):
            return self.getToken(lefParser.KW_Range, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def spacing_range_subrule(self):
            return self.getTypedRuleContext(lefParser.Spacing_range_subruleContext,0)


        def KW_LengthThreshold(self):
            return self.getToken(lefParser.KW_LengthThreshold, 0)

        def KW_EndOfLine(self):
            return self.getToken(lefParser.KW_EndOfLine, 0)

        def KW_Within(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Within)
            else:
                return self.getToken(lefParser.KW_Within, i)

        def KW_ParallelEdge(self):
            return self.getToken(lefParser.KW_ParallelEdge, 0)

        def KW_TwoEdges(self):
            return self.getToken(lefParser.KW_TwoEdges, 0)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_subrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_subrule" ):
                listener.enterSpacing_subrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_subrule" ):
                listener.exitSpacing_subrule(self)




    def spacing_subrule(self):

        localctx = lefParser.Spacing_subruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_spacing_subrule)
        self._la = 0 # Token type
        try:
            self.state = 444
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Range]:
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self.match(lefParser.KW_Range)
                self.state = 419
                self.match(lefParser.Number)
                self.state = 420
                self.match(lefParser.Number)
                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 94)) & ~0x3f) == 0 and ((1 << (_la - 94)) & ((1 << (lefParser.KW_Influence - 94)) | (1 << (lefParser.KW_UseRangeThreshold - 94)) | (1 << (lefParser.KW_Range - 94)))) != 0):
                    self.state = 421
                    self.spacing_range_subrule()


                pass
            elif token in [lefParser.KW_LengthThreshold]:
                self.enterOuterAlt(localctx, 2)
                self.state = 424
                self.match(lefParser.KW_LengthThreshold)
                self.state = 425
                self.match(lefParser.Number)
                self.state = 429
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Range:
                    self.state = 426
                    self.match(lefParser.KW_Range)
                    self.state = 427
                    self.match(lefParser.Number)
                    self.state = 428
                    self.match(lefParser.Number)


                pass
            elif token in [lefParser.KW_EndOfLine]:
                self.enterOuterAlt(localctx, 3)
                self.state = 431
                self.match(lefParser.KW_EndOfLine)
                self.state = 432
                self.match(lefParser.Number)
                self.state = 433
                self.match(lefParser.KW_Within)
                self.state = 434
                self.match(lefParser.Number)
                self.state = 442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_ParallelEdge:
                    self.state = 435
                    self.match(lefParser.KW_ParallelEdge)
                    self.state = 436
                    self.match(lefParser.Number)
                    self.state = 437
                    self.match(lefParser.KW_Within)
                    self.state = 438
                    self.match(lefParser.Number)
                    self.state = 440
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==lefParser.KW_TwoEdges:
                        self.state = 439
                        self.match(lefParser.KW_TwoEdges)




                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_range_subruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_UseRangeThreshold(self):
            return self.getToken(lefParser.KW_UseRangeThreshold, 0)

        def KW_Influence(self):
            return self.getToken(lefParser.KW_Influence, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Range(self):
            return self.getToken(lefParser.KW_Range, 0)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_range_subrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_range_subrule" ):
                listener.enterSpacing_range_subrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_range_subrule" ):
                listener.exitSpacing_range_subrule(self)




    def spacing_range_subrule(self):

        localctx = lefParser.Spacing_range_subruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_spacing_range_subrule)
        self._la = 0 # Token type
        try:
            self.state = 457
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_UseRangeThreshold]:
                self.enterOuterAlt(localctx, 1)
                self.state = 446
                self.match(lefParser.KW_UseRangeThreshold)
                pass
            elif token in [lefParser.KW_Influence]:
                self.enterOuterAlt(localctx, 2)
                self.state = 447
                self.match(lefParser.KW_Influence)
                self.state = 448
                self.match(lefParser.Number)
                self.state = 452
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Range:
                    self.state = 449
                    self.match(lefParser.KW_Range)
                    self.state = 450
                    self.match(lefParser.Number)
                    self.state = 451
                    self.match(lefParser.Number)


                pass
            elif token in [lefParser.KW_Range]:
                self.enterOuterAlt(localctx, 3)
                self.state = 454
                self.match(lefParser.KW_Range)
                self.state = 455
                self.match(lefParser.Number)
                self.state = 456
                self.match(lefParser.Number)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_c2c_subruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Layer(self):
            return self.getToken(lefParser.KW_Layer, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def KW_Stack(self):
            return self.getToken(lefParser.KW_Stack, 0)

        def KW_AdjacentCuts(self):
            return self.getToken(lefParser.KW_AdjacentCuts, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Within(self):
            return self.getToken(lefParser.KW_Within, 0)

        def KW_ExceptSamePGNet(self):
            return self.getToken(lefParser.KW_ExceptSamePGNet, 0)

        def KW_ParallelOverlap(self):
            return self.getToken(lefParser.KW_ParallelOverlap, 0)

        def KW_Area(self):
            return self.getToken(lefParser.KW_Area, 0)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_c2c_subrule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_c2c_subrule" ):
                listener.enterSpacing_c2c_subrule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_c2c_subrule" ):
                listener.exitSpacing_c2c_subrule(self)




    def spacing_c2c_subrule(self):

        localctx = lefParser.Spacing_c2c_subruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_spacing_c2c_subrule)
        self._la = 0 # Token type
        try:
            self.state = 474
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Layer]:
                self.enterOuterAlt(localctx, 1)
                self.state = 459
                self.match(lefParser.KW_Layer)
                self.state = 460
                self.match(lefParser.Name)
                self.state = 462
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Stack:
                    self.state = 461
                    self.match(lefParser.KW_Stack)


                pass
            elif token in [lefParser.KW_AdjacentCuts]:
                self.enterOuterAlt(localctx, 2)
                self.state = 464
                self.match(lefParser.KW_AdjacentCuts)
                self.state = 465
                self.match(lefParser.Number)
                self.state = 466
                self.match(lefParser.KW_Within)
                self.state = 467
                self.match(lefParser.Number)
                self.state = 469
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_ExceptSamePGNet:
                    self.state = 468
                    self.match(lefParser.KW_ExceptSamePGNet)


                pass
            elif token in [lefParser.KW_ParallelOverlap]:
                self.enterOuterAlt(localctx, 3)
                self.state = 471
                self.match(lefParser.KW_ParallelOverlap)
                pass
            elif token in [lefParser.KW_Area]:
                self.enterOuterAlt(localctx, 4)
                self.state = 472
                self.match(lefParser.KW_Area)
                self.state = 473
                self.match(lefParser.Number)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Layer_type_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Type(self):
            return self.getToken(lefParser.KW_Type, 0)

        def layer_type(self):
            return self.getTypedRuleContext(lefParser.Layer_typeContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_layer_type_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLayer_type_rule" ):
                listener.enterLayer_type_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLayer_type_rule" ):
                listener.exitLayer_type_rule(self)




    def layer_type_rule(self):

        localctx = lefParser.Layer_type_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_layer_type_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.match(lefParser.KW_Type)
            self.state = 477
            self.layer_type()
            self.state = 478
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Layer_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Cut(self):
            return self.getToken(lefParser.KW_Cut, 0)

        def KW_Implant(self):
            return self.getToken(lefParser.KW_Implant, 0)

        def KW_Masterslice(self):
            return self.getToken(lefParser.KW_Masterslice, 0)

        def KW_Overlap(self):
            return self.getToken(lefParser.KW_Overlap, 0)

        def KW_Routing(self):
            return self.getToken(lefParser.KW_Routing, 0)

        def getRuleIndex(self):
            return lefParser.RULE_layer_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLayer_type" ):
                listener.enterLayer_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLayer_type" ):
                listener.exitLayer_type(self)




    def layer_type(self):

        localctx = lefParser.Layer_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_layer_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            _la = self._input.LA(1)
            if not(((((_la - 110)) & ~0x3f) == 0 and ((1 << (_la - 110)) & ((1 << (lefParser.KW_Cut - 110)) | (1 << (lefParser.KW_Implant - 110)) | (1 << (lefParser.KW_Masterslice - 110)) | (1 << (lefParser.KW_Overlap - 110)) | (1 << (lefParser.KW_Routing - 110)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Width_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_MinWidth(self):
            return self.getToken(lefParser.KW_MinWidth, 0)

        def KW_MaxWidth(self):
            return self.getToken(lefParser.KW_MaxWidth, 0)

        def getRuleIndex(self):
            return lefParser.RULE_width_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWidth_rule" ):
                listener.enterWidth_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWidth_rule" ):
                listener.exitWidth_rule(self)




    def width_rule(self):

        localctx = lefParser.Width_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_width_rule)
        try:
            self.state = 491
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Width]:
                self.enterOuterAlt(localctx, 1)
                self.state = 482
                self.match(lefParser.KW_Width)
                self.state = 483
                self.match(lefParser.Number)
                self.state = 484
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_MinWidth]:
                self.enterOuterAlt(localctx, 2)
                self.state = 485
                self.match(lefParser.KW_MinWidth)
                self.state = 486
                self.match(lefParser.Number)
                self.state = 487
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_MaxWidth]:
                self.enterOuterAlt(localctx, 3)
                self.state = 488
                self.match(lefParser.KW_MaxWidth)
                self.state = 489
                self.match(lefParser.Number)
                self.state = 490
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Area_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Area(self):
            return self.getToken(lefParser.KW_Area, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_area_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArea_rule" ):
                listener.enterArea_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArea_rule" ):
                listener.exitArea_rule(self)




    def area_rule(self):

        localctx = lefParser.Area_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_area_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(lefParser.KW_Area)
            self.state = 494
            self.match(lefParser.Number)
            self.state = 495
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Thickness_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Thickness(self):
            return self.getToken(lefParser.KW_Thickness, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_thickness_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterThickness_rule" ):
                listener.enterThickness_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitThickness_rule" ):
                listener.exitThickness_rule(self)




    def thickness_rule(self):

        localctx = lefParser.Thickness_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_thickness_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            self.match(lefParser.KW_Thickness)
            self.state = 498
            self.match(lefParser.Number)
            self.state = 499
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Enclosure_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Enclosure(self):
            return self.getToken(lefParser.KW_Enclosure, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def KW_Length(self):
            return self.getToken(lefParser.KW_Length, 0)

        def KW_Above(self):
            return self.getToken(lefParser.KW_Above, 0)

        def KW_Below(self):
            return self.getToken(lefParser.KW_Below, 0)

        def KW_ExceptExtraCut(self):
            return self.getToken(lefParser.KW_ExceptExtraCut, 0)

        def KW_PreferEnclosure(self):
            return self.getToken(lefParser.KW_PreferEnclosure, 0)

        def getRuleIndex(self):
            return lefParser.RULE_enclosure_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnclosure_rule" ):
                listener.enterEnclosure_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnclosure_rule" ):
                listener.exitEnclosure_rule(self)




    def enclosure_rule(self):

        localctx = lefParser.Enclosure_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_enclosure_rule)
        self._la = 0 # Token type
        try:
            self.state = 531
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Enclosure]:
                self.enterOuterAlt(localctx, 1)
                self.state = 501
                self.match(lefParser.KW_Enclosure)
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Above or _la==lefParser.KW_Below:
                    self.state = 502
                    _la = self._input.LA(1)
                    if not(_la==lefParser.KW_Above or _la==lefParser.KW_Below):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 505
                self.match(lefParser.Number)
                self.state = 506
                self.match(lefParser.Number)
                self.state = 513
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Width:
                    self.state = 507
                    self.match(lefParser.KW_Width)
                    self.state = 508
                    self.match(lefParser.Number)
                    self.state = 511
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==lefParser.KW_ExceptExtraCut:
                        self.state = 509
                        self.match(lefParser.KW_ExceptExtraCut)
                        self.state = 510
                        self.match(lefParser.Number)




                self.state = 517
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Length:
                    self.state = 515
                    self.match(lefParser.KW_Length)
                    self.state = 516
                    self.match(lefParser.Number)


                self.state = 519
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_PreferEnclosure]:
                self.enterOuterAlt(localctx, 2)
                self.state = 520
                self.match(lefParser.KW_PreferEnclosure)
                self.state = 522
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Above or _la==lefParser.KW_Below:
                    self.state = 521
                    _la = self._input.LA(1)
                    if not(_la==lefParser.KW_Above or _la==lefParser.KW_Below):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 524
                self.match(lefParser.Number)
                self.state = 525
                self.match(lefParser.Number)
                self.state = 528
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Width:
                    self.state = 526
                    self.match(lefParser.KW_Width)
                    self.state = 527
                    self.match(lefParser.Number)


                self.state = 530
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Minenclosedarea_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_MinEnclosedArea(self):
            return self.getToken(lefParser.KW_MinEnclosedArea, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_minenclosedarea_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinenclosedarea_rule" ):
                listener.enterMinenclosedarea_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinenclosedarea_rule" ):
                listener.exitMinenclosedarea_rule(self)




    def minenclosedarea_rule(self):

        localctx = lefParser.Minenclosedarea_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_minenclosedarea_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            self.match(lefParser.KW_MinEnclosedArea)
            self.state = 534
            self.match(lefParser.Number)
            self.state = 535
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pitch_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Pitch(self):
            return self.getToken(lefParser.KW_Pitch, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_DiagPitch(self):
            return self.getToken(lefParser.KW_DiagPitch, 0)

        def getRuleIndex(self):
            return lefParser.RULE_pitch_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPitch_rule" ):
                listener.enterPitch_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPitch_rule" ):
                listener.exitPitch_rule(self)




    def pitch_rule(self):

        localctx = lefParser.Pitch_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_pitch_rule)
        try:
            self.state = 551
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Pitch]:
                self.enterOuterAlt(localctx, 1)
                self.state = 537
                self.match(lefParser.KW_Pitch)
                self.state = 541
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 538
                    self.match(lefParser.Number)
                    pass

                elif la_ == 2:
                    self.state = 539
                    self.match(lefParser.Number)
                    self.state = 540
                    self.match(lefParser.Number)
                    pass


                self.state = 543
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_DiagPitch]:
                self.enterOuterAlt(localctx, 2)
                self.state = 544
                self.match(lefParser.KW_DiagPitch)
                self.state = 548
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 545
                    self.match(lefParser.Number)
                    pass

                elif la_ == 2:
                    self.state = 546
                    self.match(lefParser.Number)
                    self.state = 547
                    self.match(lefParser.Number)
                    pass


                self.state = 550
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Offset_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Offset(self):
            return self.getToken(lefParser.KW_Offset, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def getRuleIndex(self):
            return lefParser.RULE_offset_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOffset_rule" ):
                listener.enterOffset_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOffset_rule" ):
                listener.exitOffset_rule(self)




    def offset_rule(self):

        localctx = lefParser.Offset_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_offset_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 553
            self.match(lefParser.KW_Offset)
            self.state = 557
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 554
                self.match(lefParser.Number)
                pass

            elif la_ == 2:
                self.state = 555
                self.match(lefParser.Number)
                self.state = 556
                self.match(lefParser.Number)
                pass


            self.state = 559
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Resistance_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Resistance(self):
            return self.getToken(lefParser.KW_Resistance, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_RPerSq(self):
            return self.getToken(lefParser.KW_RPerSq, 0)

        def getRuleIndex(self):
            return lefParser.RULE_resistance_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResistance_rule" ):
                listener.enterResistance_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResistance_rule" ):
                listener.exitResistance_rule(self)




    def resistance_rule(self):

        localctx = lefParser.Resistance_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_resistance_rule)
        try:
            self.state = 568
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 561
                self.match(lefParser.KW_Resistance)
                self.state = 562
                self.match(lefParser.Number)
                self.state = 563
                self.match(lefParser.Semicolon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 564
                self.match(lefParser.KW_Resistance)
                self.state = 565
                self.match(lefParser.KW_RPerSq)
                self.state = 566
                self.match(lefParser.Number)
                self.state = 567
                self.match(lefParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Capacitance_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Capacitance(self):
            return self.getToken(lefParser.KW_Capacitance, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_CPerSqDist(self):
            return self.getToken(lefParser.KW_CPerSqDist, 0)

        def getRuleIndex(self):
            return lefParser.RULE_capacitance_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCapacitance_rule" ):
                listener.enterCapacitance_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCapacitance_rule" ):
                listener.exitCapacitance_rule(self)




    def capacitance_rule(self):

        localctx = lefParser.Capacitance_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_capacitance_rule)
        try:
            self.state = 577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 570
                self.match(lefParser.KW_Capacitance)
                self.state = 571
                self.match(lefParser.Number)
                self.state = 572
                self.match(lefParser.Semicolon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.match(lefParser.KW_Capacitance)
                self.state = 574
                self.match(lefParser.KW_CPerSqDist)
                self.state = 575
                self.match(lefParser.Number)
                self.state = 576
                self.match(lefParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Edgecapacitance_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_EdgeCapacitance(self):
            return self.getToken(lefParser.KW_EdgeCapacitance, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_edgecapacitance_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEdgecapacitance_rule" ):
                listener.enterEdgecapacitance_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEdgecapacitance_rule" ):
                listener.exitEdgecapacitance_rule(self)




    def edgecapacitance_rule(self):

        localctx = lefParser.Edgecapacitance_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_edgecapacitance_rule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(lefParser.KW_EdgeCapacitance)
            self.state = 580
            self.match(lefParser.Number)
            self.state = 581
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Antenna_area_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_AntennaAreaDiffReducePWL(self):
            return self.getToken(lefParser.KW_AntennaAreaDiffReducePWL, 0)

        def tuple_list(self):
            return self.getTypedRuleContext(lefParser.Tuple_listContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_AntennaAreaFactor(self):
            return self.getToken(lefParser.KW_AntennaAreaFactor, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def KW_DiffuseOnly(self):
            return self.getToken(lefParser.KW_DiffuseOnly, 0)

        def KW_AntennaAreaMinusDiff(self):
            return self.getToken(lefParser.KW_AntennaAreaMinusDiff, 0)

        def KW_AntennaAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaAreaRatio, 0)

        def KW_AntennaSideAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaSideAreaRatio, 0)

        def KW_AntennaCumAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaCumAreaRatio, 0)

        def KW_AntennaCumDiffAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaCumDiffAreaRatio, 0)

        def KW_PWL(self):
            return self.getToken(lefParser.KW_PWL, 0)

        def KW_AntennaGatePlusDiff(self):
            return self.getToken(lefParser.KW_AntennaGatePlusDiff, 0)

        def KW_AntennaModel(self):
            return self.getToken(lefParser.KW_AntennaModel, 0)

        def Oxide(self):
            return self.getToken(lefParser.Oxide, 0)

        def KW_AntennaSideAreaFactor(self):
            return self.getToken(lefParser.KW_AntennaSideAreaFactor, 0)

        def KW_AntennaDiffAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaDiffAreaRatio, 0)

        def KW_AntennaDiffSideAreaRatio(self):
            return self.getToken(lefParser.KW_AntennaDiffSideAreaRatio, 0)

        def getRuleIndex(self):
            return lefParser.RULE_antenna_area_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAntenna_area_rule" ):
                listener.enterAntenna_area_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAntenna_area_rule" ):
                listener.exitAntenna_area_rule(self)




    def antenna_area_rule(self):

        localctx = lefParser.Antenna_area_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_antenna_area_rule)
        self._la = 0 # Token type
        try:
            self.state = 638
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_AntennaAreaDiffReducePWL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 583
                self.match(lefParser.KW_AntennaAreaDiffReducePWL)
                self.state = 584
                self.tuple_list()
                self.state = 585
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaAreaFactor]:
                self.enterOuterAlt(localctx, 2)
                self.state = 587
                self.match(lefParser.KW_AntennaAreaFactor)
                self.state = 588
                self.match(lefParser.Number)
                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_DiffuseOnly:
                    self.state = 589
                    self.match(lefParser.KW_DiffuseOnly)


                self.state = 592
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaAreaMinusDiff]:
                self.enterOuterAlt(localctx, 3)
                self.state = 593
                self.match(lefParser.KW_AntennaAreaMinusDiff)
                self.state = 594
                self.match(lefParser.Number)
                self.state = 595
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaAreaRatio]:
                self.enterOuterAlt(localctx, 4)
                self.state = 596
                self.match(lefParser.KW_AntennaAreaRatio)
                self.state = 597
                self.match(lefParser.Number)
                self.state = 598
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaSideAreaRatio]:
                self.enterOuterAlt(localctx, 5)
                self.state = 599
                self.match(lefParser.KW_AntennaSideAreaRatio)
                self.state = 600
                self.match(lefParser.Number)
                self.state = 601
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaCumAreaRatio]:
                self.enterOuterAlt(localctx, 6)
                self.state = 602
                self.match(lefParser.KW_AntennaCumAreaRatio)
                self.state = 603
                self.match(lefParser.Number)
                self.state = 604
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaCumDiffAreaRatio]:
                self.enterOuterAlt(localctx, 7)
                self.state = 605
                self.match(lefParser.KW_AntennaCumDiffAreaRatio)
                self.state = 609
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [lefParser.Number]:
                    self.state = 606
                    self.match(lefParser.Number)
                    pass
                elif token in [lefParser.KW_PWL]:
                    self.state = 607
                    self.match(lefParser.KW_PWL)
                    self.state = 608
                    self.tuple_list()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 611
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaGatePlusDiff]:
                self.enterOuterAlt(localctx, 8)
                self.state = 612
                self.match(lefParser.KW_AntennaGatePlusDiff)
                self.state = 613
                self.match(lefParser.Number)
                self.state = 614
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaModel]:
                self.enterOuterAlt(localctx, 9)
                self.state = 615
                self.match(lefParser.KW_AntennaModel)
                self.state = 616
                self.match(lefParser.Oxide)
                self.state = 617
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaSideAreaFactor]:
                self.enterOuterAlt(localctx, 10)
                self.state = 618
                self.match(lefParser.KW_AntennaSideAreaFactor)
                self.state = 619
                self.match(lefParser.Number)
                self.state = 621
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_DiffuseOnly:
                    self.state = 620
                    self.match(lefParser.KW_DiffuseOnly)


                self.state = 623
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaDiffAreaRatio]:
                self.enterOuterAlt(localctx, 11)
                self.state = 624
                self.match(lefParser.KW_AntennaDiffAreaRatio)
                self.state = 628
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [lefParser.Number]:
                    self.state = 625
                    self.match(lefParser.Number)
                    pass
                elif token in [lefParser.KW_PWL]:
                    self.state = 626
                    self.match(lefParser.KW_PWL)
                    self.state = 627
                    self.tuple_list()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 630
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaDiffSideAreaRatio]:
                self.enterOuterAlt(localctx, 12)
                self.state = 631
                self.match(lefParser.KW_AntennaDiffSideAreaRatio)
                self.state = 635
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [lefParser.Number]:
                    self.state = 632
                    self.match(lefParser.Number)
                    pass
                elif token in [lefParser.KW_PWL]:
                    self.state = 633
                    self.match(lefParser.KW_PWL)
                    self.state = 634
                    self.tuple_list()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 637
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_table_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_SpacingTable(self):
            return self.getToken(lefParser.KW_SpacingTable, 0)

        def KW_Orthognal(self):
            return self.getToken(lefParser.KW_Orthognal, 0)

        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Semicolon)
            else:
                return self.getToken(lefParser.Semicolon, i)

        def spacing_table_cut_row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Spacing_table_cut_rowContext)
            else:
                return self.getTypedRuleContext(lefParser.Spacing_table_cut_rowContext,i)


        def KW_ParallelRunLength(self):
            return self.getToken(lefParser.KW_ParallelRunLength, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def spacing_table_routing_prl_row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Spacing_table_routing_prl_rowContext)
            else:
                return self.getTypedRuleContext(lefParser.Spacing_table_routing_prl_rowContext,i)


        def spacing_table_routing_prl_influence(self):
            return self.getTypedRuleContext(lefParser.Spacing_table_routing_prl_influenceContext,0)


        def KW_TwoWidths(self):
            return self.getToken(lefParser.KW_TwoWidths, 0)

        def KW_Width(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Width)
            else:
                return self.getToken(lefParser.KW_Width, i)

        def KW_PRL(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_PRL)
            else:
                return self.getToken(lefParser.KW_PRL, i)

        def KW_Spacing(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Spacing)
            else:
                return self.getToken(lefParser.KW_Spacing, i)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_table_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_table_rule" ):
                listener.enterSpacing_table_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_table_rule" ):
                listener.exitSpacing_table_rule(self)




    def spacing_table_rule(self):

        localctx = lefParser.Spacing_table_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_spacing_table_rule)
        self._la = 0 # Token type
        try:
            self.state = 684
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 640
                self.match(lefParser.KW_SpacingTable)
                self.state = 641
                self.match(lefParser.KW_Orthognal)
                self.state = 643 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 642
                    self.spacing_table_cut_row()
                    self.state = 645 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.KW_Within):
                        break

                self.state = 647
                self.match(lefParser.Semicolon)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 649
                self.match(lefParser.KW_SpacingTable)
                self.state = 650
                self.match(lefParser.KW_ParallelRunLength)
                self.state = 652 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 651
                    self.match(lefParser.Number)
                    self.state = 654 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                self.state = 657 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 656
                    self.spacing_table_routing_prl_row()
                    self.state = 659 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.KW_Width):
                        break

                self.state = 661
                self.match(lefParser.Semicolon)
                self.state = 665
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 662
                    self.spacing_table_routing_prl_influence()
                    self.state = 663
                    self.match(lefParser.Semicolon)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 667
                self.match(lefParser.KW_TwoWidths)
                self.state = 679 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 668
                    self.match(lefParser.KW_Width)
                    self.state = 669
                    self.match(lefParser.Number)
                    self.state = 672
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==lefParser.KW_PRL:
                        self.state = 670
                        self.match(lefParser.KW_PRL)
                        self.state = 671
                        self.match(lefParser.Number)


                    self.state = 675 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 674
                        self.match(lefParser.KW_Spacing)
                        self.state = 677 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==lefParser.KW_Spacing):
                            break

                    self.state = 681 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.KW_Width):
                        break

                self.state = 683
                self.match(lefParser.Semicolon)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_table_cut_rowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Within(self):
            return self.getToken(lefParser.KW_Within, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Spacing(self):
            return self.getToken(lefParser.KW_Spacing, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_table_cut_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_table_cut_row" ):
                listener.enterSpacing_table_cut_row(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_table_cut_row" ):
                listener.exitSpacing_table_cut_row(self)




    def spacing_table_cut_row(self):

        localctx = lefParser.Spacing_table_cut_rowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_spacing_table_cut_row)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            self.match(lefParser.KW_Within)
            self.state = 687
            self.match(lefParser.Number)
            self.state = 688
            self.match(lefParser.KW_Spacing)
            self.state = 689
            self.match(lefParser.Number)
            self.state = 690
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_table_routing_prl_rowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_table_routing_prl_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_table_routing_prl_row" ):
                listener.enterSpacing_table_routing_prl_row(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_table_routing_prl_row" ):
                listener.exitSpacing_table_routing_prl_row(self)




    def spacing_table_routing_prl_row(self):

        localctx = lefParser.Spacing_table_routing_prl_rowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_spacing_table_routing_prl_row)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.match(lefParser.KW_Width)
            self.state = 693
            self.match(lefParser.Number)
            self.state = 695 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 694
                self.match(lefParser.Number)
                self.state = 697 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==lefParser.Number):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_table_routing_prl_influenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_SpacingTable(self):
            return self.getToken(lefParser.KW_SpacingTable, 0)

        def KW_Influence(self):
            return self.getToken(lefParser.KW_Influence, 0)

        def spacing_table_routing_prl_influence_row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Spacing_table_routing_prl_influence_rowContext)
            else:
                return self.getTypedRuleContext(lefParser.Spacing_table_routing_prl_influence_rowContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_spacing_table_routing_prl_influence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_table_routing_prl_influence" ):
                listener.enterSpacing_table_routing_prl_influence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_table_routing_prl_influence" ):
                listener.exitSpacing_table_routing_prl_influence(self)




    def spacing_table_routing_prl_influence(self):

        localctx = lefParser.Spacing_table_routing_prl_influenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_spacing_table_routing_prl_influence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            self.match(lefParser.KW_SpacingTable)
            self.state = 700
            self.match(lefParser.KW_Influence)
            self.state = 702 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 701
                self.spacing_table_routing_prl_influence_row()
                self.state = 704 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==lefParser.KW_Width):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Spacing_table_routing_prl_influence_rowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Width(self):
            return self.getToken(lefParser.KW_Width, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Within(self):
            return self.getToken(lefParser.KW_Within, 0)

        def KW_Spacing(self):
            return self.getToken(lefParser.KW_Spacing, 0)

        def getRuleIndex(self):
            return lefParser.RULE_spacing_table_routing_prl_influence_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpacing_table_routing_prl_influence_row" ):
                listener.enterSpacing_table_routing_prl_influence_row(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpacing_table_routing_prl_influence_row" ):
                listener.exitSpacing_table_routing_prl_influence_row(self)




    def spacing_table_routing_prl_influence_row(self):

        localctx = lefParser.Spacing_table_routing_prl_influence_rowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_spacing_table_routing_prl_influence_row)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 706
            self.match(lefParser.KW_Width)
            self.state = 707
            self.match(lefParser.Number)
            self.state = 708
            self.match(lefParser.KW_Within)
            self.state = 709
            self.match(lefParser.Number)
            self.state = 710
            self.match(lefParser.KW_Spacing)
            self.state = 711
            self.match(lefParser.Number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Via_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Via(self):
            return self.getToken(lefParser.KW_Via, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def KW_Default(self):
            return self.getToken(lefParser.KW_Default, 0)

        def via_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Via_elementContext)
            else:
                return self.getTypedRuleContext(lefParser.Via_elementContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_via_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVia_statement" ):
                listener.enterVia_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVia_statement" ):
                listener.exitVia_statement(self)




    def via_statement(self):

        localctx = lefParser.Via_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_via_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.match(lefParser.KW_Via)
            self.state = 714
            self.match(lefParser.Name)
            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Default:
                self.state = 715
                self.match(lefParser.KW_Default)


            self.state = 721
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lefParser.KW_Layer or _la==lefParser.KW_Property or _la==lefParser.KW_Resistance:
                self.state = 718
                self.via_element()
                self.state = 723
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 724
            self.match(lefParser.KW_End)
            self.state = 725
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Via_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Resistance(self):
            return self.getToken(lefParser.KW_Resistance, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Layer(self):
            return self.getToken(lefParser.KW_Layer, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def polygon(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.PolygonContext)
            else:
                return self.getTypedRuleContext(lefParser.PolygonContext,i)


        def property_(self):
            return self.getTypedRuleContext(lefParser.PropertyContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_via_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVia_element" ):
                listener.enterVia_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVia_element" ):
                listener.exitVia_element(self)




    def via_element(self):

        localctx = lefParser.Via_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_via_element)
        self._la = 0 # Token type
        try:
            self.state = 739
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Resistance]:
                self.enterOuterAlt(localctx, 1)
                self.state = 727
                self.match(lefParser.KW_Resistance)
                self.state = 728
                self.match(lefParser.Number)
                self.state = 729
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Layer]:
                self.enterOuterAlt(localctx, 2)
                self.state = 730
                self.match(lefParser.KW_Layer)
                self.state = 731
                self.match(lefParser.Name)
                self.state = 732
                self.match(lefParser.Semicolon)
                self.state = 734 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 733
                    self.polygon()
                    self.state = 736 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.KW_Rect or _la==lefParser.KW_Polygon):
                        break

                pass
            elif token in [lefParser.KW_Property]:
                self.enterOuterAlt(localctx, 3)
                self.state = 738
                self.property_()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PolygonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Rect(self):
            return self.getToken(lefParser.KW_Rect, 0)

        def pt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.PtContext)
            else:
                return self.getTypedRuleContext(lefParser.PtContext,i)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Polygon(self):
            return self.getToken(lefParser.KW_Polygon, 0)

        def getRuleIndex(self):
            return lefParser.RULE_polygon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPolygon" ):
                listener.enterPolygon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPolygon" ):
                listener.exitPolygon(self)




    def polygon(self):

        localctx = lefParser.PolygonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_polygon)
        self._la = 0 # Token type
        try:
            self.state = 756
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Rect]:
                self.enterOuterAlt(localctx, 1)
                self.state = 741
                self.match(lefParser.KW_Rect)
                self.state = 742
                self.pt()
                self.state = 743
                self.pt()
                self.state = 744
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Polygon]:
                self.enterOuterAlt(localctx, 2)
                self.state = 746
                self.match(lefParser.KW_Polygon)
                self.state = 747
                self.pt()
                self.state = 748
                self.pt()
                self.state = 750 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 749
                    self.pt()
                    self.state = 752 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==lefParser.Number):
                        break

                self.state = 754
                self.match(lefParser.Semicolon)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Viarule_generate_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_ViaRule(self):
            return self.getToken(lefParser.KW_ViaRule, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_Generate(self):
            return self.getToken(lefParser.KW_Generate, 0)

        def KW_Layer(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Layer)
            else:
                return self.getToken(lefParser.KW_Layer, i)

        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Semicolon)
            else:
                return self.getToken(lefParser.Semicolon, i)

        def KW_Enclosure(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Enclosure)
            else:
                return self.getToken(lefParser.KW_Enclosure, i)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_Rect(self):
            return self.getToken(lefParser.KW_Rect, 0)

        def pt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.PtContext)
            else:
                return self.getTypedRuleContext(lefParser.PtContext,i)


        def KW_Spacing(self):
            return self.getToken(lefParser.KW_Spacing, 0)

        def KW_By(self):
            return self.getToken(lefParser.KW_By, 0)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def KW_Default(self):
            return self.getToken(lefParser.KW_Default, 0)

        def KW_Width(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Width)
            else:
                return self.getToken(lefParser.KW_Width, i)

        def KW_To(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_To)
            else:
                return self.getToken(lefParser.KW_To, i)

        def KW_Resistance(self):
            return self.getToken(lefParser.KW_Resistance, 0)

        def getRuleIndex(self):
            return lefParser.RULE_viarule_generate_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterViarule_generate_statement" ):
                listener.enterViarule_generate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitViarule_generate_statement" ):
                listener.exitViarule_generate_statement(self)




    def viarule_generate_statement(self):

        localctx = lefParser.Viarule_generate_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_viarule_generate_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            self.match(lefParser.KW_ViaRule)
            self.state = 759
            self.match(lefParser.Name)
            self.state = 760
            self.match(lefParser.KW_Generate)
            self.state = 762
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Default:
                self.state = 761
                self.match(lefParser.KW_Default)


            self.state = 764
            self.match(lefParser.KW_Layer)
            self.state = 765
            self.match(lefParser.Name)
            self.state = 766
            self.match(lefParser.Semicolon)
            self.state = 767
            self.match(lefParser.KW_Enclosure)
            self.state = 768
            self.match(lefParser.Number)
            self.state = 769
            self.match(lefParser.Number)
            self.state = 770
            self.match(lefParser.Semicolon)
            self.state = 776
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Width:
                self.state = 771
                self.match(lefParser.KW_Width)
                self.state = 772
                self.match(lefParser.Number)
                self.state = 773
                self.match(lefParser.KW_To)
                self.state = 774
                self.match(lefParser.Number)
                self.state = 775
                self.match(lefParser.Semicolon)


            self.state = 778
            self.match(lefParser.KW_Layer)
            self.state = 779
            self.match(lefParser.Name)
            self.state = 780
            self.match(lefParser.Semicolon)
            self.state = 781
            self.match(lefParser.KW_Enclosure)
            self.state = 782
            self.match(lefParser.Number)
            self.state = 783
            self.match(lefParser.Number)
            self.state = 784
            self.match(lefParser.Semicolon)
            self.state = 790
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Width:
                self.state = 785
                self.match(lefParser.KW_Width)
                self.state = 786
                self.match(lefParser.Number)
                self.state = 787
                self.match(lefParser.KW_To)
                self.state = 788
                self.match(lefParser.Number)
                self.state = 789
                self.match(lefParser.Semicolon)


            self.state = 792
            self.match(lefParser.KW_Layer)
            self.state = 793
            self.match(lefParser.Name)
            self.state = 794
            self.match(lefParser.Semicolon)
            self.state = 795
            self.match(lefParser.KW_Rect)
            self.state = 796
            self.pt()
            self.state = 797
            self.pt()
            self.state = 798
            self.match(lefParser.Semicolon)
            self.state = 799
            self.match(lefParser.KW_Spacing)
            self.state = 800
            self.match(lefParser.Number)
            self.state = 801
            self.match(lefParser.KW_By)
            self.state = 802
            self.match(lefParser.Number)
            self.state = 803
            self.match(lefParser.Semicolon)
            self.state = 807
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==lefParser.KW_Resistance:
                self.state = 804
                self.match(lefParser.KW_Resistance)
                self.state = 805
                self.match(lefParser.Number)
                self.state = 806
                self.match(lefParser.Semicolon)


            self.state = 809
            self.match(lefParser.KW_End)
            self.state = 810
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Macro(self):
            return self.getToken(lefParser.KW_Macro, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def macro_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Macro_propertyContext)
            else:
                return self.getTypedRuleContext(lefParser.Macro_propertyContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_macro_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacro_statement" ):
                listener.enterMacro_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacro_statement" ):
                listener.exitMacro_statement(self)




    def macro_statement(self):

        localctx = lefParser.Macro_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_macro_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.match(lefParser.KW_Macro)
            self.state = 813
            self.match(lefParser.Name)
            self.state = 817
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << lefParser.KW_Site) | (1 << lefParser.KW_Foreign) | (1 << lefParser.KW_Pin) | (1 << lefParser.KW_Obs))) != 0) or ((((_la - 78)) & ~0x3f) == 0 and ((1 << (_la - 78)) & ((1 << (lefParser.KW_Class - 78)) | (1 << (lefParser.KW_Size - 78)) | (1 << (lefParser.KW_Symmetry - 78)) | (1 << (lefParser.KW_Origin - 78)))) != 0):
                self.state = 814
                self.macro_property()
                self.state = 819
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 820
            self.match(lefParser.KW_End)
            self.state = 821
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Class(self):
            return self.getToken(lefParser.KW_Class, 0)

        def macro_class(self):
            return self.getTypedRuleContext(lefParser.Macro_classContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Foreign(self):
            return self.getToken(lefParser.KW_Foreign, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def KW_Origin(self):
            return self.getToken(lefParser.KW_Origin, 0)

        def pt(self):
            return self.getTypedRuleContext(lefParser.PtContext,0)


        def KW_Size(self):
            return self.getToken(lefParser.KW_Size, 0)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def KW_By(self):
            return self.getToken(lefParser.KW_By, 0)

        def KW_Symmetry(self):
            return self.getToken(lefParser.KW_Symmetry, 0)

        def symmetry(self):
            return self.getTypedRuleContext(lefParser.SymmetryContext,0)


        def KW_Site(self):
            return self.getToken(lefParser.KW_Site, 0)

        def pin_declaration(self):
            return self.getTypedRuleContext(lefParser.Pin_declarationContext,0)


        def obs_declaration(self):
            return self.getTypedRuleContext(lefParser.Obs_declarationContext,0)


        def getRuleIndex(self):
            return lefParser.RULE_macro_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacro_property" ):
                listener.enterMacro_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacro_property" ):
                listener.exitMacro_property(self)




    def macro_property(self):

        localctx = lefParser.Macro_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_macro_property)
        try:
            self.state = 848
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Class]:
                self.enterOuterAlt(localctx, 1)
                self.state = 823
                self.match(lefParser.KW_Class)
                self.state = 824
                self.macro_class()
                self.state = 825
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Foreign]:
                self.enterOuterAlt(localctx, 2)
                self.state = 827
                self.match(lefParser.KW_Foreign)
                self.state = 828
                self.match(lefParser.Name)
                self.state = 829
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Origin]:
                self.enterOuterAlt(localctx, 3)
                self.state = 830
                self.match(lefParser.KW_Origin)
                self.state = 831
                self.pt()
                self.state = 832
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Size]:
                self.enterOuterAlt(localctx, 4)
                self.state = 834
                self.match(lefParser.KW_Size)
                self.state = 835
                self.match(lefParser.Number)
                self.state = 836
                self.match(lefParser.KW_By)
                self.state = 837
                self.match(lefParser.Number)
                self.state = 838
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Symmetry]:
                self.enterOuterAlt(localctx, 5)
                self.state = 839
                self.match(lefParser.KW_Symmetry)
                self.state = 840
                self.symmetry()
                self.state = 841
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Site]:
                self.enterOuterAlt(localctx, 6)
                self.state = 843
                self.match(lefParser.KW_Site)
                self.state = 844
                self.match(lefParser.Name)
                self.state = 845
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Pin]:
                self.enterOuterAlt(localctx, 7)
                self.state = 846
                self.pin_declaration()
                pass
            elif token in [lefParser.KW_Obs]:
                self.enterOuterAlt(localctx, 8)
                self.state = 847
                self.obs_declaration()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_classContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Cover(self):
            return self.getToken(lefParser.KW_Cover, 0)

        def KW_Bump(self):
            return self.getToken(lefParser.KW_Bump, 0)

        def KW_Ring(self):
            return self.getToken(lefParser.KW_Ring, 0)

        def KW_Block(self):
            return self.getToken(lefParser.KW_Block, 0)

        def KW_Blackbox(self):
            return self.getToken(lefParser.KW_Blackbox, 0)

        def KW_Soft(self):
            return self.getToken(lefParser.KW_Soft, 0)

        def KW_Pad(self):
            return self.getToken(lefParser.KW_Pad, 0)

        def KW_Input(self):
            return self.getToken(lefParser.KW_Input, 0)

        def KW_Output(self):
            return self.getToken(lefParser.KW_Output, 0)

        def KW_Inout(self):
            return self.getToken(lefParser.KW_Inout, 0)

        def KW_Power(self):
            return self.getToken(lefParser.KW_Power, 0)

        def KW_Spacer(self):
            return self.getToken(lefParser.KW_Spacer, 0)

        def KW_AreaIO(self):
            return self.getToken(lefParser.KW_AreaIO, 0)

        def KW_Core(self):
            return self.getToken(lefParser.KW_Core, 0)

        def KW_Feedthru(self):
            return self.getToken(lefParser.KW_Feedthru, 0)

        def KW_TieHigh(self):
            return self.getToken(lefParser.KW_TieHigh, 0)

        def KW_TieLow(self):
            return self.getToken(lefParser.KW_TieLow, 0)

        def KW_AntennaCell(self):
            return self.getToken(lefParser.KW_AntennaCell, 0)

        def KW_Welltap(self):
            return self.getToken(lefParser.KW_Welltap, 0)

        def KW_Endcap(self):
            return self.getToken(lefParser.KW_Endcap, 0)

        def KW_Pre(self):
            return self.getToken(lefParser.KW_Pre, 0)

        def KW_Post(self):
            return self.getToken(lefParser.KW_Post, 0)

        def KW_TopLeft(self):
            return self.getToken(lefParser.KW_TopLeft, 0)

        def KW_TopRight(self):
            return self.getToken(lefParser.KW_TopRight, 0)

        def KW_BottomLeft(self):
            return self.getToken(lefParser.KW_BottomLeft, 0)

        def KW_BottomRight(self):
            return self.getToken(lefParser.KW_BottomRight, 0)

        def getRuleIndex(self):
            return lefParser.RULE_macro_class

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacro_class" ):
                listener.enterMacro_class(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacro_class" ):
                listener.exitMacro_class(self)




    def macro_class(self):

        localctx = lefParser.Macro_classContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_macro_class)
        self._la = 0 # Token type
        try:
            self.state = 871
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Cover]:
                self.enterOuterAlt(localctx, 1)
                self.state = 850
                self.match(lefParser.KW_Cover)
                self.state = 852
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Bump:
                    self.state = 851
                    self.match(lefParser.KW_Bump)


                pass
            elif token in [lefParser.KW_Ring]:
                self.enterOuterAlt(localctx, 2)
                self.state = 854
                self.match(lefParser.KW_Ring)
                pass
            elif token in [lefParser.KW_Block]:
                self.enterOuterAlt(localctx, 3)
                self.state = 855
                self.match(lefParser.KW_Block)
                self.state = 857
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Blackbox or _la==lefParser.KW_Soft:
                    self.state = 856
                    _la = self._input.LA(1)
                    if not(_la==lefParser.KW_Blackbox or _la==lefParser.KW_Soft):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [lefParser.KW_Pad]:
                self.enterOuterAlt(localctx, 4)
                self.state = 859
                self.match(lefParser.KW_Pad)
                self.state = 861
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 124)) & ~0x3f) == 0 and ((1 << (_la - 124)) & ((1 << (lefParser.KW_Power - 124)) | (1 << (lefParser.KW_Input - 124)) | (1 << (lefParser.KW_Output - 124)) | (1 << (lefParser.KW_Inout - 124)) | (1 << (lefParser.KW_AreaIO - 124)) | (1 << (lefParser.KW_Spacer - 124)))) != 0):
                    self.state = 860
                    _la = self._input.LA(1)
                    if not(((((_la - 124)) & ~0x3f) == 0 and ((1 << (_la - 124)) & ((1 << (lefParser.KW_Power - 124)) | (1 << (lefParser.KW_Input - 124)) | (1 << (lefParser.KW_Output - 124)) | (1 << (lefParser.KW_Inout - 124)) | (1 << (lefParser.KW_AreaIO - 124)) | (1 << (lefParser.KW_Spacer - 124)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [lefParser.KW_Core]:
                self.enterOuterAlt(localctx, 5)
                self.state = 863
                self.match(lefParser.KW_Core)
                self.state = 865
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & ((1 << (lefParser.KW_Spacer - 159)) | (1 << (lefParser.KW_AntennaCell - 159)) | (1 << (lefParser.KW_Welltap - 159)) | (1 << (lefParser.KW_Feedthru - 159)) | (1 << (lefParser.KW_TieHigh - 159)) | (1 << (lefParser.KW_TieLow - 159)))) != 0):
                    self.state = 864
                    _la = self._input.LA(1)
                    if not(((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & ((1 << (lefParser.KW_Spacer - 159)) | (1 << (lefParser.KW_AntennaCell - 159)) | (1 << (lefParser.KW_Welltap - 159)) | (1 << (lefParser.KW_Feedthru - 159)) | (1 << (lefParser.KW_TieHigh - 159)) | (1 << (lefParser.KW_TieLow - 159)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [lefParser.KW_Endcap]:
                self.enterOuterAlt(localctx, 6)
                self.state = 867
                self.match(lefParser.KW_Endcap)
                self.state = 869
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 166)) & ~0x3f) == 0 and ((1 << (_la - 166)) & ((1 << (lefParser.KW_Pre - 166)) | (1 << (lefParser.KW_Post - 166)) | (1 << (lefParser.KW_TopLeft - 166)) | (1 << (lefParser.KW_TopRight - 166)) | (1 << (lefParser.KW_BottomLeft - 166)) | (1 << (lefParser.KW_BottomRight - 166)))) != 0):
                    self.state = 868
                    _la = self._input.LA(1)
                    if not(((((_la - 166)) & ~0x3f) == 0 and ((1 << (_la - 166)) & ((1 << (lefParser.KW_Pre - 166)) | (1 << (lefParser.KW_Post - 166)) | (1 << (lefParser.KW_TopLeft - 166)) | (1 << (lefParser.KW_TopRight - 166)) | (1 << (lefParser.KW_BottomLeft - 166)) | (1 << (lefParser.KW_BottomRight - 166)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SymmetryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_X(self):
            return self.getToken(lefParser.KW_X, 0)

        def KW_Y(self):
            return self.getToken(lefParser.KW_Y, 0)

        def KW_R90(self):
            return self.getToken(lefParser.KW_R90, 0)

        def getRuleIndex(self):
            return lefParser.RULE_symmetry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymmetry" ):
                listener.enterSymmetry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymmetry" ):
                listener.exitSymmetry(self)




    def symmetry(self):

        localctx = lefParser.SymmetryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_symmetry)
        try:
            self.state = 883
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 873
                self.match(lefParser.KW_X)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 874
                self.match(lefParser.KW_Y)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 875
                self.match(lefParser.KW_R90)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 876
                self.match(lefParser.KW_X)
                self.state = 877
                self.match(lefParser.KW_Y)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 878
                self.match(lefParser.KW_Y)
                self.state = 879
                self.match(lefParser.KW_R90)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 880
                self.match(lefParser.KW_X)
                self.state = 881
                self.match(lefParser.KW_Y)
                self.state = 882
                self.match(lefParser.KW_R90)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pin_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Pin(self):
            return self.getToken(lefParser.KW_Pin, 0)

        def Name(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Name)
            else:
                return self.getToken(lefParser.Name, i)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def pin_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Pin_propertyContext)
            else:
                return self.getTypedRuleContext(lefParser.Pin_propertyContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_pin_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPin_declaration" ):
                listener.enterPin_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPin_declaration" ):
                listener.exitPin_declaration(self)




    def pin_declaration(self):

        localctx = lefParser.Pin_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_pin_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            self.match(lefParser.KW_Pin)
            self.state = 886
            self.match(lefParser.Name)
            self.state = 890
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (lefParser.KW_Direction - 86)) | (1 << (lefParser.KW_Use - 86)) | (1 << (lefParser.KW_Shape - 86)) | (1 << (lefParser.KW_Port - 86)) | (1 << (lefParser.KW_AntennaGateArea - 86)) | (1 << (lefParser.KW_AntennaDiffArea - 86)))) != 0):
                self.state = 887
                self.pin_property()
                self.state = 892
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 893
            self.match(lefParser.KW_End)
            self.state = 894
            self.match(lefParser.Name)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pin_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Direction(self):
            return self.getToken(lefParser.KW_Direction, 0)

        def pin_direction(self):
            return self.getTypedRuleContext(lefParser.Pin_directionContext,0)


        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def KW_Use(self):
            return self.getToken(lefParser.KW_Use, 0)

        def KW_Power(self):
            return self.getToken(lefParser.KW_Power, 0)

        def KW_Ground(self):
            return self.getToken(lefParser.KW_Ground, 0)

        def KW_Clock(self):
            return self.getToken(lefParser.KW_Clock, 0)

        def KW_Signal(self):
            return self.getToken(lefParser.KW_Signal, 0)

        def KW_Shape(self):
            return self.getToken(lefParser.KW_Shape, 0)

        def KW_Abutment(self):
            return self.getToken(lefParser.KW_Abutment, 0)

        def KW_AntennaGateArea(self):
            return self.getToken(lefParser.KW_AntennaGateArea, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def KW_AntennaDiffArea(self):
            return self.getToken(lefParser.KW_AntennaDiffArea, 0)

        def KW_Port(self):
            return self.getToken(lefParser.KW_Port, 0)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def macro_layer_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Macro_layer_declarationContext)
            else:
                return self.getTypedRuleContext(lefParser.Macro_layer_declarationContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_pin_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPin_property" ):
                listener.enterPin_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPin_property" ):
                listener.exitPin_property(self)




    def pin_property(self):

        localctx = lefParser.Pin_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_pin_property)
        self._la = 0 # Token type
        try:
            self.state = 920
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Direction]:
                self.enterOuterAlt(localctx, 1)
                self.state = 896
                self.match(lefParser.KW_Direction)
                self.state = 897
                self.pin_direction()
                self.state = 898
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Use]:
                self.enterOuterAlt(localctx, 2)
                self.state = 900
                self.match(lefParser.KW_Use)
                self.state = 901
                _la = self._input.LA(1)
                if not(((((_la - 124)) & ~0x3f) == 0 and ((1 << (_la - 124)) & ((1 << (lefParser.KW_Power - 124)) | (1 << (lefParser.KW_Ground - 124)) | (1 << (lefParser.KW_Signal - 124)) | (1 << (lefParser.KW_Clock - 124)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 902
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Shape]:
                self.enterOuterAlt(localctx, 3)
                self.state = 903
                self.match(lefParser.KW_Shape)
                self.state = 904
                self.match(lefParser.KW_Abutment)
                self.state = 905
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaGateArea]:
                self.enterOuterAlt(localctx, 4)
                self.state = 906
                self.match(lefParser.KW_AntennaGateArea)
                self.state = 907
                self.match(lefParser.Number)
                self.state = 908
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_AntennaDiffArea]:
                self.enterOuterAlt(localctx, 5)
                self.state = 909
                self.match(lefParser.KW_AntennaDiffArea)
                self.state = 910
                self.match(lefParser.Number)
                self.state = 911
                self.match(lefParser.Semicolon)
                pass
            elif token in [lefParser.KW_Port]:
                self.enterOuterAlt(localctx, 6)
                self.state = 912
                self.match(lefParser.KW_Port)
                self.state = 916
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==lefParser.KW_Layer:
                    self.state = 913
                    self.macro_layer_declaration()
                    self.state = 918
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 919
                self.match(lefParser.KW_End)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pin_directionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Input(self):
            return self.getToken(lefParser.KW_Input, 0)

        def KW_Output(self):
            return self.getToken(lefParser.KW_Output, 0)

        def KW_Tristate(self):
            return self.getToken(lefParser.KW_Tristate, 0)

        def KW_Inout(self):
            return self.getToken(lefParser.KW_Inout, 0)

        def KW_Feedthru(self):
            return self.getToken(lefParser.KW_Feedthru, 0)

        def getRuleIndex(self):
            return lefParser.RULE_pin_direction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPin_direction" ):
                listener.enterPin_direction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPin_direction" ):
                listener.exitPin_direction(self)




    def pin_direction(self):

        localctx = lefParser.Pin_directionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_pin_direction)
        self._la = 0 # Token type
        try:
            self.state = 929
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [lefParser.KW_Input]:
                self.enterOuterAlt(localctx, 1)
                self.state = 922
                self.match(lefParser.KW_Input)
                pass
            elif token in [lefParser.KW_Output]:
                self.enterOuterAlt(localctx, 2)
                self.state = 923
                self.match(lefParser.KW_Output)
                self.state = 925
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==lefParser.KW_Tristate:
                    self.state = 924
                    self.match(lefParser.KW_Tristate)


                pass
            elif token in [lefParser.KW_Inout]:
                self.enterOuterAlt(localctx, 3)
                self.state = 927
                self.match(lefParser.KW_Inout)
                pass
            elif token in [lefParser.KW_Feedthru]:
                self.enterOuterAlt(localctx, 4)
                self.state = 928
                self.match(lefParser.KW_Feedthru)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Obs_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Obs(self):
            return self.getToken(lefParser.KW_Obs, 0)

        def KW_End(self):
            return self.getToken(lefParser.KW_End, 0)

        def macro_layer_declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(lefParser.Macro_layer_declarationContext)
            else:
                return self.getTypedRuleContext(lefParser.Macro_layer_declarationContext,i)


        def getRuleIndex(self):
            return lefParser.RULE_obs_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObs_declaration" ):
                listener.enterObs_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObs_declaration" ):
                listener.exitObs_declaration(self)




    def obs_declaration(self):

        localctx = lefParser.Obs_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_obs_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 931
            self.match(lefParser.KW_Obs)
            self.state = 935
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lefParser.KW_Layer:
                self.state = 932
                self.macro_layer_declaration()
                self.state = 937
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 938
            self.match(lefParser.KW_End)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_layer_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Layer(self):
            return self.getToken(lefParser.KW_Layer, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def Semicolon(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Semicolon)
            else:
                return self.getToken(lefParser.Semicolon, i)

        def KW_Rect(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.KW_Rect)
            else:
                return self.getToken(lefParser.KW_Rect, i)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def getRuleIndex(self):
            return lefParser.RULE_macro_layer_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacro_layer_declaration" ):
                listener.enterMacro_layer_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacro_layer_declaration" ):
                listener.exitMacro_layer_declaration(self)




    def macro_layer_declaration(self):

        localctx = lefParser.Macro_layer_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_macro_layer_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 940
            self.match(lefParser.KW_Layer)
            self.state = 941
            self.match(lefParser.Name)
            self.state = 942
            self.match(lefParser.Semicolon)
            self.state = 951
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==lefParser.KW_Rect:
                self.state = 943
                self.match(lefParser.KW_Rect)
                self.state = 944
                self.match(lefParser.Number)
                self.state = 945
                self.match(lefParser.Number)
                self.state = 946
                self.match(lefParser.Number)
                self.state = 947
                self.match(lefParser.Number)
                self.state = 948
                self.match(lefParser.Semicolon)
                self.state = 953
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def getRuleIndex(self):
            return lefParser.RULE_pt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPt" ):
                listener.enterPt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPt" ):
                listener.exitPt(self)




    def pt(self):

        localctx = lefParser.PtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_pt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.match(lefParser.Number)
            self.state = 955
            self.match(lefParser.Number)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tuple_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.LParen)
            else:
                return self.getToken(lefParser.LParen, i)

        def RParen(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.RParen)
            else:
                return self.getToken(lefParser.RParen, i)

        def Number(self, i:int=None):
            if i is None:
                return self.getTokens(lefParser.Number)
            else:
                return self.getToken(lefParser.Number, i)

        def getRuleIndex(self):
            return lefParser.RULE_tuple_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTuple_list" ):
                listener.enterTuple_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTuple_list" ):
                listener.exitTuple_list(self)




    def tuple_list(self):

        localctx = lefParser.Tuple_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_tuple_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            self.match(lefParser.LParen)
            self.state = 962 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 958
                self.match(lefParser.LParen)
                self.state = 959
                self.match(lefParser.Number)
                self.state = 960
                self.match(lefParser.Number)
                self.state = 961
                self.match(lefParser.RParen)
                self.state = 964 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==lefParser.LParen):
                    break

            self.state = 966
            self.match(lefParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_Property(self):
            return self.getToken(lefParser.KW_Property, 0)

        def Name(self):
            return self.getToken(lefParser.Name, 0)

        def Semicolon(self):
            return self.getToken(lefParser.Semicolon, 0)

        def Number(self):
            return self.getToken(lefParser.Number, 0)

        def String(self):
            return self.getToken(lefParser.String, 0)

        def getRuleIndex(self):
            return lefParser.RULE_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProperty" ):
                listener.enterProperty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProperty" ):
                listener.exitProperty(self)




    def property_(self):

        localctx = lefParser.PropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_property)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 968
            self.match(lefParser.KW_Property)
            self.state = 969
            self.match(lefParser.Name)
            self.state = 970
            _la = self._input.LA(1)
            if not(_la==lefParser.String or _la==lefParser.Number):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 971
            self.match(lefParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





