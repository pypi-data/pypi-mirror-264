{"version":3,"file":"static/js/7277.577f30b8.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/src/utils/form.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/interactive.tsx","../node_modules/@esri/calcite-components/dist/components/src/utils/browser.ts","../node_modules/@esri/calcite-components/dist/components/src/utils/label.ts"],"sourcesContent":["import { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\nimport { FunctionalComponent, h } from \"@stencil/core\";\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nexport const componentsWithInputEvent = [\n  \"calcite-input\",\n  \"calcite-input-number\",\n  \"calcite-input-text\",\n  \"calcite-text-area\",\n];\n\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nexport function getClearValidationEventName(componentTag: string): string {\n  const componentTagCamelCase = componentTag\n    .split(\"-\")\n    .map((part: string, index: number) =>\n      index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`,\n    )\n    .join(\"\");\n\n  const clearValidationEvent = `${componentTagCamelCase}${\n    componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"\n  }`;\n\n  return clearValidationEvent;\n}\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?(): void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?(input: HTMLInputElement): void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement,\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\",\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true },\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    }),\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\nfunction clearFormValidation(component: HTMLCalciteInputElement | FormComponent): void {\n  \"status\" in component && (component.status = \"idle\");\n  \"validationIcon\" in component && (component.validationIcon = false);\n  \"validationMessage\" in component && (component.validationMessage = \"\");\n}\n\nfunction setInvalidFormValidation(\n  component: HTMLCalciteInputElement | FormComponent,\n  message: string,\n): void {\n  \"status\" in component && (component.status = \"invalid\");\n\n  \"validationIcon\" in component && !component.validationIcon && (component.validationIcon = true);\n\n  \"validationMessage\" in component &&\n    !component.validationMessage &&\n    (component.validationMessage = message);\n}\n\nfunction displayValidationMessage(event: Event) {\n  // target is the hidden input, which is slotted in the actual form component\n  const hiddenInput = event?.target as HTMLInputElement;\n\n  // not necessarily a calcite-input, but we don't have an HTMLCalciteFormElement type\n  const formComponent = hiddenInput?.parentElement as HTMLCalciteInputElement;\n\n  const componentTag = formComponent?.nodeName?.toLowerCase();\n  const componentTagParts = componentTag?.split(\"-\");\n\n  if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n    return;\n  }\n\n  // prevent the browser from showing the native validation popover\n  event?.preventDefault();\n\n  setInvalidFormValidation(formComponent, hiddenInput?.validationMessage);\n\n  if (formComponent?.validationMessage !== hiddenInput?.validationMessage) {\n    return;\n  }\n\n  const clearValidationEvent = getClearValidationEventName(componentTag);\n  formComponent.addEventListener(clearValidationEvent, () => clearFormValidation(formComponent), {\n    once: true,\n  });\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.addEventListener(\"invalid\", displayValidationMessage, true);\n  formEl.requestSubmit();\n  formEl.removeEventListener(\"invalid\", displayValidationMessage, true);\n\n  requestAnimationFrame(() => {\n    const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n\n    // focus the first invalid element that has a validation message\n    for (const el of invalidEls) {\n      if ((el as HTMLCalciteInputElement)?.validationMessage) {\n        (el as HTMLCalciteInputElement)?.setFocus();\n        break;\n      }\n    }\n  });\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary<HTMLFormElement>(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  clearFormValidation(this);\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nexport const internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\n\nconst hiddenInputInputHandler = (event: Event) => {\n  event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"input\", hiddenInputInputHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value,\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument!.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument!.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"input\", hiddenInputInputHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string,\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}) => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n","import { getUserAgentString } from \"./browser\";\nimport { JSXAttributes } from \"@stencil/core/internal\";\nimport { FunctionalComponent, h, VNode } from \"@stencil/core\";\n\nexport interface InteractiveComponent {\n  /**\n   * The host element.\n   */\n  readonly el: InteractiveHTMLElement;\n\n  /**\n   * When true, prevents user interaction.\n   *\n   * Notes:\n   *\n   * This prop should use the @Prop decorator and reflect.\n   * The `disabled` Sass mixin must be added to the component's stylesheet.\n   */\n  disabled: boolean;\n}\n\n/**\n * Exported for testing purposes only.\n *\n * @internal\n */\nexport type InteractiveHTMLElement = HTMLElement & Pick<InteractiveComponent, \"disabled\">;\n\n// ⚠️ browser-sniffing is not a best practice and should be avoided ⚠️\nconst isFirefox = /firefox/i.test(getUserAgentString());\n\ntype ParentElement<T extends HTMLElement = HTMLElement> = T | null;\n\nconst disabledElementToParent: WeakMap<InteractiveHTMLElement, ParentElement> | null = isFirefox\n  ? new WeakMap()\n  : null;\n\nfunction interceptedClick(): void {\n  const { disabled } = this as InteractiveHTMLElement;\n\n  if (!disabled) {\n    HTMLElement.prototype.click.call(this);\n  }\n}\n\nfunction onPointerDown(event: PointerEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  const { disabled } = interactiveElement;\n\n  if (disabled) {\n    // prevent click from moving focus on host\n    event.preventDefault();\n  }\n}\n\nconst nonBubblingWhenDisabledMouseEvents = [\"mousedown\", \"mouseup\", \"click\"];\n\nfunction onNonBubblingWhenDisabledMouseEvent(event: MouseEvent): void {\n  const interactiveElement = event.target as InteractiveHTMLElement;\n\n  if (isFirefox && !disabledElementToParent.get(interactiveElement)) {\n    return;\n  }\n\n  // prevent disallowed mouse events from being emitted on the disabled host (per https://github.com/whatwg/html/issues/5886)\n  // ⚠ we generally avoid stopping propagation of events, but this is needed to adhere to the intended spec changes above ⚠\n  if (interactiveElement.disabled) {\n    event.stopImmediatePropagation();\n    event.preventDefault();\n  }\n}\n\nconst captureOnlyOptions = { capture: true } as const;\n\n/**\n * This helper updates the host element to prevent keyboard interaction on its subtree and sets the appropriate aria attribute for accessibility.\n *\n * This should be used in the `componentDidRender` lifecycle hook.\n *\n * **Notes**\n *\n * this util is not needed for simple components whose root element or elements are an interactive component (custom element or native control). For those cases, set the `disabled` props on the root components instead.\n * technically, users can override `tabindex` and restore keyboard navigation, but this will be considered user error\n *\n * @param component\n */\nexport function updateHostInteraction(component: InteractiveComponent): void {\n  if (component.disabled) {\n    component.el.setAttribute(\"aria-disabled\", \"true\");\n\n    if (component.el.contains(document.activeElement)) {\n      (document.activeElement as HTMLElement).blur();\n    }\n\n    blockInteraction(component);\n\n    return;\n  }\n\n  restoreInteraction(component);\n\n  component.el.removeAttribute(\"aria-disabled\");\n}\n\nfunction blockInteraction(component: InteractiveComponent): void {\n  component.el.click = interceptedClick;\n\n  if (isFirefox) {\n    const currentParent = getParentElement(component);\n    const trackedParent = disabledElementToParent.get(component.el);\n\n    if (trackedParent !== currentParent) {\n      removeInteractionListeners(trackedParent);\n      disabledElementToParent.set(component.el, currentParent);\n    }\n\n    addInteractionListeners(disabledElementToParent.get(component.el));\n    return;\n  }\n\n  addInteractionListeners(component.el);\n}\n\nfunction addInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.addEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.addEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\nfunction getParentElement(component: InteractiveComponent): ParentElement {\n  return (\n    component.el.parentElement || component.el\n  ); /* assume element is host if it has no parent when connected */\n}\n\nfunction restoreInteraction(component: InteractiveComponent): void {\n  delete component.el.click; // fallback on HTMLElement.prototype.click\n\n  if (isFirefox) {\n    removeInteractionListeners(disabledElementToParent.get(component.el));\n    disabledElementToParent.delete(component.el);\n    return;\n  }\n\n  removeInteractionListeners(component.el);\n}\n\nfunction removeInteractionListeners(element: HTMLElement): void {\n  if (!element) {\n    // this early return path is only applicable to Firefox\n    return;\n  }\n\n  element.removeEventListener(\"pointerdown\", onPointerDown, captureOnlyOptions);\n  nonBubblingWhenDisabledMouseEvents.forEach((event) =>\n    element.removeEventListener(event, onNonBubblingWhenDisabledMouseEvent, captureOnlyOptions),\n  );\n}\n\n/**\n * This utility helps disable components consistently in Firefox.\n *\n * It needs to be called in `connectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function connectInteractive(component: InteractiveComponent): void {\n  if (!component.disabled || !isFirefox) {\n    return;\n  }\n\n  blockInteraction(component);\n}\n\n/**\n * This utility restores interactivity to disabled components consistently in Firefox.\n *\n * It needs to be called in `disconnectedCallback` and is only needed for Firefox as it does not call capture event listeners before non-capture ones (see https://bugzilla.mozilla.org/show_bug.cgi?id=1731504).\n *\n * @param component\n */\nexport function disconnectInteractive(component: InteractiveComponent): void {\n  if (!isFirefox) {\n    return;\n  }\n\n  restoreInteraction(component);\n}\n\nexport interface InteractiveContainerOptions extends JSXAttributes {\n  disabled: boolean;\n}\n\nexport const CSS = {\n  container: \"interaction-container\",\n};\n\nexport function InteractiveContainer(\n  { disabled }: InteractiveContainerOptions,\n  children: VNode[],\n): FunctionalComponent {\n  return (\n    <div class={CSS.container} inert={disabled}>\n      {...children}\n    </div>\n  );\n}\n","import { Build } from \"@stencil/core\";\n\ninterface NavigatorUAData {\n  brands: Array<{ brand: string; version: string }>;\n  mobile: boolean;\n  platform: string;\n}\n\nfunction getUserAgentData(): NavigatorUAData | undefined {\n  return (navigator as any).userAgentData;\n}\n\nexport function getUserAgentString(): string {\n  if (!Build.isBrowser) {\n    return \"\";\n  }\n\n  const uaData = getUserAgentData();\n\n  return uaData?.brands\n    ? uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \")\n    : navigator.userAgent;\n}\n","import { closestElementCrossShadowBoundary, isBefore, queryElementRoots } from \"./dom\";\nimport { componentOnReady } from \"./component\";\n\nexport interface LabelableComponent {\n  /**\n   * When true, disabled prevents interaction.\n   */\n  disabled: boolean;\n\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * Text label.\n   */\n  label?: string;\n\n  /**\n   * The label this component is associated with.\n   */\n  labelEl: HTMLCalciteLabelElement;\n\n  /**\n   * Hook for components to provide custom label click behavior.\n   */\n  onLabelClick: (event: CustomEvent<any>) => void;\n}\n\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nexport const labelClickEvent = \"calciteInternalLabelClick\";\nexport const labelConnectedEvent = \"calciteInternalLabelConnected\";\nexport const labelDisconnectedEvent = \"calciteInternalLabelDisconnected\";\n\nconst labelTagName = \"calcite-label\";\nconst labelToLabelables = new WeakMap<HTMLCalciteLabelElement, LabelableComponent[]>();\nconst onLabelClickMap = new WeakMap<HTMLCalciteLabelElement, typeof onLabelClick>();\nconst onLabelConnectedMap = new WeakMap<LabelableComponent, typeof onLabelConnected>();\nconst onLabelDisconnectedMap = new WeakMap<LabelableComponent, typeof onLabelDisconnected>();\nconst unlabeledComponents = new Set<LabelableComponent>();\n\nconst findLabelForComponent = (componentEl: HTMLElement): HTMLCalciteLabelElement | null => {\n  const { id } = componentEl;\n\n  const forLabel =\n    id && (queryElementRoots(componentEl, { selector: `${labelTagName}[for=\"${id}\"]` }) as HTMLCalciteLabelElement);\n\n  if (forLabel) {\n    return forLabel;\n  }\n\n  const parentLabel = closestElementCrossShadowBoundary<HTMLCalciteLabelElement>(componentEl, labelTagName);\n\n  if (\n    !parentLabel ||\n    // labelable components within other custom elements are not considered labelable\n    hasAncestorCustomElements(parentLabel, componentEl)\n  ) {\n    return null;\n  }\n\n  return parentLabel;\n};\n\nfunction hasAncestorCustomElements(label: HTMLCalciteLabelElement, componentEl: HTMLElement): boolean {\n  let traversedElements: HTMLElement[];\n  const customElementAncestorCheckEventType = \"custom-element-ancestor-check\";\n\n  const listener = (event: CustomEvent) => {\n    event.stopImmediatePropagation();\n    const composedPath = event.composedPath() as HTMLElement[];\n    traversedElements = composedPath.slice(composedPath.indexOf(componentEl), composedPath.indexOf(label));\n  };\n\n  label.addEventListener(customElementAncestorCheckEventType, listener, { once: true });\n\n  componentEl.dispatchEvent(new CustomEvent(customElementAncestorCheckEventType, { composed: true, bubbles: true }));\n  label.removeEventListener(customElementAncestorCheckEventType, listener);\n\n  const ancestorCustomElements = traversedElements\n    .filter((el) => el !== componentEl && el !== label)\n    .filter((el) => el.tagName?.includes(\"-\"));\n\n  return ancestorCustomElements.length > 0;\n}\n\n/**\n * Helper to set up label interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  const labelEl = findLabelForComponent(component.el);\n\n  if (\n    (onLabelClickMap.has(labelEl) && labelEl === component.labelEl) ||\n    (!labelEl && unlabeledComponents.has(component))\n  ) {\n    return;\n  }\n\n  const boundOnLabelDisconnected = onLabelDisconnected.bind(component);\n\n  if (labelEl) {\n    component.labelEl = labelEl;\n\n    const labelables = labelToLabelables.get(labelEl) || [];\n    labelables.push(component);\n    labelToLabelables.set(labelEl, labelables.sort(sortByDOMOrder));\n\n    if (!onLabelClickMap.has(component.labelEl)) {\n      onLabelClickMap.set(component.labelEl, onLabelClick);\n      component.labelEl.addEventListener(labelClickEvent, onLabelClick);\n    }\n\n    unlabeledComponents.delete(component);\n    document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n    onLabelDisconnectedMap.set(component, boundOnLabelDisconnected);\n    document.addEventListener(labelDisconnectedEvent, boundOnLabelDisconnected);\n  } else if (!unlabeledComponents.has(component)) {\n    boundOnLabelDisconnected();\n    document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  }\n}\n/**\n * Helper to tear down label interactions on disconnectedCallback on labelable components.\n *\n * @param component\n */\nexport function disconnectLabel(component: LabelableComponent): void {\n  if (!component) {\n    return;\n  }\n\n  unlabeledComponents.delete(component);\n  document.removeEventListener(labelConnectedEvent, onLabelConnectedMap.get(component));\n  document.removeEventListener(labelDisconnectedEvent, onLabelDisconnectedMap.get(component));\n  onLabelConnectedMap.delete(component);\n  onLabelDisconnectedMap.delete(component);\n\n  if (!component.labelEl) {\n    return;\n  }\n\n  const labelables = labelToLabelables.get(component.labelEl);\n\n  if (labelables.length === 1) {\n    component.labelEl.removeEventListener(labelClickEvent, onLabelClickMap.get(component.labelEl));\n    onLabelClickMap.delete(component.labelEl);\n  }\n\n  labelToLabelables.set(\n    component.labelEl,\n    labelables.filter((labelable) => labelable !== component).sort(sortByDOMOrder),\n  );\n\n  component.labelEl = null;\n}\n\nfunction sortByDOMOrder(a: LabelableComponent, b: LabelableComponent): number {\n  return isBefore(a.el, b.el) ? -1 : 1;\n}\n\n/**\n * Helper to get the label text from a component.\n *\n * @param component\n */\nexport function getLabelText(component: LabelableComponent): string {\n  return component.label || component.labelEl?.textContent?.trim() || \"\";\n}\n\nfunction onLabelClick(this: HTMLCalciteLabelElement, event: CustomEvent<{ sourceEvent: MouseEvent }>): void {\n  const labelClickTarget = event.detail.sourceEvent.target as HTMLElement;\n  const labelables = labelToLabelables.get(this);\n  const clickedLabelable = labelables.find((labelable) => labelable.el === labelClickTarget);\n  const labelableChildClicked = labelables.includes(clickedLabelable);\n\n  if (labelableChildClicked) {\n    // no need to forward click as labelable will receive focus\n    return;\n  }\n\n  const firstLabelable = labelables[0];\n\n  if (firstLabelable.disabled) {\n    return;\n  }\n\n  firstLabelable.onLabelClick(event);\n}\n\nfunction onLabelConnected(this: LabelableComponent): void {\n  if (unlabeledComponents.has(this)) {\n    connectLabel(this);\n  }\n}\n\nfunction onLabelDisconnected(this: LabelableComponent): void {\n  unlabeledComponents.add(this);\n  const boundOnLabelConnected = onLabelConnectedMap.get(this) || onLabelConnected.bind(this);\n  onLabelConnectedMap.set(this, boundOnLabelConnected);\n  document.addEventListener(labelConnectedEvent, boundOnLabelConnected);\n}\n\n/**\n * Helper to associate an explicit label (i.e., using `for`) with a labelable component that does not have an associated label.\n *\n * @param label - the label element\n */\nexport async function associateExplicitLabelToUnlabeledComponent(label: HTMLCalciteLabelElement): Promise<void> {\n  await componentOnReady(label);\n\n  const alreadyLabeled = labelToLabelables.has(label);\n\n  if (alreadyLabeled) {\n    return;\n  }\n\n  const forComponentEl = label.ownerDocument?.getElementById(label.for);\n\n  if (!forComponentEl) {\n    return;\n  }\n\n  requestAnimationFrame(() => {\n    for (const labelable of unlabeledComponents) {\n      if (labelable.el === forComponentEl) {\n        connectLabel(labelable);\n        break;\n      }\n    }\n  });\n}\n"],"names":["componentsWithInputEvent","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","clearFormValidation","status","validationIcon","validationMessage","displayValidationMessage","event","_formComponent$nodeNa","hiddenInput","target","formComponent","parentElement","componentTag","nodeName","toLowerCase","componentTagParts","split","length","message","preventDefault","clearValidationEvent","componentTagCamelCase","map","part","index","concat","toUpperCase","slice","join","includes","getClearValidationEventName","addEventListener","once","submitForm","formEl","requestSubmit","removeEventListener","requestAnimationFrame","invalidEls","querySelectorAll","el","setFocus","resetForm","_component$formEl","reset","connectForm","value","associatedForm","findAssociatedForm","form","formComponentEl","closestElementCrossShadowBoundary","formComponentRegisterEventName","hasRegisteredFormComponentParent","composedPath","some","element","has","stopPropagation","dispatchEvent","CustomEvent","bubbles","composed","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","this","disconnectForm","get","delete","internalHiddenInputInputEvent","hiddenInputInputHandler","removeHiddenInputChangeEventListener","input","defaultSyncHiddenFormInput","_component$syncHidden","disabled","name","required","tabIndex","setAttribute","removeAttribute","syncHiddenFormInput","call","HiddenFormInputSlot","_ref","ownerDocument","inputs","forEach","remove","values","Array","isArray","extra","seen","Set","docFrag","valueMatch","find","val","push","pop","createElement","slot","createDocumentFragment","append","h","isFirefox","test","Build","isBrowser","uaData","navigator","userAgentData","brands","brand","version","userAgent","getUserAgentString","disabledElementToParent","interceptedClick","HTMLElement","prototype","click","onPointerDown","interactiveElement","nonBubblingWhenDisabledMouseEvents","onNonBubblingWhenDisabledMouseEvent","stopImmediatePropagation","captureOnlyOptions","capture","updateHostInteraction","contains","document","activeElement","blur","blockInteraction","restoreInteraction","currentParent","getParentElement","trackedParent","removeInteractionListeners","addInteractionListeners","connectInteractive","disconnectInteractive","CSS","container","InteractiveContainer","_ref2","children","class","inert","labelClickEvent","labelConnectedEvent","labelDisconnectedEvent","labelTagName","labelToLabelables","onLabelClickMap","onLabelConnectedMap","onLabelDisconnectedMap","unlabeledComponents","findLabelForComponent","componentEl","forLabel","selector","parentLabel","label","traversedElements","customElementAncestorCheckEventType","listener","indexOf","ancestorCustomElements","filter","_el$tagName","tagName","hasAncestorCustomElements","connectLabel","labelEl","boundOnLabelDisconnected","onLabelDisconnected","labelables","sort","sortByDOMOrder","onLabelClick","disconnectLabel","labelable","a","b","isBefore","getLabelText","_component$labelEl","textContent","trim","labelClickTarget","detail","sourceEvent","clickedLabelable","firstLabelable","onLabelConnected","boundOnLabelConnected","async","associateExplicitLabelToUnlabeledComponent","_label$ownerDocument","componentOnReady","forComponentEl","getElementById","for"],"sourceRoot":""}