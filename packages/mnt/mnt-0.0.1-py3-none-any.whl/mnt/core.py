# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['DOT', 'NIL', 'SYS', 'LOADER', 'P', 'TD', 'filterdict', 'LoadModuleKeywords', 'LoadModuleAttributeKeywords',
           'LoadModuleAttributesKeywords', 'isnone', 'notnone', 'isspec', 'ismodule', 'isloader', 'getloader',
           'getspec', 'getname', 'get__all__', 'in_sys', 'load_module', 'load_module_attr', 'load_module_attrs',
           'mount']

# %% ../nbs/00_core.ipynb 6
import io, sys
from importlib import import_module
from importlib.abc import Loader
from importlib.util import (module_from_spec, find_spec)
from importlib.machinery import ModuleSpec
from functools import singledispatch, partial, wraps
from contextlib import redirect_stderr, redirect_stdout
from itertools import chain

# %% ../nbs/00_core.ipynb 8
from types import ModuleType, NoneType
from typing import Any, Union, TypeVar, ParamSpec, TypedDict, TypeGuard, overload, _TypedDictMeta

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
#| export


# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
DOT = '.'
NIL = ''
SYS = 'sys'
LOADER = 'loader'
__ALL__ = '__all__'
__NAME__ = f'__name__'
__SPEC__ = f'__spec__'
__LOADER__ = f'__{LOADER}__'
__MODULE__ = '__module__'

# %% ../nbs/00_core.ipynb 18
P = ParamSpec('P')

TD = TypeVar('TD', _TypedDictMeta, dict)

# %% ../nbs/00_core.ipynb 20
def _str(v: str | Any) -> str:
    '''Falsey values return the nil string i.e. `''` otherwise use the `str` constructor.'''
    return NIL if not(v) else str(v)

def _dot(*strs) -> str:
    '''Join any number of strings by dots i.e. `'.'`.'''
    return DOT.join(tuple(filter(str, map(_str, strs)))).removesuffix(DOT)

def filterdict(td: TD, **kwds: P.kwargs) -> TD:
    return td({k:v for k, v in kwds.items() if k in td.__annotations__})

# %% ../nbs/00_core.ipynb 22
class LoadModuleKeywords(TypedDict):
    '''Load Module Keywords
    
    Attributes
    ----------
    path : str
        The string representation of the module to load
        
    spec : ModuleSpec, optional
        The `ModuleSpec` used to load the module. If not provided
        retrieved from `find_spec`.
        
    module : ModuleType, optional
        The `ModuleType` to load. If not provided created from
        `module_from_spec`.
        
    loader : Loader, optional
        The `Loader` used to load the module. If not provided, 
        retrieved from `spec.loader`.
        
    hush : bool, default: True
        Whether or not to silence errors.
        
    do_exec: bool, default: True
        Whether or not to execute the `module` via the `loader` i.e.
        `loader.exec_module(module)`.
        
    package : str, optional
        Required when performing a relative import. `package` specifies the 
        package to use as the anchor point from which to resolve the relative 
        import to an absolute import.
        
    mount : bool, default: True
        Whether or not to mount the module in `sys.modules`.
    '''
    path: str
    spec: ModuleSpec | None
    module: ModuleType | None
    loader: Loader | None
    hush: bool = True
    do_exec: bool = True
    mount: bool = True
    package: str | None = None
    
    @classmethod
    def filter(cls, **kwargs) -> 'LoadModuleKeywords':
        return filterdict(cls, **kwargs)
    
class LoadModuleAttributeKeywords(LoadModuleKeywords):
    '''Load Module Attribute Keywords
    
    Attributes
    ----------
    path : str
        The string representation of the module to load
        
    spec : ModuleSpec, optional
        The `ModuleSpec` used to load the module. If not provided
        retrieved from `find_spec`.
        
    module : ModuleType, optional
        The `ModuleType` to load. If not provided created from
        `module_from_spec`.
        
    loader : Loader, optional
        The `Loader` used to load the module. If not provided, 
        retrieved from `spec.loader`.
        
    hush : bool, default: True
        Whether or not to silence errors.
        
    do_exec: bool, default: True
        Whether or not to execute the `module` via the `loader` i.e.
        `loader.exec_module(module)`.
        
    mount : bool, default: True
        Whether or not to mount the module in `sys.modules`.
        
    package : str, optional
        Required when performing a relative import. `package` specifies the 
        package to use as the anchor point from which to resolve the relative 
        import to an absolute import.
        
    attr : str, optional
        The attribute to retrieve from the loaded module. If `None`, returns the
        module instead.
        
    default : Any, optional
        The default value to return if attr is not `None` but does not exist in `module`.
    '''
    attr: str | None = None
    default: Any | None = None
    
    @classmethod
    def filter(cls, **kwargs) -> 'LoadModuleAttributeKeywords':
        return filterdict(cls, **kwargs)
    
    
class LoadModuleAttributesKeywords(TypedDict):
    '''Load Module Attributes Keywords
    
    Attributes
    ----------
    path : str
        The string representation of the module to load
        
    hush : bool, default: True
        Whether or not to silence errors.
        
    do_exec: bool, default: True
        Whether or not to execute the `module` via the `loader` i.e.
        `loader.exec_module(module)`.
        
    mount : bool, default: False
        Whether or not to mount the module in `sys.modules`.
        
    package : str, optional
        Required when performing a relative import. `package` specifies the 
        package to use as the anchor point from which to resolve the relative 
        import to an absolute import.
            
    attrs : tuple[str, ...], optional
        The attributes to load from the final (sub)module.
            
    defaults : tuple[Any, ...], optional
        The default values to use for these attributes.
    '''
    path: str
    hush: bool = True
    do_exec: bool = True
    mount: bool = True
    package: str | None = None
    attrs: tuple[str, ...] | None = None
    defaults: tuple[Any, ...] | None = None
    @classmethod
    def filter(cls, **kwargs) -> 'LoadModuleAttributesKeywords':
        return filterdict(cls, **kwargs)

# %% ../nbs/00_core.ipynb 24
def isnone(x) -> TypeGuard[None]:
    return x is None

def notnone(x) -> TypeGuard[Any]:
    return not isnone(x)

def isspec(x) -> TypeGuard[ModuleSpec]:
    return isinstance(x, ModuleSpec)

def ismodule(x) -> TypeGuard[ModuleType]:
    return isinstance(x, ModuleType)

def isloader(x) -> TypeGuard[Loader]:
    return isinstance(x, Loader)

# %% ../nbs/00_core.ipynb 27
@singledispatch
def getloader(obj: ModuleSpec | ModuleType | Loader | object | None) -> Loader | None:
    '''Get the `Loader` from the given input if it exists, otherwise returns `None`.'''
    if isspec(obj): return getloader.dispatch(ModuleSpec)(obj)
    if ismodule(obj): return getloader.dispatch(ModuleType)(obj)
    if isloader(obj): return getloader.dispatch(Loader)(obj)
    return None
    
@getloader.register(ModuleSpec)
def _(spec: ModuleSpec) -> Loader | None:
    return getattr(spec, LOADER, None) if isspec(spec) else None
    
@getloader.register(ModuleType)
def _(modl: ModuleType) -> Loader | None:
    return getattr(modl, __LOADER__, None) if ismodule(modl) else None

@getloader.register(Loader)
def _(load: Loader) -> Loader | None:
    return load if isloader(load) else None


# %% ../nbs/00_core.ipynb 29
@singledispatch
def getspec(obj: ModuleSpec | ModuleType | Loader | object | None) -> ModuleSpec | None:
    '''Get the `ModuleSpec` from the given input if it exists, otherwise returns `None`.'''
    if isspec(obj): return getspec.dispatch(ModuleSpec)(obj)
    if ismodule(obj): return getspec.dispatch(ModuleType)(obj)
    if isloader(obj): return getspec.dispatch(Loader)(obj)
    return None

@getspec.register(ModuleSpec)
def _(spec: ModuleSpec) -> Loader | None:
    return spec if isspec(spec) else None

@getspec.register(ModuleType)
def _(modl: ModuleType) -> Loader | None:
    return getattr(modl, __SPEC__, None) if ismodule(modl) else None

@getspec.register(Loader)
def _(load: Loader) -> Loader | None:
    if isloader(load): return getspec.dispatch(ModuleType)(load.load_module())
    return None

# %% ../nbs/00_core.ipynb 31
@singledispatch
def getname(obj: ModuleSpec | ModuleType | Loader | object | None) -> ModuleSpec | None:
    '''Get the `ModuleSpec` from the given input if it exists, otherwise returns `None`.'''
    if isspec(obj): return getname.dispatch(ModuleSpec)(obj)
    if ismodule(obj): return getname.dispatch(ModuleType)(obj)
    if isloader(obj): return getname.dispatch(Loader)(obj)
    return None

@getname.register(ModuleSpec)
def _(spec: ModuleSpec) -> Loader | None:
    return spec.name if isspec(spec) else None

@getname.register(ModuleType)
def _(modl: ModuleType) -> Loader | None:
    return getattr(modl, __NAME__, None) if ismodule(modl) else None

@getname.register(Loader)
def _(load: Loader) -> Loader | None:
    return load.name if isloader(load) else None

# %% ../nbs/00_core.ipynb 32
@singledispatch
def get__all__(obj: ModuleType | object | None) -> list[str]:
    '''Get `ModuleType.__all__` from the given obj if it exists, otherwise returns `[]`.'''
    if ismodule(obj): return get__all__.dispatch(ModuleType)(obj)
    if isinstance(obj, object): return get__all__.dispatch(object)(obj)
    if hasattr(obj, __MODULE__): get__all__.dispatch(ModuleType)(import_module(obj.__module__))
    return []
    raise AttributeError(f'''module {obj} has no attribute '__all__'.''')

@getname.register(ModuleType)
def _(modl: ModuleType) -> Loader | None:
    return getattr(modl, __ALL__, []) if ismodule(modl) else []

@getname.register(object)
def _(item: ModuleSpec) -> Loader | None:
    if not hasattr(item, __MODULE__): return []
    return get__all__.dispatch(ModuleType)(import_module(item.__module__))

# %% ../nbs/00_core.ipynb 35
def in_sys(path: str, package: str | None = None) -> TypeGuard[ModuleType]:
    '''Check if path is in `sys.modules` with a module of the same name.'''
    full: str = _dot(package, path)
    for name in {path, full}:
        found: ModuleType = sys.modules.get(name)
        mname = getname(found)
        return name == mname
    return False

# %% ../nbs/00_core.ipynb 38
@overload
def load_module(path: str, **kwargs: LoadModuleKeywords) -> ModuleType | None: ...
def load_module(
    path: str | None = None,
    spec: ModuleSpec | None = None,
    module: ModuleType | None = None,
    loader: Loader | None = None,
    hush: bool = True,
    do_exec: bool = True,
    mount: bool = True,
    package: str | None = None,
) -> ModuleType | None:
    '''Load a module dynamically based on the provided parameters.

    Parameters
    ----------
    path : str, optional
        The string representation of the module to load
        
    spec : ModuleSpec, optional
        The `ModuleSpec` used to load the module. If not provided
        retrieved from `find_spec`.
        
    module : ModuleType, optional
        The `ModuleType` to load. If not provided created from
        `module_from_spec`.
        
    loader : Loader, optional
        The `Loader` used to load the module. If not provided, 
        retrieved from `spec.loader`.
        
    hush : bool, default: True
        Whether or not to silence errors.
        
    do_exec: bool, default: True
        Whether or not to execute the `module` via the `loader` i.e.
        `loader.exec_module(module)`.
        
    mount : bool, default: False
        Whether or not to mount the module in `sys.modules`.
        
    package : str, optional
        Required when performing a relative import. `package` specifies the 
        package to use as the anchor point from which to resolve the relative 
        import to an absolute import.
        
    Returns
    -------
    ModuleType | None
        The loaded module object, or `None` if the loading fails and `hush` is `True`.
    
    Raises
    ------
    ValueError
        If none of the `path`, `spec`, or `module` parameters are provided.
        
    ImportError, NameError, AttributeError, ModuleNotFoundError
        If an error occurs during the import and `hush` is `False`.
    '''
    full: str = _dot(package, path)
    
    # print(path, full, in_sys(path), in_sys(full))
    if in_sys(full): return sys.modules[full]
    if in_sys(path): return sys.modules[path]

    
    if not any((full, spec, module)):
        if hush: return None
        raise ValueError(f'One of {path, spec, module} must be not be None.')
    
    specname = getname(spec)
    modlname = getname(module)
    loadname = getname(loader)
    
    if notnone(spec) and specname != full: spec = None
    
    if isnone(spec): 
        try: spec: ModuleSpec | None = find_spec(full)
        except (ImportError, NameError, AttributeError, ModuleNotFoundError) as e:
            if not hush: raise e
    if isnone(spec): spec = getspec(module)
    if isnone(spec): spec = getspec(loader)
    
    
    if notnone(module) and modlname != full: module = None
    if isnone(module): 
        try: module: ModuleType | None = module_from_spec(spec)
        except AttributeError as e:
            if not hush: raise e
        
    if isnone(module):
        try: module: ModuleType = import_module(path, package=package)
        except (ImportError, NameError, AttributeError, ModuleNotFoundError) as e:
            if not hush: raise e
    
    
    if notnone(loader) and loadname != full: loader = None
    if isnone(loader): loader: Loader | None = getloader(spec)
    if isnone(loader): loader: Loader | None = getloader(module)
        
    if do_exec and isloader(loader):
        try: loader.exec_module(module)
        except NameError as e: 
            if not hush: raise e
            return module
        except (RuntimeError, NameError) as e:
            return module
    
    if mount and notnone(module): 
        try:
            if in_sys(full): sys.modules.setdefault(full, module)
            else: sys.modules[full] = module
        except RuntimeError as e: 
            if not hush: raise e
            
    return module

# %% ../nbs/00_core.ipynb 40
@overload
def load_module_attr(attr: str, **kwargs: LoadModuleKeywords) -> ModuleType | Any | None: ...
@overload
def load_module_attr(path: str, **kwargs: LoadModuleAttributeKeywords) -> ModuleType | Any | None: ...
@overload
def load_module_attr(module: ModuleType, attr: str, **kwargs: LoadModuleKeywords) -> ModuleType | Any | None: ...
@overload
def load_module_attr(module: ModuleType, attr: str, default: Any, **kwargs: LoadModuleKeywords) -> ModuleType | Any | None: ...
@overload
def load_module_attr(
    path: str | None = None,
    spec: ModuleSpec | None = None,
    module: ModuleType | None = None,
    loader: Loader | None = None,
    hush: bool = True,
    do_exec: bool = True,
    mount: bool = True,
    package: str | None = None,
    attr : str | None = None,
    default = None
) -> ModuleType | Any | None: ...
@overload
def load_module_attr(
    attr: str, default: Any | None, module: ModuleType | None, 
    **kwargs: LoadModuleKeywords
) -> ModuleType | Any | None: ...
@overload
def load_module_attr(
    path: str, attr: str, default: Any | None,
    **kwargs: LoadModuleKeywords
) -> ModuleType | Any | None: ...
def load_module_attr(
    attr: str, default: Any | None = None, 
    hush: bool = True, **kwargs: LoadModuleKeywords
) -> ModuleType | Any | None:
    '''Load a specific attribute from a dynamically loaded module.
    
    This function wraps `load_module`, adding functionality to retrieve a specific attribute
    from the loaded module.
    
    Parameters
    ----------
    path : str, optional
        The string representation of the module to load
        
    spec : ModuleSpec, optional
        The `ModuleSpec` used to load the module. If not provided
        retrieved from `find_spec`.
        
    module : ModuleType, optional
        The `ModuleType` to load. If not provided created from
        `module_from_spec`.
        
    loader : Loader, optional
        The `Loader` used to load the module. If not provided, 
        retrieved from `spec.loader`.
        
    hush : bool, default: True
        Whether or not to silence errors.
        
    do_exec: bool, default: True
        Whether or not to execute the `module` via the `loader` i.e.
        `loader.exec_module(module)`.
        
    mount : bool, default: False
        Whether or not to mount the module in `sys.modules`.
        
    package : str, optional
        Required when performing a relative import. `package` specifies the 
        package to use as the anchor point from which to resolve the relative 
        import to an absolute import.
        
    attr : str, optional
        The attribute to retrieve from the loaded module. If `None`, returns the
        module instead.
        
    default : Any, optional
        The default value to return if attr is not `None` but does not exist in `module`.
    '''
    load_kwds = LoadModuleKeywords.filter(hush=hush, **kwargs)
    getmodule = partial(load_module, **load_kwds)
    
    def getter() -> ModuleType | Any | None:
        if isnone(attr): return getmodule()
        return getattr(getmodule(), attr, default)
    
    if not hush: return getter()
    with redirect_stderr(io.StringIO()), redirect_stdout(io.StringIO()): return getter()

# %% ../nbs/00_core.ipynb 43
def load_module_attrs(path: str, **kwargs: LoadModuleAttributesKeywords) -> dict[str, ModuleType | Any | None]:
    modules = dict()
    
    parts = _dot(path).split(DOT)
    
    kwds = LoadModuleAttributesKeywords.filter(**kwargs)
    
    attrs = kwds.pop('attrs', None)
    if isnone(attrs): 
        if len(parts) > 1: attrs = (parts[-1], )
        if len(parts) == 1: attrs = ()
    
    defs = list(kwds.pop('defaults', ()))
    defs = tuple(defs + [None] * (len(attrs) - len(defs)))
    
    for i, part in enumerate(parts):
        old = _dot(*parts[:i])
        cur = _dot(*parts[:i + 1])
        nxt = _dot(*parts[:i + 2])
        
        # print('old', old, 'cur', cur, 'nxt', nxt, sep='\t')
        prev = modules.get(old, None)
        spec = getspec(prev)
        
        # print(f'\tcalling `load_module(path={cur})`')
        # sub = load_module(path=cur, **kwds)
        sub = load_module(path=cur, module=prev, spec=spec, **kwds)
        # print('\tcur', cur, '\t', 'sub', sub, )
        # print('\tprev', prev, '\t', 'spec', spec, )
        modules[cur] = sub
        
        # only on part e.g. `pandas`
        if len(parts) == 1: break 
        
        # not yet at the end of the module subparts
        # if cur != nxt: continue 
        # val = load_module_attr(attr=part, path=old, module=prev, spec=spec)
        # if notnone(val): 
        #     modules[cur] = val
        #     continue
    
    # If the use provided additional attributes
    if notnone(attrs):
        path = cur if len(parts) == 1 else old
        prev = modules.get(path, None)
        spec = getspec(prev)
        # print(path, spec, prev)
        for i, attr in enumerate(attrs):
            key = _dot(path, attr)
            if in_sys(key): continue
            # print(i, attr, key, path, key in modules)
            val = load_module_attr(attr=attr, path=path, module=prev, spec=spec, default=defs[i])
            modules[key] = val
        
    return modules

# %% ../nbs/00_core.ipynb 45
class mount:
    '''
    A class for dynamically loading Python modules and retrieving module attributes. 
    It facilitates the handling of import paths, module loading, and attribute access 
    through a streamlined interface.

    Parameters
    ----------
    item : str
        The import path of the module or attribute to be loaded. Can include both
        the module path and the attribute name separated by dots.
    
    *attrs : str
        Additional strings to be concatenated to the `item` path, allowing dynamic
        path construction.
    
    **kwargs : LoadModuleAttributeKeywords
        Keyword arguments to filter through `LoadModuleAttributeKeywords` for additional 
        configuration during module or attribute loading.

    Attributes
    ----------
    item : str
        The full import path derived from the `item` and `*attrs` parameters.
        
    kwds : LoadModuleAttributeKeywords
        A dictionary of keyword arguments filtered for relevance to module or attribute
        loading operations.

    Methods
    -------
    - __init__(self, item: str, *attrs, **kwargs): Initializes the `mount` instance.
    - safe(cls, v: str | Any) -> str: Class method to safely convert a value to a string.
    - join(cls, *attrs, **kwargs) -> 'mount': Class method to create a `mount` instance
      by joining given attributes.
    - __repr__(self): Represents the `mount` instance as a string.
    - __len__(self): Returns the number of parts in the import path.
    - __str__(self): Returns the full import path as a string.
    - __iter__(self): Allows iteration over the parts of the import path.
    - __getitem__(self, idx): Enables index-based access to parts of the import path.
    - getmodule(self, hush: bool = True, **kwargs): Loads the module indicated by the path.
    - getattr(self, hush: bool = True, **kwargs): Retrieves a specified attribute from the
      loaded module.
    - getattrs(self, hush: bool = True, **kwargs): Retrieves specified attributes from the
      loaded module.
    - load(self, __key: str | bool | None = None, **kwargs): Loads the module or attribute
      and optionally returns a specific part of the result.
    - __call__(self, **kwargs): Shortcut to `load` method, loading the module or attribute.

    Properties
    ----------
    - parts: The parts of the import path as a tuple.
    - default: The default value to use when loading an attribute fails.
    - first: The first part of the import path.
    - rest: The remaining parts of the import path after the first.
    - most: All but the last part of the import path.
    - last: The last part of the import path.
    - solo: Indicates if the path represents a single module without submodules.
    - is_module: Determines if the path represents a module.
    - path: The full path to the last submodule.
    - attr: The name of the attribute to load from the module, if applicable.
    - submodules: The submodules within the import path.
    - insys: Checks if the module's path is present in `sys.modules`.
    - subpackage: Tuple containing the submodule name and package.

    Examples
    --------
    >>> mnt = mount('pandas')
    >>> mnt.path, mnt.first, mnt.rest, mnt.most, mnt.last, mnt.submodules, mnt.subpackage
    ('pandas', 'pandas', (), (), 'pandas', (), ('', 'pandas'))
    
    >>> mnt = mount('sklearn.metrics.pairwise')
    >>> mnt.path, mnt.first, mnt.rest, mnt.most, mnt.last
    ('sklearn.metrics', 'sklearn', ('metrics', 'pairwise'), ('sklearn', 'metrics'), 'pairwise')
    
    >>> mnt.submodules, mnt.subpackage
    (('metrics', 'pairwise'), ('sklearn.metrics', 'pairwise'))

    >>> mnt = mount('math.nan')
    >>> mnt()
    nan
    
    >>> mnt = mount('pandas')
    >>> mnt()
    <module 'pandas' from '...'>

    >>> mnt = mount('pandas.NA')
    >>> mnt()
    <NA>
    
    >>> mnt = mount('sklearn.metrics.pairwise')
    >>> mnt()
    <module 'sklearn.metrics.pairwise' from '...'>
    
    >>> mnt.load()
    {
        'sklearn': <module 'sklearn' from '...'>,
        'sklearn.metrics': <module 'sklearn.metrics' from '...'>,
        'sklearn.metrics.pairwise': <module 'sklearn.metrics.pairwise' from '...'>
    }
    
    See Also
    --------
    _dot : join strings via the dot character i.e. `'.'`.
    _str : safely initalize a string, where Falsey values return the nil string instead `''`.
    '''
    def __init__(self, item: str, *attrs, **kwargs):
        self.item = _dot(item, *attrs)
        self.kwds = LoadModuleAttributeKeywords.filter(**kwargs)
    
    @classmethod
    def safe(cls, v: str | Any) -> str: return _str(v)
    @classmethod
    def join(cls, *attrs, **kwargs) -> 'mount': return cls(_dot(*attrs), **kwargs)
    @property
    def parts(self) -> tuple[str, ...]:
        '''The parts of the item to mount as separated by the dot character i.e. `'.'`.'''
        return self.item.split(DOT)
    @property
    def default(self) -> Any | None: 
        '''The default value to use when trying to load an attribute and it fails.'''
        return self.kwds.get('default', None)
    
    def __repr__(self): 
        return f'''mount({self.item}, sys['{self.first}']={self.insys})'''
        
    def __len__(self): return len(self.parts)
    def __str__(self): return self.item
    def __iter__(self): return iter(self.parts)
    def __getitem__(self, idx) -> str: return self.parts[idx]
    
    @property
    def first(self) -> str:
        '''self[0]'''
        return self.parts[0]
    @property
    def rest(self) -> tuple[str, ...]:
        '''self[1:]'''
        return tuple(self.parts[1:])
    @property
    def most(self) -> tuple[str, ...]:
        '''self[:-1]'''
        return tuple(self.parts[:-1])
    @property
    def last(self) -> str: 
        '''self[-1]'''
        return self.parts[-1]
    
    @property
    def solo(self) -> bool:
        '''Whether the item doesn't have more than one attribute 
        i.e. the last attribute is the same as it's first.'''
        return DOT not in self.item or self.most == NIL and self.first == self.last
    
    @property
    def is_module(self):
        '''Whether the asset is a module or has submodules.'''
        return self.solo or DOT not in self.item
    
    @property
    def path(self) -> str: 
        '''Full path to the `last` submodule.'''
        return self.item if self.is_module else _dot(*self.most)
    
    @property
    def attr(self) -> str | None:
        '''The attribute name from the module to load if it exists, otherwise `None`.'''
        return (None if self.solo else self.last) 
    
    @property
    def submodules(self) -> tuple[str, ...]:
        '''The submodules of self i.e. self.rest '''
        return tuple(filter(str, self.rest))
    
    @property
    def insys(self) -> bool:
        '''Whether or not self.path is in `sys.modules`.'''
        return in_sys(self.path)
    
    @property
    def subpackage(self) -> tuple[str, str]:
        '''Tuple of the submodule name and package i.e. `(path.to.sub.module, package)`.'''
        return (_dot(*self.most), self.last)
    
    def getmodule(self, hush: bool = True, **kwargs: LoadModuleKeywords) -> ModuleType | None:
        '''Load the module indicated by path.'''
        kwds = dict(self.kwds)
        kwds.update(hush = hush, **kwargs)
        return load_module(path=self.path, **kwds)
        
    def getattr(self, hush: bool = True, **kwargs: LoadModuleKeywords) -> ModuleType | Any | None:
        '''Get the designated attribute from the loaded module, where attr is
        the last part of the asset's name i.e. `getattr(<module sub.module>, package, default)`.
        '''
        kwds = dict(self.kwds)
        kwds.setdefault('attr', self.attr)
        kwds.setdefault('default', self.default)
        kwds.update(hush=hush, **kwargs)
        return load_module_attr(path = self.path, **kwds)
    
    def getattrs(self, hush: bool = True, **kwargs: LoadModuleKeywords) -> ModuleType | Any | None:
        '''Get the designated attribute from the loaded module, where attr is
        the last part of the asset's name i.e. `getattr(<module sub.module>, package, default)`.
        '''
        kwds = dict(self.kwds)
        kwds.update(hush=hush, **kwargs)
        return load_module_attrs(path = self.item, **kwds)
        
    @overload
    def load(self, **kwargs: LoadModuleAttributesKeywords) -> dict[str, ModuleType | Any | None]: ...
    @overload
    def load(self, *, __return: str | bool | None = None, **kwargs: LoadModuleAttributesKeywords) -> ModuleType | Any | None: ...
    @overload
    def load(self,  __key: str | bool | None = None, /,  **kwargs: LoadModuleAttributesKeywords) -> ModuleType | Any | None: ...
    @overload
    def load(self, **kwargs: LoadModuleAttributesKeywords) -> Union[ModuleType | Any | None,  dict[str, ModuleType | Any | None]]: ...
    def load(
        self, __key: str | bool | None = None, /, **kwargs: LoadModuleAttributesKeywords
    ) -> Union[ModuleType | Any | None,  dict[str, ModuleType | Any | None]]:
        '''Load the module / attribute.'''
        __key = kwargs.pop('__return', __key)
        results = self.getattrs(**kwargs)
        if isnone(__key): return results
        if __key in results: return results.get(__key)
        return results.get(self.item)
    
    def __call__(self, **kwargs: LoadModuleAttributesKeywords) -> ModuleType | Any | None:
        '''Load the module / attribute.'''
        return self.load(__return=self.item, **kwargs)
