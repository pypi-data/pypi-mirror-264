#run with python -m unittest test.test_baccoemu
import unittest
import baccoemu
import numpy as np
import copy

emu = baccoemu.Matter_powerspectrum()
lbias_emu = baccoemu.Lbias_expansion()

kk = np.logspace(-2, 0.6, 10)
k_lbias = np.logspace(-2, np.log10(0.7), 10)

params = {
    'omega_matter'  :  0.315,
    'A_s'           :  2e-9,
    'omega_baryon'  :  0.05,
    'ns'            :  0.96,
    'hubble'        :  0.67,
    'neutrino_mass' :  0.1,
    'w0'            : -1.1,
    'wa'            :  0.2,
    'expfactor'     :  0.8,

    'M_c'           :  14,
    'eta'           : -0.3,
    'beta'          : -0.22,
    'M1_z0_cen'     : 10.5,
    'theta_out'     : 0.25,
    'theta_inn'     : -0.86,
    'M_inn'         : 13.4
}

params_sigma8 = copy.deepcopy(params)
del params_sigma8['A_s']
params_sigma8['sigma8_cold'] = 0.78

params_vec = copy.deepcopy(params)
for key in params_vec:
    params_vec[key] = np.full(3, params_vec[key])

params_sigma8_vec = copy.deepcopy(params_sigma8)
for key in params_sigma8_vec:
    params_sigma8_vec[key] = np.full(3, params_sigma8_vec[key])

dec_prec = 4
dec_prec_vec = 4

class test_baccoemu(unittest.TestCase):
    def test_get_nonlinear_boost(self):
        k, Q = emu.get_nonlinear_boost(k=kk, **params)
        k, Q_vec = emu.get_nonlinear_boost(k=kk, **params_vec)
        Q_tab = np.array([1., 0.99590761, 0.99121246, 0.98290575, 1.03702336,
                          1.33282697, 2.278292, 5.05824684, 11.3084095, 20.30722402])
        for i, j in zip(Q, Q_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(Q_vec[0], Q_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_baryonic_boost(self):
        k, S = emu.get_baryonic_boost(k=kk, **params)
        k, S_vec = emu.get_baryonic_boost(k=kk, **params_vec)
        S_tab = np.array([1., 0.99987408, 0.99823301, 0.99842851, 0.99661524,
                          0.99048668, 0.97008812, 0.93416284, 0.88753495, 0.83362897])
        for i, j in zip(S, S_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(S_vec[0], S_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_linear_pk(self):
        k, pk = emu.get_linear_pk(k=kk, cold=True,**params)
        k, pk_vec = emu.get_linear_pk(k=kk, cold=True,**params_vec)
        pk_tab = np.array([1.62854202e+04, 1.77584272e+04, 1.16049010e+04, 6.59140263e+03,
                           2.49394757e+03, 7.38743943e+02, 1.88090420e+02, 4.23532034e+01,
                           8.68574677e+00, 1.66160033e+00])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

        k, pk = emu.get_linear_pk(k=kk, cold=False, **params)
        k, pk_vec = emu.get_linear_pk(k=kk, cold=False, **params_vec)
        pk_tab = np.array([1.61550167e+04, 1.75643864e+04, 1.14536956e+04, 6.48821102e+03,
                           2.45236575e+03, 7.26781531e+02, 1.85054654e+02, 4.16805981e+01,
                           8.54843543e+00, 1.63536007e+00])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_no_wiggles_pk(self):
        k, pk = emu.get_no_wiggles_pk(k=kk, **params)
        k, pk_vec = emu.get_no_wiggles_pk(k=kk, **params_vec)
        pk_tab = np.array([1.51897503e+04, 1.65266487e+04, 1.22728098e+04, 6.15643967e+03,
                           2.39506902e+03, 7.34150779e+02, 1.88040439e+02, 4.23532034e+01,
                           8.68574677e+00, 1.66160033e+00])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_nonlinear_pk(self):
        k, pk = emu.get_nonlinear_pk(k=kk, baryonic_boost=True, **params)
        k, pk_vec = emu.get_nonlinear_pk(k=kk, baryonic_boost=True, **params_vec)
        pk_tab = np.array([16285.42024, 17683.5257821, 11482.59689214, 6468.54627449,
                           2577.52792877, 975.25087152, 415.706914  , 200.12846733,
                           87.17544124, 28.12871718])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_sigma8(self):
        sigma8 = emu.get_sigma8(**params)
        sigma8_vec = emu.get_sigma8(**params_vec)
        self.assertAlmostEqual(np.round(sigma8 / 0.78652451, dec_prec), 1)
        self.assertAlmostEqual(np.round(sigma8_vec[0] / 0.78652451, dec_prec), 1)

    def test_get_sigma12(self):
        sigma12 = emu.get_sigma12(**params)
        sigma12_vec = emu.get_sigma12(**params_vec)
        self.assertAlmostEqual(np.round(sigma12 / 0.78323520, dec_prec), 1)
        self.assertAlmostEqual(np.round(sigma12_vec[0] / 0.78323520, dec_prec), 1)

    def test_get_linear_pk_sigma8(self):
        k, pk = emu.get_linear_pk(k=kk, cold=True, **params_sigma8)
        k, pk_vec = emu.get_linear_pk(k=kk, cold=True, **params_sigma8_vec)
        pk_tab = np.array([1.60163538e+04, 1.74650239e+04, 1.14131658e+04, 6.48250000e+03,
                           2.45274276e+03, 7.26538474e+02, 1.84982805e+02, 4.16534471e+01,
                           8.54224155e+00, 1.63414750e+00])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

        k, pk = emu.get_linear_pk(k=kk, cold=False, **params_sigma8)
        k, pk_vec = emu.get_linear_pk(k=kk, cold=False, **params_sigma8_vec)
        pk_tab = np.array([1.58881048e+04, 1.72741890e+04, 1.12644586e+04, 6.38101332e+03,
                           2.41184796e+03, 7.14773705e+02, 1.81997196e+02, 4.09919545e+01,
                           8.40719885e+00, 1.60834078e+00])
        for i, j in zip(pk, pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for i, j in zip(pk_vec[0], pk_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

    def test_get_lpt_pk(self):
        k, pk = lbias_emu.get_lpt_pk(k=k_lbias, **params)
        k, pk_vec = lbias_emu.get_lpt_pk(k=k_lbias, **params_vec)

        pk_tab = np.array([[ 1.63348403e+04,  1.80863642e+04,  1.60351504e+04,
         1.07565770e+04,  7.48276912e+03,  3.96764583e+03,
         2.30246901e+03,  1.48304388e+03,  1.04685987e+03,
         7.36131890e+02],
       [ 1.63287094e+04,  1.81047719e+04,  1.60241328e+04,
         1.07603389e+04,  7.51605453e+03,  4.04162474e+03,
         2.41864873e+03,  1.63092957e+03,  1.20302374e+03,
         8.98641306e+02],
       [ 6.67143251e-01,  9.19713234e+00,  4.34139543e+01,
         1.25943084e+02,  2.71789923e+02,  4.69384256e+02,
         6.00429121e+02,  6.05058025e+02,  4.98619776e+02,
         4.04954903e+02],
       [-2.85811341e+00, -6.84447088e+00, -1.90887589e+01,
        -4.07585300e+01, -6.96375666e+01, -9.25344979e+01,
        -9.35671424e+01, -7.37828216e+01, -4.38339995e+01,
         4.06179869e+00],
       [-1.79401861e+00, -4.75402959e+00, -1.06652995e+01,
        -1.81809618e+01, -3.17463866e+01, -4.02933388e+01,
        -4.98134851e+01, -5.72058919e+01, -5.65344758e+01,
        -5.31136255e+01],
       [ 1.63033453e+04,  1.80633953e+04,  1.60021255e+04,
         1.07285396e+04,  7.45779896e+03,  3.88454890e+03,
         2.14750118e+03,  1.25386150e+03,  7.70702179e+02,
         4.91088012e+02],
       [ 2.21614242e+01,  5.80447298e+01,  1.43133629e+02,
         3.02042322e+02,  5.39551920e+02,  8.02047871e+02,
         9.41088476e+02,  8.92734681e+02,  6.98386253e+02,
         4.93786250e+02],
       [ 8.59852234e+00,  1.22408947e+01,  7.80467322e+00,
        -1.08033159e+01, -4.75066584e+01, -8.79798726e+01,
        -1.05319076e+02, -9.37427928e+01, -6.60581538e+01,
        -1.33756830e+01],
       [-1.83428987e+00, -4.72259495e+00, -1.06174104e+01,
        -1.81704541e+01, -3.18319745e+01, -4.03205765e+01,
        -4.99428695e+01, -5.72898913e+01, -5.66146091e+01,
        -5.30964953e+01],
       [ 3.99186542e+03,  3.96854199e+03,  3.92295327e+03,
         3.81155946e+03,  3.58447130e+03,  3.15781770e+03,
         2.52431689e+03,  1.77132288e+03,  1.03464793e+03,
         3.86378007e+02],
       [ 2.58727807e+03,  2.47440395e+03,  2.26229211e+03,
         1.92223602e+03,  1.44759750e+03,  9.41815177e+02,
         4.96126129e+02,  1.82190933e+02,  9.93406221e-01,
        -4.81347412e+01],
       [-5.44347928e-02,  1.29889979e-01,  4.21232485e-01,
         8.33282770e-01,  1.58432767e+00,  2.17508832e+00,
         1.10403212e+00, -4.91403238e+00, -2.42109962e+01,
        -1.09013109e+02],
       [ 1.68128965e+03,  1.58063260e+03,  1.41258443e+03,
         1.17309547e+03,  8.86534824e+02,  6.07578789e+02,
         3.69526140e+02,  1.91748614e+02,  7.89115927e+01,
         3.06354629e+01],
       [ 4.41467179e-02,  1.14669602e-01,  2.96499181e-01,
         7.62526523e-01,  1.89791424e+00,  4.43078666e+00,
         9.13112800e+00,  1.60043149e+01,  2.13143636e+01,
         4.63480125e+00],
       [ 1.78464868e-04,  1.29632995e-03,  7.65516519e-03,
         3.52477038e-02,  1.69128576e-01,  6.53857456e-01,
         2.76849596e+00,  1.26865797e+01,  6.12345088e+01,
         2.43612463e+02]])

        for n in range(15):
            for i, j in zip(pk[n], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for n in range(15):
            for i, j in zip(pk_vec[n][0], pk_tab[n]):
                print(i / j)
                self.assertAlmostEqual(np.round(i / j, dec_prec_vec), 1)

    def test_get_lpt_pk_sigma8(self):
        k, pk = lbias_emu.get_lpt_pk(k=k_lbias, **params_sigma8)
        k, pk_vec = lbias_emu.get_lpt_pk(k=k_lbias, **params_sigma8_vec)
        pk_tab = np.array([[ 1.60628965e+04,  1.77839139e+04,  1.57662380e+04,
         1.05748657e+04,  7.35449358e+03,  3.89526072e+03,
         2.25479323e+03,  1.44687843e+03,  1.01711707e+03,
         7.13447280e+02],
       [ 1.60545921e+04,  1.77991374e+04,  1.57534490e+04,
         1.05790200e+04,  7.38603720e+03,  3.96690479e+03,
         2.36752930e+03,  1.59013725e+03,  1.16819942e+03,
         8.70750586e+02],
       [ 6.45381425e-01,  8.89555208e+00,  4.19946517e+01,
         1.21841527e+02,  2.62968402e+02,  4.54151658e+02,
         5.80944225e+02,  5.85447482e+02,  4.82496767e+02,
         3.91812333e+02],
       [-2.73641913e+00, -6.58574496e+00, -1.83896277e+01,
        -3.92846612e+01, -6.72530945e+01, -8.94145949e+01,
        -9.03737547e+01, -7.11859171e+01, -4.22416934e+01,
         3.90436515e+00],
       [-1.76304284e+00, -4.67503968e+00, -1.04864649e+01,
        -1.78763159e+01, -3.12127578e+01, -3.96107614e+01,
        -4.89547737e+01, -5.61839254e+01, -5.55426641e+01,
        -5.21986981e+01],
       [ 1.60254830e+04,  1.77619190e+04,  1.57372962e+04,
         1.05483167e+04,  7.32943776e+03,  3.81421357e+03,
         2.10452386e+03,  1.22494385e+03,  7.50001814e+02,
         4.76616938e+02],
       [ 2.14512791e+01,  5.61517922e+01,  1.38483151e+02,
         2.92135126e+02,  5.21994076e+02,  7.75828103e+02,
         9.10332373e+02,  8.63615936e+02,  6.75487813e+02,
         4.77648126e+02],
       [ 8.30708858e+00,  1.18425780e+01,  7.57384018e+00,
        -1.04352659e+01, -4.59141640e+01, -8.50928528e+01,
        -1.01914282e+02, -9.07343796e+01, -6.39219537e+01,
        -1.29461143e+01],
       [-1.80198811e+00, -4.64172163e+00, -1.04407659e+01,
        -1.78657223e+01, -3.12924260e+01, -3.96452488e+01,
        -4.91165793e+01, -5.63193290e+01, -5.56511543e+01,
        -5.21767292e+01],
       [ 3.86255041e+03,  3.83909690e+03,  3.79486928e+03,
         3.68724585e+03,  3.46785168e+03,  3.05457424e+03,
         2.44200699e+03,  1.71354806e+03,  1.00094201e+03,
         3.73755265e+02],
       [ 2.50348479e+03,  2.39449073e+03,  2.18940389e+03,
         1.86041763e+03,  1.40106957e+03,  9.11593542e+02,
         4.80166598e+02,  1.76187601e+02,  7.82991239e-01,
        -4.65349660e+01],
       [-5.36362344e-02,  1.23542378e-01,  4.10033014e-01,
         8.06859197e-01,  1.53212346e+00,  2.09964623e+00,
         1.05480531e+00, -4.77093817e+00, -2.34356987e+01,
        -1.05759302e+02],
       [ 1.62649524e+03,  1.52865644e+03,  1.36620948e+03,
         1.13470493e+03,  8.57489837e+02,  5.87765973e+02,
         3.57482764e+02,  1.85499737e+02,  7.63418524e+01,
         2.96435352e+01],
       [ 4.25993114e-02,  1.10773027e-01,  2.86460952e-01,
         7.36929766e-01,  1.83449817e+00,  4.28353841e+00,
         8.83001054e+00,  1.54769169e+01,  2.06127068e+01,
         4.49490440e+00],
       [ 1.75198879e-04,  1.27283211e-03,  7.51569237e-03,
         3.45820200e-02,  1.65792224e-01,  6.39604896e-01,
         2.70058548e+00,  1.23372505e+01,  5.93882883e+01,
         2.35973731e+02]])

        for n in range(15):
            for i, j in zip(pk[n], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for n in range(15):
            for i, j in zip(pk_vec[n][0], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec_vec), 1)

    def test_get_nonlinear_pnn(self):
        k, pk = lbias_emu.get_nonlinear_pnn(k=k_lbias, **params)
        k, pk_vec = lbias_emu.get_nonlinear_pnn(k=k_lbias, **params_vec)
        pk_tab = np.array([[ 1.62722909e+04,  1.80049033e+04,  1.58755152e+04,
         1.05543910e+04,  7.14789667e+03,  3.66917914e+03,
         1.91930167e+03,  1.00706180e+03,  5.44676186e+02,
         3.21801752e+02],
       [ 1.62883242e+04,  1.79524704e+04,  1.58375656e+04,
         1.05688954e+04,  7.23655938e+03,  3.82853677e+03,
         2.11136406e+03,  1.18652864e+03,  7.00623372e+02,
         4.41665697e+02],
       [ 6.62382842e-01,  9.19570896e+00,  4.34132870e+01,
         1.25963682e+02,  2.71806276e+02,  4.42563590e+02,
         5.15376165e+02,  5.49490777e+02,  5.13747959e+02,
         4.50133502e+02],
       [-2.78582071e+00, -6.83971171e+00, -1.90872030e+01,
        -4.06428898e+01, -6.98005352e+01, -8.39213626e+01,
        -7.16648705e+01, -6.02968825e+01, -4.20201785e+01,
        -2.33460149e+01],
       [-1.42670360e+00, -5.22291251e+00, -1.21763689e+01,
        -2.09523400e+01, -3.57864197e+01, -4.52684723e+01,
        -5.49072219e+01, -5.96297424e+01, -5.67560867e+01,
        -4.17062354e+01],
       [ 1.62529167e+04,  1.79136064e+04,  1.58228928e+04,
         1.06260371e+04,  7.38653002e+03,  4.07209745e+03,
         2.38618526e+03,  1.45639658e+03,  9.50724121e+02,
         6.65469758e+02],
       [ 2.21664122e+01,  5.80406001e+01,  1.43132362e+02,
         3.02027424e+02,  5.39466138e+02,  7.75869361e+02,
         8.71561130e+02,  8.92415729e+02,  8.34584589e+02,
         7.44533417e+02],
       [ 8.23569672e+00,  1.23382936e+01,  7.75303771e+00,
        -1.08118145e+01, -4.71879050e+01, -8.11642561e+01,
        -9.13946172e+01, -8.42552237e+01, -6.54738415e+01,
        -3.66846309e+01],
       [-1.05039778e+00, -5.24851022e+00, -1.21779633e+01,
        -2.13424403e+01, -3.67783012e+01, -4.76900404e+01,
        -6.00918969e+01, -6.92190000e+01, -7.09781233e+01,
        -5.99512941e+01],
       [ 3.99055374e+03,  3.96844417e+03,  3.92317485e+03,
         3.81159713e+03,  3.58362078e+03,  3.09059619e+03,
         2.47587893e+03,  1.90500687e+03,  1.43706028e+03,
         1.14867004e+03],
       [ 2.59035859e+03,  2.47492362e+03,  2.26285329e+03,
         1.92163913e+03,  1.44740176e+03,  9.28916789e+02,
         4.86866838e+02,  1.97244180e+02,  3.78334874e+01,
        -7.64508247e+00],
       [-5.84433010e-02,  1.32331907e-01,  4.11015319e-01,
         8.42898365e-01,  1.59854502e+00,  2.16065233e+00,
         1.33359832e+00, -2.88598295e+00, -2.02478212e+01,
        -4.55250270e+01],
       [ 1.68107938e+03,  1.58064952e+03,  1.41258691e+03,
         1.17316104e+03,  8.86622023e+02,  5.87481580e+02,
         3.49648375e+02,  1.85768630e+02,  8.88830501e+01,
         4.49065534e+01],
       [ 4.41915905e-02,  1.14547941e-01,  2.96583192e-01,
         7.61794140e-01,  1.89823341e+00,  4.51404628e+00,
         8.68402865e+00,  1.29349097e+01,  1.23821464e+01,
         5.76753617e+00],
       [ 7.16310878e-05,  1.81123431e-03,  1.08760284e-02,
         4.93826573e-02,  2.14458985e-01,  7.19196888e-01,
         2.24609785e+00,  5.89197425e+00,  1.10521017e+01,
         9.62549816e+00]])

        for n in range(15):
            for i, j in zip(pk[n], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for n in range(15):
            for i, j in zip(pk_vec[n][0], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec_vec), 1)

    def test_get_nonlinear_pnn_sigma8(self):
        k, pk = lbias_emu.get_nonlinear_pnn(k=k_lbias, **params_sigma8)
        k, pk_vec = lbias_emu.get_nonlinear_pnn(k=k_lbias, **params_sigma8_vec)
        pk_tab = np.array([[ 1.60047134e+04,  1.77076121e+04,  1.56135043e+04,
         1.03804503e+04,  7.03008008e+03,  3.60773828e+03,
         1.88558250e+03,  9.87332167e+02,  5.32855644e+02,
         3.14051833e+02],
       [ 1.60199834e+04,  1.76567437e+04,  1.55752374e+04,
         1.03928241e+04,  7.11503939e+03,  3.75861262e+03,
         2.07006776e+03,  1.16117902e+03,  6.83394836e+02,
         4.29190258e+02],
       [ 6.40712489e-01,  8.89414729e+00,  4.19938805e+01,
         1.21860928e+02,  2.62987528e+02,  4.25693049e+02,
         5.00480501e+02,  5.33086724e+02,  4.97852088e+02,
         4.35577952e+02],
       [-2.66923316e+00, -6.58072208e+00, -1.83872729e+01,
        -3.91723529e+01, -6.74017610e+01, -8.11630761e+01,
        -6.98140270e+01, -5.86155168e+01, -4.07366671e+01,
        -2.23903949e+01],
       [-1.49102701e+00, -5.14511347e+00, -1.20146802e+01,
        -2.06467407e+01, -3.52633202e+01, -4.45591128e+01,
        -5.40006368e+01, -5.85985070e+01, -5.56725559e+01,
        -4.09212710e+01],
       [ 1.59937140e+04,  1.76235263e+04,  1.55610005e+04,
         1.04455655e+04,  7.25709547e+03,  3.99661254e+03,
         2.33768242e+03,  1.42199745e+03,  9.24507931e+02,
         6.44422172e+02],
       [ 2.14609564e+01,  5.61479087e+01,  1.38482325e+02,
         2.92121565e+02,  5.21917517e+02,  7.50358022e+02,
         8.43541154e+02,  8.63809219e+02,  8.07091757e+02,
         7.19297987e+02],
       [ 7.95682107e+00,  1.19369284e+01,  7.52342990e+00,
        -1.04441900e+01, -4.56110552e+01, -7.84241472e+01,
        -8.84731067e+01, -8.16064582e+01, -6.33644142e+01,
        -3.53863358e+01],
       [-9.60577032e-01, -5.17041907e+00, -1.19943837e+01,
        -2.10332748e+01, -3.62548327e+01, -4.69981009e+01,
        -5.92131846e+01, -6.82228613e+01, -6.99297255e+01,
        -5.91621559e+01],
       [ 3.86129945e+03,  3.83900734e+03,  3.79509852e+03,
         3.68728268e+03,  3.46704890e+03,  2.98891370e+03,
         2.39528101e+03,  1.84227916e+03,  1.38777557e+03,
         1.10568139e+03],
       [ 2.50636167e+03,  2.39501910e+03,  2.18989397e+03,
         1.85984480e+03,  1.40085313e+03,  8.97369327e+02,
         4.70365959e+02,  1.90353367e+02,  3.59032437e+01,
        -8.05565442e+00],
       [-5.69482896e-02,  1.25974973e-01,  3.98616855e-01,
         8.16888781e-01,  1.54803238e+00,  2.09121860e+00,
         1.27615868e+00, -3.72436337e+00, -1.96325506e+01,
        -4.42000254e+01],
       [ 1.62627172e+03,  1.52867412e+03,  1.36621215e+03,
         1.13476621e+03,  8.57573836e+02,  5.68390775e+02,
         3.38321721e+02,  1.79609892e+02,  8.56969606e+01,
         4.30835703e+01],
       [ 4.26535727e-02,  1.10656233e-01,  2.86563210e-01,
         7.36075338e-01,  1.83503316e+00,  4.35962033e+00,
         8.40542219e+00,  1.25658079e+01,  1.20816627e+01,
         5.61698982e+00],
       [ 2.93997129e-04,  1.83371571e-03,  1.05746142e-02,
         4.82714178e-02,  2.09479809e-01,  7.01817625e-01,
         2.19255708e+00,  5.76370068e+00,  1.08827966e+01,
         9.52628591e+00]])

        for n in range(15):
            for i, j in zip(pk[n], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec), 1)
        for n in range(15):
            for i, j in zip(pk_vec[n][0], pk_tab[n]):
                self.assertAlmostEqual(np.round(i / j, dec_prec_vec), 1)

    def test_get_galaxy_real_pk(self):
        k, pgg, pgm = lbias_emu.get_galaxy_real_pk(k=k_lbias, bias=[0.2, 0.02, -0.02, 0.2], **params)
        pgg_tab = np.array([23437.52749951, 25901.17364443, 22841.52084439, 15206.52849924,
                            10339.7186542 ,  5370.20886112,  2864.48151203,  1543.53220011,
                            864.7661628 ,   529.25537471])
        pgm_tab = np.array([19529.73940259, 21594.67352594, 19041.84310334, 12667.31173365,
                            8594.88340034,  4436.36249983,  2342.33386124,  1244.63733005,
                            684.56500576,   411.26323479])

        for i, j in zip(pgg, pgg_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec), 1)

        for i, j in zip(pgm, pgm_tab):
            self.assertAlmostEqual(np.round(i / j, dec_prec_vec), 1)

if __name__ == '__main__':
    unittest.main()
