# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['T', 'S', 'P', 'R_co', 'detuple', 'mop', 'mop_op', 'reduce_op', 'reduce_eq', 'reduce_ne', 'reduce_gt', 'reduce_ge',
           'reduce_lt', 'reduce_le', 'reduce_pow', 'reduce_add', 'reduce_sub', 'reduce_mul', 'reduce_abs', 'reduce_is_',
           'reduce_is_not', 'reduce_concat', 'reduce_floordiv', 'reduce_min', 'reduce_max', 'map_op', 'map_eq',
           'map_ne', 'map_gt', 'map_ge', 'map_lt', 'map_le', 'map_pow', 'map_add', 'map_sub', 'map_mul', 'map_abs',
           'map_is_', 'map_is_not', 'map_concat', 'map_floordiv', 'map_min', 'map_max', 'method', 'identity',
           'identitymethod', 'instancemethod', 'zipr']

# %% ../nbs/00_core.ipynb 6
import sys, math, operator
from functools import wraps, partial, reduce, singledispatch
from itertools import takewhile, count, accumulate, repeat, zip_longest
from _collections_abc import dict_keys, dict_values, dict_items

# %% ../nbs/00_core.ipynb 8
from types import FunctionType, BuiltinFunctionType, SimpleNamespace
from typing import (TypeVar, ParamSpec, Generator, Iterable, Callable, Generic, Concatenate, Any, overload,)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
#| export


# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
T = TypeVar('T')
S = TypeVar('S')
P = ParamSpec('P')
R_co = TypeVar('R_co', covariant=True)

# %% ../nbs/00_core.ipynb 18
def detuple(arg: tuple | Any | None = None, /, *args: P.args):
    '''
    Flatten inputs by converting nested tuples, ranges, dict_keys, dict_values,
    dict_items, Generators, and Iterables into a single tuple. This function
    is recursive to handle deeply nested structures.
    
    Parameters
    ----------
    arg : tuple | Any | None, optional
        The first argument which may be a tuple or any other value. If it's a collection
        type, it will be detupled. Default is None.
        
    *args : P.args
        Additional arguments which are processed in the same manner as `arg`.
    
    Returns
    -------
    tuple
        A tuple of the detupled inputs.
    '''
    if isinstance(arg, (tuple, range, dict_keys, dict_values, dict_items, Generator, Iterable)): 
        return detuple(*tuple(arg))
    return (arg, *args)

def mop(op: Callable, /) -> Callable[P, Any]:
    '''
    Decorator to modify an operation (function) to automatically detuple its arguments
    before applying the operation. This allows the operation to be applied to nested
    tuple structures seamlessly.
    
    Parameters
    ----------
    op : Callable
        The operation to be modified. It should be a function that accepts any number
        of positional arguments.
    
    Returns
    -------
    Callable[P, Any]
        A wrapped version of the operation that detuples its arguments before applying
        the original operation.
    '''
    @wraps(op)
    def wop(*args: P.args, **kwargs: P.kwargs):
        return op(*detuple(*args), **kwargs)
    return wop

def mop_op(*its, op: Callable) -> map:
    '''
    Apply a modified operation (using `mop`) over pairs of elements from multiple
    iterables. This function is essentially a combination of `map` and `zip`,
    applying the operation to each pair of elements.
    
    Parameters
    ----------
    *its : iterable
        Iterables whose elements are to be paired and passed to the operation.
    op : Callable
        The operation to apply. It will be modified by `mop` to detuple its arguments.
    
    Returns
    -------
    map
        An iterator that yields the results of applying the modified operation to
        pairs of elements from the input iterables.
    '''
    return map(mop(op), zip(*its))

# %% ../nbs/00_core.ipynb 21
def reduce_op(op: BuiltinFunctionType) -> Callable[[tuple[T, ...]], S]:
    '''
    Decorator factory that takes a binary operation and returns a decorator.
    This decorator transforms a function into one that applies a reduction
    (fold) using the given operation over its arguments.
    
    Parameters
    ----------
    op : BuiltinFunctionType
        A binary operation, like those found in the `operator` module, that will be
        used to reduce the arguments.
    
    Returns
    -------
    Callable[[tuple[T, ...]], S]
        A decorator that, when applied to a function, transforms it into a reduction
        over its arguments using the specified operation.
        
    Examples
    --------
    >>> @reduce_op(operator.eq)
    ... def reduce_eq(*args): ...
    
    >>> @reduce_op(operator.add)
    ... def reduce_add(*args): ...
    '''
    def decorator(fn: FunctionType):
        @wraps(op, assigned=('__annotations__', '__doc__'))
        @wraps(fn, assigned=('__module__', '__name__', '__qualname__', '__type_params__'))
        def mapped(*args: T) -> S: return reduce(op, args)
        return mapped
    return decorator

# %% ../nbs/00_core.ipynb 22
@reduce_op(operator.eq)
def reduce_eq(*args): ...
@reduce_op(operator.ne)
def reduce_ne(*args): ...
@reduce_op(operator.gt)
def reduce_gt(*args): ...
@reduce_op(operator.ge)
def reduce_ge(*args): ...
@reduce_op(operator.lt)
def reduce_lt(*args): ...
@reduce_op(operator.le)
def reduce_le(*args): ...
@reduce_op(operator.pow)
def reduce_pow(*args): ...
@reduce_op(operator.add)
def reduce_add(*args): ...
@reduce_op(operator.sub)
def reduce_sub(*args): ...
@reduce_op(operator.mul)
def reduce_mul(*args): ...
@reduce_op(operator.abs)
def reduce_abs(*args): ...
@reduce_op(operator.is_)
def reduce_is_(*args): ...
@reduce_op(operator.is_not)
def reduce_is_not(*args): ...
@reduce_op(operator.concat)
def reduce_concat(*args): ...
@reduce_op(operator.floordiv)
def reduce_floordiv(*args): ...
@reduce_op(min)
def reduce_min(*args): ...
@reduce_op(max)
def reduce_max(*args): ...

# %% ../nbs/00_core.ipynb 24
def map_op(op: BuiltinFunctionType) -> Callable[[tuple[T, ...]], S]:
    '''
    Decorator factory that takes a binary operation and returns a decorator for
    functions that apply the operation over elements from multiple iterables in
    a map-like fashion.

    Parameters
    ----------
    op : BuiltinFunctionType
        A binary operation suitable for mapping over iterables.
    
    Returns
    -------
    Callable[[tuple[T, ...]], S]
        A decorator that, when applied to a function, allows it to map the specified
        operation over elements from the provided iterables.

    Examples
    --------
    >>> @map_op(reduce_eq)
    ... def map_eq(*args): ...
    
    >>> @map_op(reduce_add)
    ... def map_add(*args): ...
    '''
    def decorator(fn: FunctionType):
        @wraps(op, assigned=('__annotations__', '__doc__'))
        @wraps(fn, assigned=('__module__', '__name__', '__qualname__', '__type_params__'))
        def mapped(*its: T) -> map: return map(mop(op), zip(*its))
        return mapped
    return decorator

# %% ../nbs/00_core.ipynb 25
@map_op(reduce_eq)
def map_eq(*args): ...
@map_op(reduce_ne)
def map_ne(*args): ...
@map_op(reduce_gt)
def map_gt(*args): ...
@map_op(reduce_ge)
def map_ge(*args): ...
@map_op(reduce_lt)
def map_lt(*args): ...
@map_op(reduce_le)
def map_le(*args): ...
@map_op(reduce_pow)
def map_pow(*args): ...
@map_op(reduce_add)
def map_add(*args): ...
@map_op(reduce_sub)
def map_sub(*args): ...
@map_op(reduce_mul)
def map_mul(*args): ...
@map_op(reduce_abs)
def map_abs(*args): ...
@map_op(reduce_is_)
def map_is_(*args): ...
@map_op(reduce_is_not)
def map_is_not(*args): ...
@map_op(reduce_concat)
def map_concat(*args): ...
@map_op(reduce_floordiv)
def map_floordiv(*args): ...
@map_op(min)
def map_min(*args): ...
@map_op(max)
def map_max(*args): ...

# %% ../nbs/00_core.ipynb 28
class method(Generic[T, P, R_co]):
    __name__: str
    __qualname__: str
    def __init__(self, __f: Callable[Concatenate[type[T], P], R_co], *args, **kwargs) -> None:
        setattr(self, '__f', __f or self.__call__)

    def __call__(cls, *args: P.args, **kwargs: P.kwargs) -> R_co:
        return args, kwargs
    

def identity(*args: P.args, **kwargs: P.kwargs) -> R_co:
    return args, kwargs

class identitymethod(metaclass=method):
    ...
    
class instancemethod(method):
    '''Zipr class namespaced so instancemethods and classmethods work the same.'''
    def __init__(self, __f: Callable[Concatenate[type[T], P], R_co], *args, **kwargs) -> None:
        # print(__f, args, kwargs)
        setattr(self, '__f', __f)
        
    def __get__(self, __instance: T | None, __owner: type[T], *args, **kwargs) -> Callable[P, R_co]:
        # print('ins', __instance, 'owner', __owner, 'args', args, 'kwds', kwargs)
        ins = __instance
        cls = __owner
        fn = getattr(self, '__f', identitymethod)
        # print('function', fn, )
        @wraps(fn)
        def wrapper(arg1: T | Any | None = None, /, *args: P.args, **kwargs: P.kwargs) -> S:
            # print('wrapper', 'ins', ins, 'cls', cls, 'arg1', arg1, 'args', args, 'kwargs', kwargs)
            if arg1 is None and isinstance(ins, cls):
                inst = ins
                # print('if', arg1, ins)
            elif arg1 == cls:
                # print('elif', args)
                inst = cls(*args, **kwargs)
            else: 
                # print('else', (arg1, *args))
                inst = cls(arg1, *args, **kwargs)
            # print('returning', inst)
            # print(list(inst.zips))
            return fn(inst)
        
        return wrapper

# %% ../nbs/00_core.ipynb 31
class zipr:
    '''
    A utility class for iterating over multiple iterables in parallel (like `zip`)
    and applying operations (both mapped and reduced) over the iterated elements.
    
    Methods in this class can apply operations to pairs of elements from the iterables
    or reduce multiple elements using specified operations. This class supports a variety of 
    operations, including equality checks, arithmetic operations, and logical comparisons, applied across elements from multiple iterables.
    
    Parameters
    ----------
    *its : P.args
        Any number of iterables to be zipped together.
    
    Attributes
    ----------
    zips : zip
        The zipped iterator of the input iterables.
        
    Methods
    -------
    reduce(op)
        Class method that returns a decorator for reducing an iterable using the specified operation.
    map(op)
        Class method that returns a decorator for mapping an operation over elements from multiple iterables.
    eq, ne, gt, ge, lt, le, pow, add, sub, mul, abs, is_, is_not, concat, floordiv, min, max
        Instance methods that apply specific operations (equality, arithmetic, etc.) over zipped elements.
        
    Examples
    --------
    >>> a = (1,2,3)
    ... b = (1,3,4)
    ... c = (1,13,14)
    ... list(zipr.eq(a, b, c)), list(zipr.add(a, b, c)), list(zipr.min(a, b, c)), list(zipr.max(a, b, c))
    ([True, False, False], [3, 18, 21], [1, 2, 3], [1, 13, 14])
    
    >>> z = zipr(a, b, c)
    ... list(z.eq())
    [True, False, False]
    '''
    def __init__(self, *its: P.args):
        self._its = its
    
    @property
    def zips(self) -> zip: return zip(*self._its)
    def __iter__(self) -> zip: return self.zips
    def __next__(self): return next(iter(self))
    
    @classmethod
    @wraps(reduce_op)
    def reduce(cls, op): return reduce_op(op)
    @classmethod
    @wraps(map_op)
    def map(cls, op): return map_op(op)
    
    @wraps(map_eq)
    @instancemethod
    def eq(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_eq(ins)
    @wraps(map_ne)
    @instancemethod
    def ne(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_ne(ins)
    @wraps(map_gt)
    @instancemethod
    def gt(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_gt(ins)
    @wraps(map_ge)
    @instancemethod
    def ge(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_ge(ins)
    @wraps(map_lt)
    @instancemethod
    def lt(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_lt(ins)
    @wraps(map_le)
    @instancemethod
    def le(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_le(ins)
    @wraps(map_pow)
    @instancemethod
    def pow(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_pow(ins)
    @wraps(map_add)
    @instancemethod
    def add(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_add(ins)
    @wraps(map_sub)
    @instancemethod
    def sub(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_sub(ins)
    @wraps(map_mul)
    @instancemethod
    def mul(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_mul(ins)
    @wraps(map_abs)
    @instancemethod
    def abs(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_abs(ins)
    @wraps(map_is_)
    @instancemethod
    def is_(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_is_(ins)
    @wraps(map_is_not)
    @instancemethod
    def is_not(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_is_not(ins)
    @wraps(map_concat)
    @instancemethod
    def concat(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_concat(ins)
    @wraps(map_floordiv)
    @instancemethod
    def floordiv(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_floordiv(ins)
    @wraps(map_min)
    @instancemethod
    def min(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_min(ins)
    @wraps(map_max)
    @instancemethod
    def max(ins: T, /, *args: P.args, **kwargs: P.kwargs) -> S: return map_max(ins)
