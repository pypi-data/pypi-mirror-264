# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: services/connect/v1/connect.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common import v1 as __common_v1__
from ...universalwallet import v1 as __universalwallet_v1__


if TYPE_CHECKING:
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class VerificationType(betterproto.Enum):
    """The type of verification to perform"""

    GOVERNMENT_ID = 0
    """Government-issued ID (driver's license, passport, etc)"""


class IdvSessionState(betterproto.Enum):
    """The states a VerificationSession can be in"""

    IDV_CREATED = 0
    """Session has been created, but not yet shown to user"""

    IDV_INITIATED = 1
    """
    Session has been shown to user (iframe / popup opened), but user has not
    yet logged in.
    """

    IDV_AUTHENTICATING = 2
    """
    User has entered their phone number, but not yet authenticated with the
    code sent via SMS
    """

    IDV_IN_PROGRESS = 3
    """User has been authenticated and is performing identity verification"""

    IDV_SUCCESS = 4
    """Session was completed successfully and IDV data is available to RP"""

    IDV_FAILED = 5
    """The session failed; reason is present in `fail_code`."""


class VerificationState(betterproto.Enum):
    """The states an individual Verification can be in"""

    VERIFICATION_PENDING = 0
    """This verification has not yet been performed in the flow"""

    VERIFICATION_PENDING_REUSE = 1
    """
    This verification has been started by the user, and can be reused from a
    previous verification, but the user has not yet decided whether to reuse
    it.
    """

    VERIFICATION_STARTED = 2
    """
    This verification has been started by the user, but not yet completed
    """

    VERIFICATION_SUCCESS = 3
    """This verification has been successfully completed"""

    VERIFICATION_FAILED = 4
    """This verification has failed"""


class SessionFailCode(betterproto.Enum):
    """The specific reason an IDVSession is in the `Failed` state"""

    SESSION_FAIL_NONE = 0
    """The Session is not in a failure state."""

    SESSION_FAIL_INTERNAL = 1
    """An internal Trinsic error caused this session to fail"""

    SESSION_FAIL_VERIFICATION_FAILED = 2
    """
    The session failed because one or more of the verifications failed. The
    reason for the failure is present in the `fail_reason` field of the
    relevant `Verification` object(s).
    """

    SESSION_FAIL_AUTHENTICATION = 3
    """
    The session failed because the user failed to authenticate with their phone
    number too many times.
    """

    SESSION_FAIL_EXPIRED = 4
    """The session expired"""

    SESSION_FAIL_USER_CANCELED = 5
    """The user canceled / rejected the session"""

    SESSION_FAIL_RP_CANCELED = 6
    """The RP canceled the session"""


class VerificationFailCode(betterproto.Enum):
    """The specific reason a Verification is in the `Failed` state"""

    VERIFICATION_FAIL_NONE = 0
    """The verification is not in a failure state"""

    VERIFICATION_FAIL_INTERNAL = 1
    """An internal Trinsic error caused this verification to fail"""

    VERIFICATION_FAIL_INVALID_IMAGE = 2
    """
    The image(s) provided for this verification were either too low-quality,
    not of the correct type, or otherwise unable to be processed. This failure
    reason is non-terminal; the user is able to retry the verification.
    """

    VERIFICATION_FAIL_INAUTHENTIC = 3
    """
    The identity data/images provided are suspected to be inauthentic,
    fraudulent, or forged.
    """

    VERIFICATION_FAIL_UNSUPPORTED_DOCUMENT = 4
    """
    The document provided is either of an unsupported type, or from an
    unsupported country.
    """


class SessionOrdering(betterproto.Enum):
    """Controls how sessions are ordered in `ListSessions`"""

    CREATED = 0
    """Order sessions according to when they were created"""

    UPDATED = 1
    """Order sessions according to when they last changed state"""

    STATE = 2
    """Order sessions according to their numerical state"""


@dataclass(eq=False, repr=False)
class IdvSession(betterproto.Message):
    """An Identity Verification Session"""

    id: str = betterproto.string_field(1)
    """The ID of the IDVSession."""

    client_token: str = betterproto.string_field(2)
    """
    The Client Token for this IDVSession. This should be passed to your
    frontend to initiate the IDV flow using Trinsic's Web SDK.
    """

    state: "IdvSessionState" = betterproto.enum_field(3)
    """State of the IDVSession"""

    verifications: Dict[str, "Verification"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """The actual Verifications to perform in this IDV flow"""

    fail_code: Optional["SessionFailCode"] = betterproto.enum_field(
        5, optional=True, group="_fail_code"
    )
    """
    The reason for the IDVSession's failure. Only set if `state` is
    `IDV_FAILED`.
    """

    result_vp: Optional[str] = betterproto.string_field(
        6, optional=True, group="_result_vp"
    )
    """The resultant signed VP combining the results of all verifications"""

    created: int = betterproto.fixed64_field(7)
    """The unix timestamp, in seconds, that this IDVSession was created"""

    updated: int = betterproto.fixed64_field(8)
    """
    The unix timestamp, in seconds, that this IDVSession's `state` was last
    updated
    """


@dataclass(eq=False, repr=False)
class Verification(betterproto.Message):
    """A Verification that is part of an IDVSession"""

    id: str = betterproto.string_field(1)
    """The ID of the verification"""

    type: "VerificationType" = betterproto.enum_field(2)
    """
    The type of verification (driver's license, passport, proof of address,
    etc)
    """

    state: "VerificationState" = betterproto.enum_field(3)
    """The state of the verification"""

    fail_code: Optional["VerificationFailCode"] = betterproto.enum_field(
        4, optional=True, group="_fail_code"
    )
    """
    The reason for the Verification's failure. Only set if `state` is
    `VERIFICATION_FAILED`.
    """

    reused: bool = betterproto.bool_field(5)
    """
    Whether this was a reused (true) or fresh (false) verification. If `state`
    is not `VERIFICATION_SUCCESS`, this field is `false` and does not convey
    useful information.
    """

    begun: int = betterproto.fixed64_field(6)
    """
    The unix timestamp, in seconds, when this verification was begun by the
    user -- or `0` if not yet begun.
    """

    updated: int = betterproto.fixed64_field(7)
    """
    The unix timestamp, in seconds, when this verification last changed state
    -- or `0` if it has not yet begun.
    """

    government_id_options: Optional["GovernmentIdOptions"] = betterproto.message_field(
        8, optional=True, group="_government_id_options"
    )
    """
    The Government ID options for this Verification. Only set if this
    Verification is of type `GOVERNMENT_ID`.
    """

    normalized_government_id_data: Optional["NormalizedGovernmentIdData"] = (
        betterproto.message_field(
            9, optional=True, group="_normalized_government_id_data"
        )
    )
    """
    Normalized output for manual parsing and usage for this verification Only
    set if this Verification is of type `GOVERNMENT_ID` and has succeeded.
    """


@dataclass(eq=False, repr=False)
class NormalizedGovernmentIdData(betterproto.Message):
    id_number: Optional[str] = betterproto.string_field(
        1, optional=True, group="_id_number"
    )
    """The ID number of the underlying identity document"""

    given_name: Optional[str] = betterproto.string_field(
        2, optional=True, group="_given_name"
    )
    """Given ("first") name of the document holder"""

    family_name: Optional[str] = betterproto.string_field(
        3, optional=True, group="_family_name"
    )
    """Family ("last") name of the document holder"""

    address: Optional[str] = betterproto.string_field(
        4, optional=True, group="_address"
    )
    """Full address of the document holder"""

    date_of_birth: Optional[str] = betterproto.string_field(
        5, optional=True, group="_date_of_birth"
    )
    """Date of birth of the document holder"""

    country: Optional[str] = betterproto.string_field(
        6, optional=True, group="_country"
    )
    """ISO3 country code of the document"""

    issue_date: Optional[str] = betterproto.string_field(
        7, optional=True, group="_issue_date"
    )
    """Issuance date of the document"""

    expiration_date: Optional[str] = betterproto.string_field(
        8, optional=True, group="_expiration_date"
    )
    """Expiration date date of the document"""


@dataclass(eq=False, repr=False)
class CreateSessionRequest(betterproto.Message):
    """Request to create an Identity Verification Session"""

    verifications: List["RequestedVerification"] = betterproto.message_field(1)
    """Array of verifications to perform"""

    debug_information: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    """Debugging information used to help diagnose issues"""


@dataclass(eq=False, repr=False)
class RequestedVerification(betterproto.Message):
    """A verification to perform in an IDV flow"""

    type: "VerificationType" = betterproto.enum_field(1)
    """The type of verification to perform"""

    government_id_options: "GovernmentIdOptions" = betterproto.message_field(
        2, group="options"
    )
    """Options for a Verification of type `GOVERNMENT_ID`"""


@dataclass(eq=False, repr=False)
class GovernmentIdOptions(betterproto.Message):
    """Options for a Verification of type `GOVERNMENT_ID`"""

    fields: "GovernmentIdFields" = betterproto.message_field(1)
    """
    The fields to retrieve from the Government ID. If this object is not set,
    all fields will be retrieved.
    """


@dataclass(eq=False, repr=False)
class GovernmentIdFields(betterproto.Message):
    """
    Selection of fields to retrieve from a Government ID. All fields default to
    `false` unless explicitly set to `true`.
    """

    id_number: bool = betterproto.bool_field(1)
    """ID number of the underlying identity document"""

    given_name: bool = betterproto.bool_field(2)
    """Given ("first") name of the document holder"""

    family_name: bool = betterproto.bool_field(3)
    """Family ("last") name of the document holder"""

    address: bool = betterproto.bool_field(4)
    """Full address of the document holder"""

    date_of_birth: bool = betterproto.bool_field(5)
    """Date of birth of the document holder"""

    country: bool = betterproto.bool_field(6)
    """ISO3 country code of the document"""

    issue_date: bool = betterproto.bool_field(7)
    """Issuance date of the document"""

    expiration_date: bool = betterproto.bool_field(8)
    """Expiration date date of the document"""


@dataclass(eq=False, repr=False)
class CreateSessionResponse(betterproto.Message):
    """Response to `CreateIDVSessionRequest`"""

    session: "IdvSession" = betterproto.message_field(1)
    """The created IDVSession"""


@dataclass(eq=False, repr=False)
class CancelSessionRequest(betterproto.Message):
    """Request to cancel an Identity Verification Session"""

    idv_session_id: str = betterproto.string_field(1)
    """The ID of the IDVSession to cancel"""


@dataclass(eq=False, repr=False)
class CancelSessionResponse(betterproto.Message):
    """Response to `CancelIDVSessionRequest`"""

    session: "IdvSession" = betterproto.message_field(1)
    """The IDVSession in its current state after cancellation"""


@dataclass(eq=False, repr=False)
class GetSessionRequest(betterproto.Message):
    """Request to get an IDVSession"""

    idv_session_id: str = betterproto.string_field(1)
    """The ID of the IDVSession to get"""


@dataclass(eq=False, repr=False)
class GetSessionResponse(betterproto.Message):
    """Response to `GetIDVSessionRequest`"""

    session: "IdvSession" = betterproto.message_field(1)
    """The IDVSession"""


@dataclass(eq=False, repr=False)
class ListSessionsRequest(betterproto.Message):
    """Request to list all IDVSessions you've created"""

    order_by: "SessionOrdering" = betterproto.enum_field(1)
    """The field by which sessions should be sorted. Defaults to `CREATED`."""

    order_direction: "__common_v1__.OrderDirection" = betterproto.enum_field(2)
    """
    The order in which sessions should be sorted. Defaults to `ASCENDING`.
    """

    page_size: Optional[int] = betterproto.int32_field(
        3, optional=True, group="_page_size"
    )
    """
    The number of results to return per page. Must be between `1` and `10`,
    inclusive. Defaults to `10`.
    """

    page: Optional[int] = betterproto.int32_field(4, optional=True, group="_page")
    """The page index of results to return. Starts at `1`. Defaults to `1`."""


@dataclass(eq=False, repr=False)
class ListSessionsResponse(betterproto.Message):
    """Response to `ListIDVSessionsRequest`"""

    sessions: List["IdvSession"] = betterproto.message_field(1)
    """The sessions you've created"""

    total: int = betterproto.int32_field(2)
    """The total number of sessions you've created"""

    more: bool = betterproto.bool_field(3)
    """
    If `true`, this is not the last page of results. If `false`, this is the
    last page of results.
    """


@dataclass(eq=False, repr=False)
class HasValidCredentialRequest(betterproto.Message):
    """
    Request to preemptively check if an identity has a valid reusable
    credential
    """

    identity: "__universalwallet_v1__.CreateWalletRequestExternalIdentity" = (
        betterproto.message_field(1)
    )
    """The identity used to find a credential"""

    credential_request_data: "CredentialRequestData" = betterproto.message_field(2)
    """The criteria used to find a valid credential"""


@dataclass(eq=False, repr=False)
class HasValidCredentialResponse(betterproto.Message):
    """Response to `HasValidCredentialRequest`"""

    has_valid_credential: bool = betterproto.bool_field(1)
    """Whether the identity has a valid credential"""


@dataclass(eq=False, repr=False)
class CredentialRequestData(betterproto.Message):
    type: "VerificationType" = betterproto.enum_field(1)
    """The type of verification for which the credential can be used"""


class ConnectStub(betterproto.ServiceStub):
    async def create_session(
        self,
        create_session_request: "CreateSessionRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "CreateSessionResponse":
        return await self._unary_unary(
            "/services.connect.v1.Connect/CreateSession",
            create_session_request,
            CreateSessionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_session(
        self,
        cancel_session_request: "CancelSessionRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "CancelSessionResponse":
        return await self._unary_unary(
            "/services.connect.v1.Connect/CancelSession",
            cancel_session_request,
            CancelSessionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_session(
        self,
        get_session_request: "GetSessionRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "GetSessionResponse":
        return await self._unary_unary(
            "/services.connect.v1.Connect/GetSession",
            get_session_request,
            GetSessionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_sessions(
        self,
        list_sessions_request: "ListSessionsRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "ListSessionsResponse":
        return await self._unary_unary(
            "/services.connect.v1.Connect/ListSessions",
            list_sessions_request,
            ListSessionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def has_valid_credential(
        self,
        has_valid_credential_request: "HasValidCredentialRequest",
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["_MetadataLike"] = None,
    ) -> "HasValidCredentialResponse":
        return await self._unary_unary(
            "/services.connect.v1.Connect/HasValidCredential",
            has_valid_credential_request,
            HasValidCredentialResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ConnectBase(ServiceBase):

    async def create_session(
        self, create_session_request: "CreateSessionRequest"
    ) -> "CreateSessionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_session(
        self, cancel_session_request: "CancelSessionRequest"
    ) -> "CancelSessionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_session(
        self, get_session_request: "GetSessionRequest"
    ) -> "GetSessionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_sessions(
        self, list_sessions_request: "ListSessionsRequest"
    ) -> "ListSessionsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def has_valid_credential(
        self, has_valid_credential_request: "HasValidCredentialRequest"
    ) -> "HasValidCredentialResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_session(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.create_session(request)
        await stream.send_message(response)

    async def __rpc_cancel_session(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.cancel_session(request)
        await stream.send_message(response)

    async def __rpc_get_session(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.get_session(request)
        await stream.send_message(response)

    async def __rpc_list_sessions(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.list_sessions(request)
        await stream.send_message(response)

    async def __rpc_has_valid_credential(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()
        response = await self.has_valid_credential(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/services.connect.v1.Connect/CreateSession": grpclib.const.Handler(
                self.__rpc_create_session,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateSessionRequest,
                CreateSessionResponse,
            ),
            "/services.connect.v1.Connect/CancelSession": grpclib.const.Handler(
                self.__rpc_cancel_session,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelSessionRequest,
                CancelSessionResponse,
            ),
            "/services.connect.v1.Connect/GetSession": grpclib.const.Handler(
                self.__rpc_get_session,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSessionRequest,
                GetSessionResponse,
            ),
            "/services.connect.v1.Connect/ListSessions": grpclib.const.Handler(
                self.__rpc_list_sessions,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSessionsRequest,
                ListSessionsResponse,
            ),
            "/services.connect.v1.Connect/HasValidCredential": grpclib.const.Handler(
                self.__rpc_has_valid_credential,
                grpclib.const.Cardinality.UNARY_UNARY,
                HasValidCredentialRequest,
                HasValidCredentialResponse,
            ),
        }
