# Code generated by smithy-python-codegen DO NOT EDIT.

from typing import Any, Dict, List, Optional, Union


class ValidationExceptionField:
    path: str
    message: str
    def __init__(
        self,
        *,
        path: str,
        message: str,
    ):
        """Describes one specific validation failure for an input member.

        :param path: A JSONPointer expression to the structure member whose value failed
        to satisfy the modeled constraints.
        :param message: A detailed description of the validation failure.
        """
        self.path = path
        self.message = message

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ValidationExceptionField to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "path": self.path,
            "message": self.message,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ValidationExceptionField":
        """Creates a ValidationExceptionField from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "path": d["path"],
            "message": d["message"],
        }

        return ValidationExceptionField(**kwargs)

    def __repr__(self) -> str:
        result = "ValidationExceptionField("
        if self.path is not None:
            result += f"path={repr(self.path)}, "

        if self.message is not None:
            result += f"message={repr(self.message)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ValidationExceptionField):
            return False
        attributes: list[str] = ['path','message',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteItemInput:
    database_id: Optional[str]
    key: Optional[str]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        key: Optional[str] = None,
    ):
        self.database_id = database_id
        self.key = key

    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.key is not None:
            d["key"] = self.key

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteItemInput":
        """Creates a DeleteItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "key" in d:
            kwargs["key"] = d["key"]

        return DeleteItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "DeleteItemInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, DeleteItemInput):
            return False
        attributes: list[str] = ['database_id','key',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class DeleteItemOutput:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the DeleteItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "DeleteItemOutput":
        """Creates a DeleteItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return DeleteItemOutput()

    def __repr__(self) -> str:
        result = "DeleteItemOutput("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, DeleteItemOutput)

class EmbeddingInputText():
    def __init__(self, value: str):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"text": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EmbeddingInputText":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return EmbeddingInputText(d["text"])

    def __repr__(self) -> str:
        return f"EmbeddingInputText(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EmbeddingInputText):
            return False
        return self.value == other.value

class EmbeddingInputImage():
    def __init__(self, value: bytes | bytearray):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"image": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EmbeddingInputImage":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return EmbeddingInputImage(d["image"])

    def __repr__(self) -> str:
        return f"EmbeddingInputImage(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EmbeddingInputImage):
            return False
        return self.value == other.value

class EmbeddingInputUnknown():
    """Represents an unknown variant.

    If you receive this value, you will need to update your library to receive the
    parsed value.

    This value may not be deliberately sent.
    """

    def __init__(self, tag: str):
        self.tag = tag

    def as_dict(self) -> Dict[str, Any]:
        return {"SDK_UNKNOWN_MEMBER": {"name": self.tag}}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EmbeddingInputUnknown":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")
        return EmbeddingInputUnknown(d["SDK_UNKNOWN_MEMBER"]["name"])

    def __repr__(self) -> str:
        return f"EmbeddingInputUnknown(tag={self.tag})"

EmbeddingInput = Union[EmbeddingInputText, EmbeddingInputImage, EmbeddingInputUnknown]
def _embedding_input_from_dict(d: Dict[str, Any]) -> EmbeddingInput:
    if "text" in d:
        return EmbeddingInputText.from_dict(d)

    if "image" in d:
        return EmbeddingInputImage.from_dict(d)

    raise TypeError(f'Unions may have exactly 1 value, but found {len(d)}')

class EmbeddingModel:
    ALL_MINILM_L6_V2 = "ALL_MINILM_L6_V2"

    CLIP_VIT_BASE_PATH32 = "CLIP_VIT_BASE_PATH32"

    # This set contains every possible value known at the time this was generated. New
    # values may be added in the future.
    values = frozenset({"ALL_MINILM_L6_V2", "CLIP_VIT_BASE_PATH32"})

class EmbedInput:
    database_id: Optional[str]
    model: Optional[str]
    input: Optional[EmbeddingInput]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        model: Optional[str] = None,
        input: Optional[EmbeddingInput] = None,
    ):
        self.database_id = database_id
        self.model = model
        self.input = input

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EmbedInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.model is not None:
            d["model"] = self.model

        if self.input is not None:
            d["input"] = self.input.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EmbedInput":
        """Creates a EmbedInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "model" in d:
            kwargs["model"] = d["model"]

        if "input" in d:
            kwargs["input"] = _embedding_input_from_dict(d["input"]),

        return EmbedInput(**kwargs)

    def __repr__(self) -> str:
        result = "EmbedInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.model is not None:
            result += f"model={repr(self.model)}, "

        if self.input is not None:
            result += f"input={repr(self.input)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EmbedInput):
            return False
        attributes: list[str] = ['database_id','model','input',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class EmbedOutput:
    vector: list[float]
    consumed_embedding_units: Optional[int]
    def __init__(
        self,
        *,
        vector: list[float],
        consumed_embedding_units: Optional[int] = None,
    ):
        self.vector = vector
        self.consumed_embedding_units = consumed_embedding_units

    def as_dict(self) -> Dict[str, Any]:
        """Converts the EmbedOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "vector": self.vector,
        }

        if self.consumed_embedding_units is not None:
            d["consumedEmbeddingUnits"] = self.consumed_embedding_units

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "EmbedOutput":
        """Creates a EmbedOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "vector": d["vector"],
        }

        if "consumedEmbeddingUnits" in d:
            kwargs["consumed_embedding_units"] = d["consumedEmbeddingUnits"]

        return EmbedOutput(**kwargs)

    def __repr__(self) -> str:
        result = "EmbedOutput("
        if self.vector is not None:
            result += f"vector={repr(self.vector)}, "

        if self.consumed_embedding_units is not None:
            result += f"consumed_embedding_units={repr(self.consumed_embedding_units)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, EmbedOutput):
            return False
        attributes: list[str] = ['vector','consumed_embedding_units',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetItemInput:
    database_id: Optional[str]
    key: Optional[str]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        key: Optional[str] = None,
    ):
        self.database_id = database_id
        self.key = key

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.key is not None:
            d["key"] = self.key

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetItemInput":
        """Creates a GetItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "key" in d:
            kwargs["key"] = d["key"]

        return GetItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "GetItemInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetItemInput):
            return False
        attributes: list[str] = ['database_id','key',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class GetItemOutput:
    key: str
    value: bytes | bytearray
    vector: list[float]
    def __init__(
        self,
        *,
        key: str,
        value: bytes | bytearray,
        vector: list[float],
    ):
        self.key = key
        self.value = value
        self.vector = vector

    def as_dict(self) -> Dict[str, Any]:
        """Converts the GetItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "key": self.key,
            "value": self.value,
            "vector": self.vector,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "GetItemOutput":
        """Creates a GetItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": d["key"],
            "value": d["value"],
            "vector": d["vector"],
        }

        return GetItemOutput(**kwargs)

    def __repr__(self) -> str:
        result = "GetItemOutput("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.vector is not None:
            result += f"vector={repr(self.vector)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, GetItemOutput):
            return False
        attributes: list[str] = ['key','value','vector',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListItemsInput:
    database_id: Optional[str]
    page_size: Optional[int]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        page_size: Optional[int] = None,
        next_token: Optional[str] = None,
    ):
        self.database_id = database_id
        self.page_size = page_size
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListItemsInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.page_size is not None:
            d["pageSize"] = self.page_size

        if self.next_token is not None:
            d["nextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListItemsInput":
        """Creates a ListItemsInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "pageSize" in d:
            kwargs["page_size"] = d["pageSize"]

        if "nextToken" in d:
            kwargs["next_token"] = d["nextToken"]

        return ListItemsInput(**kwargs)

    def __repr__(self) -> str:
        result = "ListItemsInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.page_size is not None:
            result += f"page_size={repr(self.page_size)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListItemsInput):
            return False
        attributes: list[str] = ['database_id','page_size','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class Item:
    key: str
    value: bytes | bytearray
    vector: list[float]
    def __init__(
        self,
        *,
        key: str,
        value: bytes | bytearray,
        vector: list[float],
    ):
        self.key = key
        self.value = value
        self.vector = vector

    def as_dict(self) -> Dict[str, Any]:
        """Converts the Item to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "key": self.key,
            "value": self.value,
            "vector": self.vector,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Item":
        """Creates a Item from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": d["key"],
            "value": d["value"],
            "vector": d["vector"],
        }

        return Item(**kwargs)

    def __repr__(self) -> str:
        result = "Item("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.vector is not None:
            result += f"vector={repr(self.vector)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, Item):
            return False
        attributes: list[str] = ['key','value','vector',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class ListItemsOutput:
    items: list[Item]
    next_token: Optional[str]
    def __init__(
        self,
        *,
        items: list[Item],
        next_token: Optional[str] = None,
    ):
        self.items = items
        self.next_token = next_token

    def as_dict(self) -> Dict[str, Any]:
        """Converts the ListItemsOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {
            "items": _item_list_as_dict(self.items),
        }

        if self.next_token is not None:
            d["nextToken"] = self.next_token

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "ListItemsOutput":
        """Creates a ListItemsOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "items": _item_list_from_dict(d["items"]),
        }

        if "nextToken" in d:
            kwargs["next_token"] = d["nextToken"]

        return ListItemsOutput(**kwargs)

    def __repr__(self) -> str:
        result = "ListItemsOutput("
        if self.items is not None:
            result += f"items={repr(self.items)}, "

        if self.next_token is not None:
            result += f"next_token={repr(self.next_token)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, ListItemsOutput):
            return False
        attributes: list[str] = ['items','next_token',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class QueryTypeKey():
    def __init__(self, value: str):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"key": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryTypeKey":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return QueryTypeKey(d["key"])

    def __repr__(self) -> str:
        return f"QueryTypeKey(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryTypeKey):
            return False
        return self.value == other.value

class QueryTypeVector():
    def __init__(self, value: list[float]):
        self.value = value

    def as_dict(self) -> Dict[str, Any]:
        return {"vector": self.value}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryTypeVector":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")

        return QueryTypeVector(d["vector"])

    def __repr__(self) -> str:
        return f"QueryTypeVector(value=repr(self.value))"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryTypeVector):
            return False
        return self.value == other.value

class QueryTypeUnknown():
    """Represents an unknown variant.

    If you receive this value, you will need to update your library to receive the
    parsed value.

    This value may not be deliberately sent.
    """

    def __init__(self, tag: str):
        self.tag = tag

    def as_dict(self) -> Dict[str, Any]:
        return {"SDK_UNKNOWN_MEMBER": {"name": self.tag}}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryTypeUnknown":
        if (len(d) != 1):
            raise TypeError(f"Unions may have exactly 1 value, but found {len(d)}")
        return QueryTypeUnknown(d["SDK_UNKNOWN_MEMBER"]["name"])

    def __repr__(self) -> str:
        return f"QueryTypeUnknown(tag={self.tag})"

QueryType = Union[QueryTypeKey, QueryTypeVector, QueryTypeUnknown]
def _query_type_from_dict(d: Dict[str, Any]) -> QueryType:
    if "key" in d:
        return QueryTypeKey.from_dict(d)

    if "vector" in d:
        return QueryTypeVector.from_dict(d)

    raise TypeError(f'Unions may have exactly 1 value, but found {len(d)}')

class QueryInput:
    database_id: Optional[str]
    max_results: Optional[int]
    query: Optional[QueryType]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        max_results: Optional[int] = None,
        query: Optional[QueryType] = None,
    ):
        self.database_id = database_id
        self.max_results = max_results
        self.query = query

    def as_dict(self) -> Dict[str, Any]:
        """Converts the QueryInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.max_results is not None:
            d["maxResults"] = self.max_results

        if self.query is not None:
            d["query"] = self.query.as_dict()

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryInput":
        """Creates a QueryInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "maxResults" in d:
            kwargs["max_results"] = d["maxResults"]

        if "query" in d:
            kwargs["query"] = _query_type_from_dict(d["query"]),

        return QueryInput(**kwargs)

    def __repr__(self) -> str:
        result = "QueryInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.max_results is not None:
            result += f"max_results={repr(self.max_results)}, "

        if self.query is not None:
            result += f"query={repr(self.query)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryInput):
            return False
        attributes: list[str] = ['database_id','max_results','query',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class QueryResultItem:
    key: str
    value: bytes | bytearray
    vector: list[float]
    distance: float
    def __init__(
        self,
        *,
        key: str,
        value: bytes | bytearray,
        vector: list[float],
        distance: float,
    ):
        self.key = key
        self.value = value
        self.vector = vector
        self.distance = distance

    def as_dict(self) -> Dict[str, Any]:
        """Converts the QueryResultItem to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "key": self.key,
            "value": self.value,
            "vector": self.vector,
            "distance": self.distance,
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryResultItem":
        """Creates a QueryResultItem from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "key": d["key"],
            "value": d["value"],
            "vector": d["vector"],
            "distance": d["distance"],
        }

        return QueryResultItem(**kwargs)

    def __repr__(self) -> str:
        result = "QueryResultItem("
        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.vector is not None:
            result += f"vector={repr(self.vector)}, "

        if self.distance is not None:
            result += f"distance={repr(self.distance)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryResultItem):
            return False
        attributes: list[str] = ['key','value','vector','distance',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class QueryOutput:
    results: list[QueryResultItem]
    def __init__(
        self,
        *,
        results: list[QueryResultItem],
    ):
        self.results = results

    def as_dict(self) -> Dict[str, Any]:
        """Converts the QueryOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {
            "results": _query_result_as_dict(self.results),
        }

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "QueryOutput":
        """Creates a QueryOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {
            "results": _query_result_from_dict(d["results"]),
        }

        return QueryOutput(**kwargs)

    def __repr__(self) -> str:
        result = "QueryOutput("
        if self.results is not None:
            result += f"results={repr(self.results)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, QueryOutput):
            return False
        attributes: list[str] = ['results',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SetItemInput:
    database_id: Optional[str]
    key: Optional[str]
    value: Optional[bytes | bytearray]
    vector: Optional[list[float]]
    def __init__(
        self,
        *,
        database_id: Optional[str] = None,
        key: Optional[str] = None,
        value: Optional[bytes | bytearray] = None,
        vector: Optional[list[float]] = None,
    ):
        self.database_id = database_id
        self.key = key
        self.value = value
        self.vector = vector

    def as_dict(self) -> Dict[str, Any]:
        """Converts the SetItemInput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        d: Dict[str, Any] = {}

        if self.database_id is not None:
            d["databaseId"] = self.database_id

        if self.key is not None:
            d["key"] = self.key

        if self.value is not None:
            d["value"] = self.value

        if self.vector is not None:
            d["vector"] = self.vector

        return d

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SetItemInput":
        """Creates a SetItemInput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        kwargs: Dict[str, Any] = {}

        if "databaseId" in d:
            kwargs["database_id"] = d["databaseId"]

        if "key" in d:
            kwargs["key"] = d["key"]

        if "value" in d:
            kwargs["value"] = d["value"]

        if "vector" in d:
            kwargs["vector"] = d["vector"]

        return SetItemInput(**kwargs)

    def __repr__(self) -> str:
        result = "SetItemInput("
        if self.database_id is not None:
            result += f"database_id={repr(self.database_id)}, "

        if self.key is not None:
            result += f"key={repr(self.key)}, "

        if self.value is not None:
            result += f"value={repr(self.value)}, "

        if self.vector is not None:
            result += f"vector={repr(self.vector)}"

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, SetItemInput):
            return False
        attributes: list[str] = ['database_id','key','value','vector',]
        return all(
            getattr(self, a) == getattr(other, a)
            for a in attributes
        )

class SetItemOutput:
    def as_dict(self) -> Dict[str, Any]:
        """Converts the SetItemOutput to a dictionary.

        The dictionary uses the modeled shape names rather than the parameter names as
        keys to be mostly compatible with boto3.
        """
        return {}

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "SetItemOutput":
        """Creates a SetItemOutput from a dictionary.

        The dictionary is expected to use the modeled shape names rather than the
        parameter names as keys to be mostly compatible with boto3.
        """
        return SetItemOutput()

    def __repr__(self) -> str:
        result = "SetItemOutput("

        return result + ")"

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, SetItemOutput)

def _validation_exception_field_list_as_dict(given: list[ValidationExceptionField]) -> List[Any]:
    return [v.as_dict() for v in given]

def _validation_exception_field_list_from_dict(given: List[Any]) -> list[ValidationExceptionField]:
    return [ValidationExceptionField.from_dict(v) for v in given]

def _query_result_as_dict(given: list[QueryResultItem]) -> List[Any]:
    return [v.as_dict() for v in given]

def _query_result_from_dict(given: List[Any]) -> list[QueryResultItem]:
    return [QueryResultItem.from_dict(v) for v in given]

def _item_list_as_dict(given: list[Item]) -> List[Any]:
    return [v.as_dict() for v in given]

def _item_list_from_dict(given: List[Any]) -> list[Item]:
    return [Item.from_dict(v) for v in given]
