 {
    "respHdr": {
        "tid": "5fe325b3-5f4b-4073-964d-bb00647ca3ca",
        "requestTid": "REXiiwHxg_JtyCI6PSsmh"
    },
    "legos": [
        {
            "name": "Get K8S OOMKilled Pods",
            "id": "dadfbf844469d50feb44c38e8a812ef1e61b466e905f1acc9d7aa65d77aa0541",
            "index": 64,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_oomkilled_pods"
            ],
            "currentVersion": "0.1.0",
            "description": "Get K8S Pods which are OOMKilled from the container last states.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "import pprint",
                "from typing import Tuple, Optional",
                "from pydantic import BaseModel, Field",
                "from kubernetes import client",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_oomkilled_pods_printer(output):",
                "    if output is None:",
                "        return",
                "    pprint.pprint(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_oomkilled_pods(handle, namespace: str = \"\") -> Tuple:",
                "    \"\"\"k8s_get_oomkilled_pods This function returns the pods that have OOMKilled event in the container last states",
                "",
                "    :type handle: Object",
                "    :param handle: Object returned from the task.validate(...) function",
                "",
                "    :type namespace: str",
                "    :param namespace: (Optional)String, K8S Namespace as python string",
                "",
                "    :rtype: Status, List of objects of pods, namespaces, and containers that are in OOMKilled state",
                "    \"\"\"",
                "    result = []",
                "",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    v1 = client.CoreV1Api(api_client=handle)",
                "",
                "    # Check whether a namespace is provided, if not fetch all namespaces",
                "    try:",
                "        if namespace:",
                "            response = v1.list_namespaced_pod(namespace)",
                "        else:",
                "            response = v1.list_pod_for_all_namespaces()",
                "",
                "        if response is None or not hasattr(response, 'items'):",
                "            raise ApiException(\"Unexpected response from the Kubernetes API. 'items' not found in the response.\")",
                "",
                "        pods = response.items",
                "",
                "    except ApiException as e:",
                "        raise e",
                "",
                "    # Check if pods is None or not",
                "    if pods is None:",
                "        raise ApiException(\"No pods returned from the Kubernetes API.\")",
                "",
                "    for pod in pods:",
                "        pod_name = pod.metadata.name",
                "        namespace = pod.metadata.namespace",
                "",
                "        # Ensure container_statuses is not None before iterating",
                "        container_statuses = pod.status.container_statuses",
                "        if container_statuses is None:",
                "            continue",
                "",
                "        # Check each pod for OOMKilled state",
                "        for container_status in container_statuses:",
                "            container_name = container_status.name",
                "            last_state = container_status.last_state",
                "            if last_state and last_state.terminated and last_state.terminated.reason == \"OOMKilled\":",
                "                result.append({\"pod\": pod_name, \"namespace\": namespace, \"container\": container_name})",
                "",
                "    return (False, result) if result else (True, None)",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_oomkilled_pods, lego_printer=k8s_get_oomkilled_pods_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"Kubernetes Namespace Where the Service exists\",\"title\":\"K8S Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_oomkilled_pods\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_TROUBLESHOOTING",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get all K8s Pods in CrashLoopBackOff State",
            "id": "d8047bf803242cfbfd1a19e28d64ae8d95168f8edb753ae4e1e7a7af1ffccf07",
            "index": 40,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pods_in_crashloopbackoff_state"
            ],
            "currentVersion": "0.1.0",
            "description": "Get all K8s pods in CrashLoopBackOff State",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2022 unSkript.com",
                "# All rights reserved.",
                "#",
                "",
                "import pprint",
                "import re",
                "from typing import Optional, Tuple",
                "from collections import defaultdict",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pods_in_crashloopbackoff_state_printer(output):",
                "    if output is None:",
                "        return",
                "    pprint.pprint(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_pods_in_crashloopbackoff_state(handle, namespace: str = '') -> Tuple:",
                "    \"\"\"k8s_get_pods_in_crashloopbackoff_state executes the given kubectl",
                "    command to find pods in CrashLoopBackOff State",
                "",
                "        :type handle: object",
                "        :param handle: Object returned from the Task validate method",
                "",
                "        :type namespace: Optional[str]",
                "        :param namespace: Namespace to get the pods from. Eg:\"logging\",",
                "        if not given all namespaces are considered",
                "",
                "        :rtype: Status, List of pods in CrashLoopBackOff State",
                "    \"\"\"",
                "",
                "    if handle.client_side_validation is False:",
                "        raise ApiException(f\"K8S Connector is invalid: {handle}\")",
                "",
                "    kubectl_command = (\"kubectl get pods --all-namespaces | grep CrashLoopBackOff \"",
                "                       \"| tr -s ' ' | cut -d ' ' -f 1,2\")",
                "    if namespace:",
                "        kubectl_command = \"kubectl get pods -n \" + namespace + \\",
                "        \" | grep CrashLoopBackOff | cut -d' ' -f 1 | tr -d ' '\"",
                "    response = handle.run_native_cmd(kubectl_command)",
                "",
                "    if response is None:",
                "        print(",
                "            f\"Error while executing command ({kubectl_command}) (empty response)\")",
                "        return False, None",
                "",
                "    if response.stderr:",
                "        raise ApiException(",
                "            f\"Error occurred while executing command {kubectl_command} {response.stderr}\")",
                "",
                "    temp = response.stdout",
                "    result = []",
                "    res = []",
                "    unhealthy_pods = []",
                "    unhealthy_pods_tuple = ()",
                "    if not namespace:",
                "        all_namespaces = re.findall(r\"(\\S+).*\", temp)",
                "        all_unhealthy_pods = re.findall(r\"\\S+\\s+(.*)\", temp)",
                "        unhealthy_pods = list(zip(all_namespaces, all_unhealthy_pods))",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    elif namespace:",
                "        all_pods = []",
                "        all_unhealthy_pods = []",
                "        all_pods = re.findall(r\"(\\S+).*\", temp)",
                "        for p in all_pods:",
                "            unhealthy_pods_tuple = (namespace, p)",
                "            unhealthy_pods.append(unhealthy_pods_tuple)",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    if len(res) != 0:",
                "        result.append(dict(res))",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pods_in_crashloopbackoff_state, lego_printer=k8s_get_pods_in_crashloopbackoff_state_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"k8s Namespace\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_pods_in_crashloopbackoff_state\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_TROUBLESHOOTING",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get K8S Service with no associated endpoints",
            "id": "9006093a3cd1f8d0b2fa5f4b7958469bddf8f788d089ef8480fbc7d3af189088",
            "index": 36,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_service_with_no_associated_endpoints"
            ],
            "currentVersion": "0.1.0",
            "description": "Get K8S Service with no associated endpoints",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "import pprint",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes import client",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_service_with_no_associated_endpoints_printer(output):",
                "    if output is None:",
                "        return",
                "",
                "    print(output)",
                "",
                "@beartype",
                "def k8s_get_service_with_no_associated_endpoints(handle, namespace: str = \"\") -> Tuple:",
                "    \"\"\"k8s_get_service_with_no_associated_endpoints This function returns Services that",
                "       do not have any associated endpoints.",
                "",
                "       :type handle: Object",
                "       :param handle: Object returned from the task.validate(...) function",
                "",
                "       :type namespace: str",
                "       :param namespace: String, K8S Namespace as python string",
                "",
                "       :rtype: Tuple Result in tuple format.",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    v1 = client.CoreV1Api(api_client=handle)",
                "    services = v1.list_service_for_all_namespaces().items",
                "    services_to_check = services",
                "    if namespace != \"\":",
                "        for s in services:",
                "            if s.metadata.namespace == namespace:",
                "                services_to_check = s",
                "                break",
                "",
                "    retval = []",
                "    for service in services_to_check:",
                "        ep = v1.read_namespaced_endpoints(service.metadata.name, service.metadata.namespace)",
                "        if not ep.subsets:",
                "            pprint.pprint(ep)",
                "            retval.append({\"name\": service.metadata.name, \"namespace\": service.metadata.namespace})",
                "",
                "    if retval:",
                "        return (False, retval)",
                "",
                "    return(True, [])",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_service_with_no_associated_endpoints, lego_printer=k8s_get_service_with_no_associated_endpoints_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"Kubernetes Namespace Where the Service exists\",\"title\":\"K8S Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_service_with_no_associated_endpoints\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get expiring K8s certificates",
            "id": "87eb04e0ec473d61454c46bb664e197d85d8343abf973144031d7ee4dbb40fa1",
            "index": 99,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_expiring_certificates"
            ],
            "currentVersion": "0.1.0",
            "description": "Get the expiring certificates for a K8s cluster.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "##",
                "# Copyright (c) 2023 unSkript, Inc",
                "# All rights reserved.",
                "##",
                "from pydantic import BaseModel, Field",
                "from typing import Optional, Tuple",
                "import base64",
                "import datetime",
                "from cryptography import x509",
                "from cryptography.hazmat.backends import default_backend",
                "from kubernetes import client, watch",
                "from kubernetes.client.rest import ApiException",
                "from tabulate import tabulate",
                "from unskript.legos.kubernetes.k8s_kubectl_command.k8s_kubectl_command import k8s_kubectl_command",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_expiring_certificates_printer(output):",
                "    if output is None:",
                "        return",
                "    success, data = output",
                "    if not success:",
                "        headers = ['Secret Name', 'Namespace']",
                "        table = [[item['secret_name'], item['namespace']] for item in data]",
                "        print(tabulate(table, headers=headers, tablefmt='grid'))",
                "    else:",
                "        print(\"No expiring certificates found.\")",
                "",
                "@beartype",
                "def get_expiry_date(pem_data: str) -> datetime.datetime:",
                "    cert = x509.load_pem_x509_certificate(pem_data.encode(), default_backend())",
                "    return cert.not_valid_after",
                "",
                "",
                "@beartype",
                "def k8s_get_expiring_certificates(handle, namespace:str='', expiring_threshold:int=90) -> Tuple:",
                "    \"\"\"",
                "    Get the expiring certificates for a K8s cluster.",
                "",
                "    Args:",
                "        handle: Object of type unSkript K8S Connector",
                "        namespace (str): The Kubernetes namespace where the certificates are stored.",
                "        expiration_threshold (int): The threshold (in days) for considering a certificate as expiring soon.",
                "",
                "    Returns:",
                "        tuple: Status, a list of expiring certificate names.",
                "    \"\"\"",
                "    result = []",
                "    all_namespaces = [namespace]",
                "",
                "    cmd = \"kubectl get ns  --no-headers -o custom-columns=':metadata.name'\"",
                "",
                "    if namespace is None or len(namespace) == 0:",
                "        response = handle.run_native_cmd(cmd)",
                "        if response is None:",
                "            print(",
                "                f\"Error while executing command ({cmd}) (empty response)\")",
                "",
                "        if response.stderr:",
                "            raise ApiException(",
                "                f\"Error occurred while executing command {cmd} {response.stderr}\")",
                "        kubernetes_namespaces = response.stdout",
                "        replaced_str = kubernetes_namespaces.replace(\"\\n\", \" \")",
                "        stripped_str = replaced_str.strip()",
                "        all_namespaces = stripped_str.split(\" \")",
                "",
                "    coreApiClient = client.CoreV1Api(api_client=handle)",
                "    for n in all_namespaces:",
                "        coreApiClient.read_namespace_status(n, pretty=True)",
                "        secrets = coreApiClient.list_namespaced_secret(n, watch=False, limit=200).items",
                "",
                "        for secret in secrets:",
                "            # Check if the secret contains a certificate",
                "            if secret.type == \"kubernetes.io/tls\":",
                "                # Get the certificate data",
                "                cert_data = secret.data.get(\"tls.crt\")",
                "                if cert_data:",
                "                    # Decode the certificate data",
                "                    cert_data_decoded = base64.b64decode(cert_data).decode(\"utf-8\")",
                "                    # Parse the certificate expiration date",
                "                    cert_exp = get_expiry_date(cert_data_decoded)",
                "                    if cert_exp and cert_exp < datetime.datetime.now() + datetime.timedelta(days=expiring_threshold):",
                "                        result.append({\"secret_name\": secret.metadata.name, \"namespace\": n})",
                "",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_expiring_certificates, lego_printer=k8s_get_expiring_certificates_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"expiring_threshold\":{\"default\":90,\"description\":\"Expiration Threshold of certificates (in days). Default- 90 days\",\"title\":\"Expiration Threshold (in days)\",\"type\":\"integer\"},\"namespace\":{\"default\":\"\",\"description\":\"K8s Namespace. Default- all namespaces\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_expiring_certificates\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace",
                "expiring_threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get all K8s Pods in ImagePullBackOff State",
            "id": "683b7f1a1482a5bed32698689e2b47e13dcdb5e00d719316cc46ada5ead26758",
            "index": 65,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pods_in_imagepullbackoff_state"
            ],
            "currentVersion": "0.1.0",
            "description": "Get all K8s pods in ImagePullBackOff State",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2022 unSkript.com",
                "# All rights reserved.",
                "#",
                "",
                "import pprint",
                "import re",
                "from typing import Optional, Tuple",
                "from collections import defaultdict",
                "from pydantic import BaseModel, Field",
                "",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pods_in_imagepullbackoff_state_printer(output):",
                "    if output is None:",
                "        return",
                "    pprint.pprint(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_pods_in_imagepullbackoff_state(handle, namespace: str = '') -> Tuple:",
                "    \"\"\"k8s_get_list_of_pods_with_imagepullbackoff_state executes the given",
                "    kubectl command to find pods in ImagePullBackOff State",
                "",
                "        :type handle: object",
                "        :param handle: Object returned from the Task validate method",
                "",
                "        :type namespace: Optional[str]",
                "        :param namespace: Namespace to get the pods from. Eg:\"logging\",",
                "        if not given all namespaces are considered",
                "",
                "        :rtype: Status, List of pods in CrashLoopBackOff State",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        print(f\"K8S Connector is invalid: {handle}\")",
                "        return False, None",
                "",
                "    kubectl_command = (\"kubectl get pods --all-namespaces | grep -e ImagePullBackOff -e ErrImagePull \"",
                "                       \"| tr -s ' ' | cut -d ' ' -f 1,2\")",
                "    if namespace:",
                "        kubectl_command = \"kubectl get pods -n \" + namespace + \\",
                "            \" | grep -e ImagePullBackOff -e ErrImagePull | cut -d' ' -f 1 | tr -d ' '\"",
                "    response = handle.run_native_cmd(kubectl_command)",
                "",
                "    if response is None:",
                "        print(",
                "            f\"Error while executing command ({kubectl_command}) (empty response)\")",
                "        return False, None",
                "",
                "    if response.stderr:",
                "        raise ApiException(",
                "            f\"Error occurred while executing command {kubectl_command} {response.stderr}\")",
                "",
                "    temp = response.stdout",
                "    result = []",
                "    res = []",
                "    unhealthy_pods = []",
                "    unhealthy_pods_tuple = ()",
                "    if not namespace:",
                "        all_namespaces = re.findall(r\"(\\S+).*\", temp)",
                "        all_unhealthy_pods = re.findall(r\"\\S+\\s+(.*)\", temp)",
                "        unhealthy_pods = list(zip(all_namespaces, all_unhealthy_pods))",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    elif namespace:",
                "        all_pods = []",
                "        all_unhealthy_pods = []",
                "        all_pods = re.findall(r\"(\\S+).*\", temp)",
                "        for p in all_pods:",
                "            unhealthy_pods_tuple = (namespace, p)",
                "            unhealthy_pods.append(unhealthy_pods_tuple)",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    if len(res) != 0:",
                "        result.append(dict(res))",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pods_in_imagepullbackoff_state, lego_printer=k8s_get_pods_in_imagepullbackoff_state_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"k8s Namespace\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_pods_in_imagepullbackoff_state\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_TROUBLESHOOTING",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {
                "31574b9c-b3da-467a-aef4-2dd48d635d38": {
                    "actionNextHopDetails": {
                        "name": "k8s: Pod Stuck in ImagePullBackOff State"
                    }
                }
            },
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get K8S Cluster Health",
            "id": "134d70d8685769e42fdf3b014e948b88e3d0efd0b9da0f5a2e60cf6f62069aad",
            "index": 93,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_cluster_health"
            ],
            "currentVersion": "0.1.0",
            "description": "Get K8S Cluster Health",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "##",
                "# Copyright (c) 2023 unSkript, Inc",
                "# All rights reserved.",
                "##",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes import client",
                "from kubernetes.client.rest import ApiException",
                "from tabulate import tabulate",
                "",
                "try:",
                "    from unskript.legos.kubernetes.k8s_utils import normalize_cpu, normalize_memory",
                "except Exception:",
                "    pass",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_cluster_health_printer(output):",
                "    status, details_list = output",
                "    details = details_list[0]",
                "",
                "    # Print overall status",
                "    if status:",
                "        print(\"Cluster Health: OK\\n\")",
                "        return",
                "",
                "    # If there are any issues, tabulate and print them",
                "    print(\"Cluster Health: NOT OK\\n\")",
                "",
                "    # Print Not Ready Nodes",
                "    if details['not_ready_nodes']:",
                "        headers = [\"Name\", \"Type\", \"Status\", \"Reason\", \"Message\"]",
                "        table = [[node['name'], node['condition_type'], node['condition_status'], node['condition_reason'], node['condition_message']]",
                "                 for node in details['not_ready_nodes']]",
                "        print(\"Not Ready Nodes:\")",
                "        print(tabulate(table, headers=headers, tablefmt='grid', numalign=\"left\"))",
                "        print()",
                "",
                "    # Print Not Ready Pods",
                "    if details['not_ready_pods']:",
                "        headers = [\"Name\", \"Namespace\", \"Type\", \"Status\", \"Reason\", \"Message\"]",
                "        table = [[pod['name'], pod['namespace'], pod['condition_type'], pod['condition_status'], pod['condition_reason'], pod['condition_message']]",
                "                 for pod in details['not_ready_pods']]",
                "        print(\"Not Ready Pods:\")",
                "        print(tabulate(table, headers=headers, tablefmt='grid', numalign=\"left\"))",
                "        print()",
                "",
                "    # Print Abnormal Nodes",
                "    if details['abnormal_nodes']:",
                "        headers = [\"Name\", \"Events\"]",
                "        table = [[node['name'], node['events']] for node in details['abnormal_nodes']]",
                "        print(\"Nodes with Abnormal Events:\")",
                "        print(tabulate(table, headers=headers, tablefmt='grid', numalign=\"left\"))",
                "        print()",
                "",
                "",
                "",
                "@beartype",
                "def k8s_get_abnormal_events(node_api, node_name: str, security_level: str = \"Warning\") -> str:",
                "    \"\"\"k8s_get_abnormal_events This is a helper function that is called by the main function to",
                "       get abnormal events with a filter. Default filter (security_level) is set to Warning",
                "    \"\"\"",
                "    field_selector = f\"involvedObject.kind=Node,involvedObject.name={node_name},type={security_level}\"",
                "    event_string = ''",
                "    try:",
                "        events = node_api.list_event_for_all_namespaces(field_selector=field_selector)",
                "",
                "        # Print the details of each event",
                "        for event in events.items:",
                "            event_string = event_string + f\"Event: {event.metadata.name} - {event.type} - \\",
                "                {event.reason} - {event.message} - {event.last_timestamp}\" + '\\n'",
                "",
                "    except ApiException as e:",
                "        raise e",
                "",
                "    return event_string",
                "",
                "@beartype",
                "def k8s_get_cluster_health(handle, threshold:int = 80) -> Tuple:",
                "    \"\"\"k8s_get_cluster_health This function takes the Handle as an input parameter,",
                "       finds out all the Nodes present in the Cluster, Finds out the following",
                "       * Any abnormal events seen on the node",
                "       * If the node is under pressure",
                "       * Node Status & Pod Status",
                "",
                "       :type handle: object",
                "       :param handle: Object returned from task.validator(...)",
                "",
                "       :type threshold: int",
                "       :param threshold: CPU and Memory Threshold",
                "",
                "       :rtype: Tuple",
                "       :param: Tuple that contains result and any errors",
                "    \"\"\"",
                "",
                "    retval = {}",
                "    not_ready_nodes = []",
                "    not_ready_pods = []",
                "    abnormal_nodes = []",
                "",
                "    node_api = pods_api = client.CoreV1Api(api_client=handle)",
                "    nodes = node_api.list_node()",
                "",
                "    for node in nodes.items:",
                "        skip_remaining_checks = False",
                "        # Get Node Status",
                "        conditions = node.status.conditions",
                "        for condition in conditions:",
                "            if condition.type == 'Ready' and condition.status == 'False':",
                "                not_ready_nodes.append({",
                "                    'name': node.metadata.name,",
                "                    'condition_type': condition.type,",
                "                    'condition_status': condition.status,",
                "                    'condition_reason': condition.reason,",
                "                    'condition_message': condition.message",
                "                })",
                "                skip_remaining_checks = True",
                "                break",
                "",
                "        # Node is not ready, no need to perform other checks",
                "        if skip_remaining_checks:",
                "            continue",
                "",
                "        # Lets get abnormal events. Lets go with `warning` as the default level",
                "        events = k8s_get_abnormal_events(node_api, node.metadata.name)",
                "        if events != '':",
                "            abnormal_nodes.append({'name': node.metadata.name, 'events': events})",
                "",
                "    # Check the status of the Kubernetes pods",
                "    pods = pods_api.list_pod_for_all_namespaces()",
                "    for pod in pods.items:",
                "        conditions = pod.status.conditions",
                "        for condition in conditions:",
                "            if condition.type == 'Ready' and condition.status == 'False':",
                "                not_ready_pods.append({",
                "                    'name': pod.metadata.name,",
                "                    'namespace': pod.metadata.namespace,",
                "                    'condition_type': condition.type,",
                "                    'condition_status': condition.status,",
                "                    'condition_reason': condition.reason,",
                "                    'condition_message': condition.message",
                "                })",
                "                break",
                "",
                "    # If any of the above checks have failed, raise an exception",
                "    if len(not_ready_nodes) > 0 or len(not_ready_pods) > 0 or len(abnormal_nodes) > 0:",
                "        retval['not_ready_nodes'] = not_ready_nodes",
                "        retval['not_ready_pods'] = not_ready_pods",
                "        retval['abnormal_nodes'] = abnormal_nodes",
                "        return (False, [retval])",
                "",
                "    return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_cluster_health, lego_printer=k8s_get_cluster_health_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"threshold\":{\"default\":80,\"description\":\"CPU \\u0026 Memory Threshold %age\",\"title\":\"Threshold\",\"type\":\"integer\"}},\"title\":\"k8s_get_cluster_health\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD",
                "CATEGORY_TYPE_K8S_CLUSTER"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get all K8s Pods in Terminating State",
            "id": "0ee6916ced53898c496c01c396ee6765611e023029080258463bd4331af54582",
            "index": 73,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pods_in_terminating_state"
            ],
            "currentVersion": "0.1.0",
            "description": "Get all K8s pods in Terminating State",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2022 unSkript.com",
                "# All rights reserved.",
                "#",
                "",
                "import pprint",
                "import re",
                "from typing import Optional, Tuple",
                "from collections import defaultdict",
                "from pydantic import BaseModel, Field",
                "from unskript.legos.utils import CheckOutput",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pods_in_terminating_state_printer(output):",
                "    if output is None:",
                "        return",
                "    if isinstance(output, CheckOutput):",
                "        print(output.json())",
                "    else:",
                "        pprint.pprint(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_pods_in_terminating_state(handle, namespace: str = '') -> Tuple:",
                "    \"\"\"k8s_get_pods_in_terminating_state executes the given kubectl",
                "    command to find pods in Terminating State",
                "",
                "        :type handle: object",
                "        :param handle: Object returned from the Task validate method",
                "",
                "        :type namespace: Optional[str]",
                "        :param namespace: Namespace to get the pods from. Eg:\"logging\", if not",
                "        given all namespaces are considered",
                "",
                "        :rtype: Status, List of pods in Terminating State",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        print(f\"K8S Connector is invalid: {handle}\")",
                "        return False, None",
                "    kubectl_command = (\"kubectl get pods --all-namespaces | grep Terminating \"",
                "                       \"| tr -s ' ' | cut -d ' ' -f 1,2\")",
                "    if namespace:",
                "        kubectl_command = (\"kubectl get pods -n \" + namespace + \" | grep Terminating \"",
                "                           \"| cut -d' ' -f 1 | tr -d ' '\")",
                "    response = handle.run_native_cmd(kubectl_command)",
                "",
                "    if response is None:",
                "        print(",
                "            f\"Error while executing command ({kubectl_command}) (empty response)\")",
                "        return False, None",
                "",
                "    if response.stderr:",
                "        raise ApiException(",
                "            f\"Error occurred while executing command {kubectl_command} {response.stderr}\")",
                "",
                "    temp = response.stdout",
                "    result = []",
                "    res = []",
                "    unhealthy_pods = []",
                "    unhealthy_pods_tuple = ()",
                "    if not namespace:",
                "        all_namespaces = re.findall(r\"(\\S+).*\", temp)",
                "        all_unhealthy_pods = re.findall(r\"\\S+\\s+(.*)\", temp)",
                "        unhealthy_pods = list(zip(all_namespaces, all_unhealthy_pods))",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    elif namespace:",
                "        all_pods = []",
                "        all_unhealthy_pods = []",
                "        all_pods = re.findall(r\"(\\S+).*\", temp)",
                "        for p in all_pods:",
                "            unhealthy_pods_tuple = (namespace, p)",
                "            unhealthy_pods.append(unhealthy_pods_tuple)",
                "        res = defaultdict(list)",
                "        for key, val in unhealthy_pods:",
                "            res[key].append(val)",
                "    if len(res) != 0:",
                "        result.append(dict(res))",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pods_in_terminating_state, lego_printer=k8s_get_pods_in_terminating_state_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"k8s Namespace\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_pods_in_terminating_state\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get frequently restarting K8s pods",
            "id": "f859a8bb5222b242b8366f5d0459b72309b6891d2dcac154cd273f4dbde1e5ac",
            "index": 103,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_frequently_restarting_pods"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes pods from all namespaces that are restarting too often.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "##",
                "# Copyright (c) 2023 unSkript, Inc",
                "# All rights reserved.",
                "##",
                "import json",
                "from typing import Optional, Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_frequently_restarting_pods_printer(output):",
                "    if output is None:",
                "        return",
                "    print(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_frequently_restarting_pods(handle, restart_threshold:int=90) -> Tuple:",
                "    \"\"\"k8s_get_frequently_restarting_pods finds any K8s pods that have restarted more number of times than a given threshold",
                "",
                "        :type handle: object",
                "        :param handle: Object returned from the Task validate method",
                "",
                "        :type restart_threshold: int",
                "        :param restart_threshold: Threshold number of times for which a pod should be restarting",
                "",
                "        :rtype: Tuple of status and list of namespaces and pods that have restarted more than the threshold number of times.",
                "    \"\"\"",
                "    result = []",
                "    cmd = \"kubectl get pods --all-namespaces --sort-by='.status.containerStatuses[0].restartCount' -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RESTART_COUNT:.status.containerStatuses[0].restartCount' -o json\"",
                "    response = handle.run_native_cmd(cmd)",
                "    if response is None:",
                "        print(",
                "            f\"Error while executing command ({cmd}) (empty response)\")",
                "",
                "    if response.stderr:",
                "        raise ApiException(",
                "            f\"Error occurred while executing command {cmd} {response.stderr}\")",
                "",
                "    all_pods_data = json.loads(response.stdout)",
                "    for pod_data in all_pods_data['items']:",
                "        pod = pod_data['metadata']['name']",
                "        nmspace = pod_data['metadata']['namespace']",
                "",
                "        # Check if 'containerStatuses' is present and if it's not empty",
                "        if 'containerStatuses' in pod_data['status'] and pod_data['status']['containerStatuses']:",
                "            restart_count = pod_data['status']['containerStatuses'][0]['restartCount']",
                "            if restart_count > restart_threshold:",
                "                pods_dict = {",
                "                    'pod': pod,",
                "                    'namespace': nmspace",
                "                }",
                "                result.append(pods_dict)",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_frequently_restarting_pods, lego_printer=k8s_get_frequently_restarting_pods_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"restart_threshold\":{\"default\":90,\"description\":\"Threshold number of times for which a pod should be restarting. Default is 90 times.\",\"title\":\"Restart threshold\",\"type\":\"integer\"}},\"title\":\"k8s_get_frequently_restarting_pods\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "restart_threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Check K8s worker CPU Utilization",
            "id": "cd509c90b084afb4a0b3739e97a6e518a33c5bb71a76b1cbf7bdfb707d14e1b9",
            "index": 97,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_check_worker_cpu_utilization"
            ],
            "currentVersion": "0.1.0",
            "description": "Retrieves the CPU utilization for all worker nodes in the cluster and compares it to a given threshold.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "from __future__ import annotations",
                "",
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from pydantic import BaseModel, Field",
                "from typing import Optional, Tuple",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_check_worker_cpu_utilization_printer(output):",
                "    status, nodes_info = output",
                "    if status:",
                "        print(\"All nodes are within the CPU utilization threshold.\")",
                "        return",
                "",
                "    print(\"ALERT: Nodes exceeding CPU utilization threshold:\")",
                "    print(\"-\" * 40)",
                "    for node_info in nodes_info:",
                "        print(f\"Node: {node_info['node']} - CPU Utilization: {node_info['cpu']}%\")",
                "    print(\"-\" * 40)",
                "",
                "@beartype",
                "def k8s_check_worker_cpu_utilization(handle, threshold: float=70.0) -> Tuple:",
                "    \"\"\"",
                "    k8s_check_worker_cpu_utilization Retrieves the CPU utilization for all worker nodes in the cluster and compares it to a given threshold.",
                "",
                "    :type handle: object",
                "    :param handle: Handle object to execute the kubectl command.",
                "",
                "    :type threshold: int",
                "    :param threshold: Threshold for CPU utilization in percentage.",
                "",
                "    :return: Status and dictionary with node names and their CPU information if any node's CPU utilization exceeds the threshold.",
                "    \"\"\"",
                "    exceeding_nodes = []",
                "    kubectl_command = \"kubectl top nodes --no-headers\"",
                "    response = handle.run_native_cmd(kubectl_command)",
                "",
                "    if response is None or response.stderr:",
                "        raise ApiException(f\"Error while executing command ({kubectl_command}): {response.stderr if response else 'empty response'}\")",
                "",
                "    lines = response.stdout.split('\\n')",
                "    for line in lines:",
                "        parts = line.split()",
                "        if len(parts) < 5:  # Check for correct line format",
                "            continue",
                "        node_name, cpu_percentage_str = parts[0], parts[2]",
                "        cpu_percentage = float(cpu_percentage_str.rstrip('%'))",
                "",
                "        if cpu_percentage > threshold:",
                "            exceeding_nodes.append({\"node\": node_name, \"cpu\": cpu_percentage})",
                "",
                "    if len(exceeding_nodes) != 0:",
                "        return (False, exceeding_nodes)",
                "    return (True, None)",
                "",
                "",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_check_worker_cpu_utilization, lego_printer=k8s_check_worker_cpu_utilization_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"threshold\":{\"default\":70,\"description\":\"Threshold for CPU utilization in percentage.\",\"title\":\"Threshold (in %)\",\"type\":\"number\"}},\"title\":\"k8s_check_worker_cpu_utilization\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_NODE"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get K8s get pending pods",
            "id": "9a88e3d97dcfa624b606b0dee0ad37a84d903962068245bc2d1b5334266649b9",
            "index": 83,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pending_pods"
            ],
            "currentVersion": "0.1.0",
            "description": "This action checks if any pod in the Kubernetes cluster is in 'Pending' status.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Optional, Tuple",
                "from pydantic import BaseModel, Field",
                "import json",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pending_pods_printer(output):",
                "    if output is None:",
                "        return",
                "    print(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_pending_pods(handle, namespace:str=\"\") -> Tuple:",
                "    \"\"\"",
                "    k8s_get_pending_pods checks if any pod in the Kubernetes cluster is in 'Pending' status.",
                "",
                "    :type handle: object",
                "    :param handle: Object returned from the Task validate method",
                "",
                "    :type namespace: string",
                "    :param namespace: Namespace in which to look for the resources. If not provided, all namespaces are considered",
                "",
                "    :rtype: tuple",
                "    :return: Status,list of pending pods with their namespace",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        print(f\"K8S Connector is invalid: {handle}\")",
                "        return False, \"Invalid Handle\"",
                "",
                "    namespace_option = f\"--namespace={namespace}\" if namespace else \"--all-namespaces\"",
                "",
                "    # Getting pods details in json format",
                "    cmd = f\"kubectl get pods -o json {namespace_option}\"",
                "    result = handle.run_native_cmd(cmd)",
                "",
                "    if result.stderr:",
                "        raise ApiException(f\"Error occurred while executing command {cmd} {result.stderr}\")",
                "",
                "    pods = json.loads(result.stdout)['items']",
                "    pending_pods = []",
                "",
                "    for pod in pods:",
                "        name = pod['metadata']['name']",
                "        status = pod['status']['phase']",
                "        pod_namespace = pod['metadata']['namespace']",
                "",
                "        if status == 'Pending':",
                "            pending_pods.append([name, pod_namespace])",
                "",
                "    if len(pending_pods) != 0:",
                "        return (False, pending_pods)",
                "    return (True, None)",
                "",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pending_pods, lego_printer=k8s_get_pending_pods_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"k8s Namespace\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_pending_pods\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Check K8s services endpoint health",
            "id": "99f603380bd9a44b2aa1c13d90754207c756a3bc849052b5fe3816585d68568e",
            "index": 86,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_check_service_status"
            ],
            "currentVersion": "0.1.0",
            "description": "This action checks the health status of the provided Kubernetes services.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "##",
                "##  Copyright (c) 2023 unSkript, Inc",
                "##  All rights reserved.",
                "##",
                "from pydantic import BaseModel, Field",
                "from typing import List, Tuple, Optional",
                "from requests.packages.urllib3.exceptions import InsecureRequestWarning",
                "from kubernetes.client.rest import ApiException",
                "import requests",
                "import json",
                "",
                "# Disabling insecure request warnings",
                "requests.packages.urllib3.disable_warnings(InsecureRequestWarning)",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_check_service_status_printer(output):",
                "",
                "    status, result = output",
                "    if status:",
                "        print(\"All services are healthy.\")",
                "        return",
                "",
                "    # If there are any unhealthy services",
                "    print(\"\\n\" + \"=\" * 100)  # main separator",
                "",
                "    for service, status_msg in result[0].items():",
                "        print(f\"Service:\\t{service}\")",
                "        print(\"-\" * 100)  # sub-separator",
                "        print(f\"Status: {status_msg}\\n\")",
                "        print(\"=\" * 100)  # main separator",
                "",
                "",
                "@beartype",
                "def get_service_url(service_name, namespace, handle):",
                "    kubectl_command = f\"kubectl get service {service_name} -n {namespace} -o=json\"",
                "    response = handle.run_native_cmd(kubectl_command)",
                "",
                "    if response is None or response.stderr:",
                "        error_message = response.stderr if response else \"empty response\"",
                "        print(f\"Error while executing command ({kubectl_command}) ({error_message})\")",
                "        return None",
                "",
                "    service_info = json.loads(response.stdout)",
                "",
                "    # Check if 'spec' key exists in service_info",
                "    if 'spec' not in service_info:",
                "        print(f\"Service '{service_name}' in namespace '{namespace}' does not contain 'spec' key.\")",
                "        return None",
                "",
                "    ip = service_info['spec'].get('clusterIP', None)",
                "    port = None",
                "    if 'ports' in service_info['spec'] and len(service_info['spec']['ports']) > 0:",
                "        port = service_info['spec']['ports'][0].get('port', None)",
                "",
                "    if ip and port:",
                "        return f'http://{ip}:{port}'",
                "    return None",
                "",
                "",
                "@beartype",
                "def k8s_check_service_status(handle, services: list = \"\", namespace: str = \"\") -> Tuple:",
                "    \"\"\"",
                "    k8s_check_service_status Checks the health status of the provided Kubernetes services.",
                "",
                "    :type handle: object",
                "    :param handle: Handle object to execute the kubectl command.",
                "",
                "    :type services: list, optional",
                "    :param services: List of service names to be checked.",
                "",
                "    :type namespace: str, optional",
                "    :param namespace: Namespace where the services reside.",
                "",
                "    :return: Status, dictionary with service statuses.",
                "    \"\"\"",
                "    status_dict = {}",
                "    result = []",
                "",
                "    # Get all namespaces if none is provided",
                "    if not namespace:",
                "        kubectl_command = \"kubectl get namespace -o=jsonpath='{.items[*].metadata.name}'\"",
                "        response = handle.run_native_cmd(kubectl_command)",
                "        if response is None or response.stderr:",
                "            raise ApiException(f\"Error occurred while executing command {kubectl_command} {response.stderr if response else 'empty response'}\")",
                "        namespaces = response.stdout.strip().split(' ')",
                "    else:",
                "        namespaces = [namespace]",
                "",
                "    # For each namespace",
                "    for ns in namespaces:",
                "        # If services are provided",
                "        if services or len(services)!=0:",
                "            services_to_check = services",
                "        else:",
                "            kubectl_command = f\"kubectl get services -n {ns} -o=jsonpath='{{.items[*].metadata.name}}'\"",
                "            response = handle.run_native_cmd(kubectl_command)",
                "            if response is None or response.stderr:",
                "                raise ApiException(f\"Error occurred while executing command {kubectl_command} {response.stderr if response else 'empty response'}\")",
                "                continue",
                "            services_to_check = response.stdout.strip().split(' ')",
                "",
                "        for name in services_to_check:",
                "            url = get_service_url(name, ns, handle)",
                "",
                "            if not url:",
                "                print(f'Unable to find service {name} in namespace {ns}')",
                "                continue",
                "",
                "            # Check service health",
                "            try:",
                "                response = requests.get(url, verify=True, timeout=5)",
                "                if response.status_code != 200:",
                "                    status_dict[name] = f'unhealthy in namespace {ns}. Status code: {response.status_code}'",
                "                    result.append(status_dict)",
                "            except requests.RequestException as e:",
                "                status_dict[name] = f'down in namespace {ns}. Error: {str(e)}'",
                "                result.append(status_dict)",
                "",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_check_service_status, lego_printer=k8s_check_service_status_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"description\":\"Namespace in which the services are running.\",\"title\":\"K8s Namespace\",\"type\":\"string\"},\"services\":{\"description\":\"List of service names to be checked.\",\"items\":{},\"title\":\"List of service names\",\"type\":\"array\"}},\"required\":[\"namespace\",\"services\"],\"title\":\"k8s_check_service_status\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace",
                "services"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get K8s services exceeding memory utilization",
            "id": "700e6c98fcac0b9533445138fe078178e46efde3e596178ce0564d35792a3482",
            "index": 71,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_memory_utilization_of_services"
            ],
            "currentVersion": "0.1.0",
            "description": "This action executes the given kubectl commands to find the memory utilization of the specified services in a particular namespace and compares it with a given threshold.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Optional, Tuple",
                "from pydantic import BaseModel, Field",
                "from tabulate import tabulate",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_memory_utilization_of_services_printer(output):",
                "    status, data = output",
                "    if status:",
                "        print(\"All services are within memory utilization threhsold\")",
                "    else:",
                "        headers = [\"Service\", \"Namespace\", \"Utilization %\"]",
                "        table_data = []",
                "",
                "        for entry in data:",
                "            service = entry['service']",
                "            namespace = entry['namespace']",
                "            utilization_percentage = entry.get('utilization_percentage', \"\")",
                "            table_data.append([service, namespace, utilization_percentage])",
                "        print(tabulate(table_data, headers=headers, tablefmt=\"grid\"))",
                "",
                "",
                "",
                "@beartype",
                "def convert_memory_to_milli(memory_request: str) -> int:",
                "    units = {",
                "        'K': 1,",
                "        'M': 1000,",
                "        'G': 1000 * 1000,",
                "        'T': 1000 * 1000 * 1000,",
                "    }",
                "",
                "    if memory_request[-1] in units:",
                "        return int(memory_request[:-1]) * units[memory_request[-1]]",
                "    elif memory_request[-2:] == 'Ki':",
                "        return int(memory_request[:-2])",
                "    elif memory_request[-2:] == 'Mi':",
                "        return int(memory_request[:-2]) * 1000",
                "    elif memory_request[-2:] == 'Gi':",
                "        return int(memory_request[:-2]) * 1000 * 1000",
                "    elif memory_request[-2:] == 'Ti':",
                "        return int(memory_request[:-2]) * 1000 * 1000 * 1000",
                "    else:",
                "        return int(memory_request)",
                "",
                "",
                "",
                "@beartype",
                "def k8s_get_memory_utilization_of_services(handle, namespace: str = \"\", threshold:float=80, services: list=\"\") -> Tuple:",
                "    \"\"\"",
                "    k8s_get_memory_utilization_of_services executes the given kubectl commands",
                "    to find the memory utilization of the specified services in a particular namespace",
                "    and compares it with a given threshold.",
                "",
                "    Example-",
                "    Memory Request: The memory request for the service is 256Mi, and the function convert_memory_to_milli converts this value to 256000 milli units.",
                "    Memory Usage: According to the kubectl top pod command, the memory usage for the container is 4Mi, which equals 4000 milli units (since 1 Mi = 1000 milli units).",
                "    Utilization Percentage Calculation: The utilization percentage would be calculated as (memory_usage / memory_request_milli) * 100.",
                "    Substituting the values we have:",
                "    (4000/256000)∗100=0.0015625∗100=0.15625% (Utilization %)",
                "",
                "    :type handle: object",
                "    :param handle: Object returned from the Task validate method, must have client-side validation enabled.",
                "",
                "    :type services: list",
                "    :param services: List of pod names of the services for which memory utilization is to be fetched.",
                "",
                "    :type namespace: str",
                "    :param namespace: Namespace in which the services are running.",
                "",
                "    :type threshold: float, optional",
                "    :param threshold: Threshold for memory utilization percentage. Default is 80%.",
                "",
                "    :rtype: tuple (status, list of exceeding services or None)",
                "    :return: Status, list of exceeding services if any service has exceeded the threshold,",
                "    \"\"\"",
                "    if handle.client_side_validation is False:",
                "        raise ApiException(f\"K8S Connector is invalid: {handle}\")",
                "",
                "    if services and not namespace:",
                "        raise ApiException(\"Namespace must be provided if services are specified.\")",
                "",
                "    if not namespace:",
                "        kubectl_command = \"kubectl get namespace -o=jsonpath='{.items[*].metadata.name}'\"",
                "        response = handle.run_native_cmd(kubectl_command)",
                "        if response is None or response.stderr:",
                "            raise ApiException(f\"Error occurred while executing command {kubectl_command} {response.stderr if response else 'empty response'}\")",
                "        namespaces = response.stdout.strip().split(' ')",
                "    else:",
                "        namespaces = [namespace]",
                "",
                "    exceeding_services = []",
                "",
                "    for nmspace in namespaces:",
                "        if not services:",
                "            kubectl_command = f\"kubectl get pods -n {nmspace} -o=jsonpath='{{.items[*].metadata.name}}'\"",
                "            response = handle.run_native_cmd(kubectl_command)",
                "            if response is None or response.stderr:",
                "                raise ApiException(f\"Error occurred while executing command {kubectl_command} {response.stderr if response else 'empty response'}\")",
                "            services_to_check = response.stdout.strip().split(' ')",
                "        else:",
                "            services_to_check = services",
                "",
                "        for service in services_to_check:",
                "            # Get the memory request for the service",
                "            kubectl_command = f\"kubectl get pod {service} -n {nmspace} -o=jsonpath='{{.spec.containers[0].resources.requests.memory}}'\"",
                "            response = handle.run_native_cmd(kubectl_command)",
                "            memory_request = response.stdout",
                "",
                "            memory_request = memory_request.strip() if memory_request else '0'",
                "            memory_request_milli = convert_memory_to_milli(memory_request)",
                "            if memory_request_milli == 0:",
                "                print(f\"Warning: Memory request usage not set for '{service}' in '{nmspace}' namespace\")",
                "            # Get the memory usage for the service",
                "            kubectl_command = f\"kubectl top pod {service} -n {nmspace} --containers | awk '{{print $3}}' | tail -n +2\"",
                "            response = handle.run_native_cmd(kubectl_command)",
                "            memory_usage_values = response.stdout.strip().split('\\n')",
                "            memory_usage_values = [int(value.replace('m', '')) * 1024 if 'm' in value else int(value) for value in memory_usage_values if value.strip()]",
                "",
                "            # Compare each memory usage with the threshold and add to exceeding_services if necessary",
                "            for memory_usage in memory_usage_values:",
                "                utilization_percentage = (memory_usage / memory_request_milli) * 100 if memory_request_milli > 0 else 0",
                "                if utilization_percentage > threshold:",
                "                    exceeding_services.append({\"service\": service, \"namespace\": nmspace,\"message\": \"Memory request usage not set\", \"utilization_percentage\": utilization_percentage})",
                "",
                "    if exceeding_services:",
                "        return (False, exceeding_services)",
                "    return (True, None)",
                "",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_memory_utilization_of_services, lego_printer=k8s_get_memory_utilization_of_services_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"description\":\"Namespace in which the services are running.\",\"title\":\"K8s Namespace\",\"type\":\"string\"},\"services\":{\"description\":\"List of pod names of the services for which memory utilization is to be fetched.\",\"items\":{},\"title\":\"List of pod names (as services)\",\"type\":\"array\"},\"threshold\":{\"default\":80,\"description\":\"Threshold for memory utilization percentage. Default is 80%.\",\"title\":\"Threshold (in %)\",\"type\":\"number\"}},\"required\":[\"services\",\"namespace\"],\"title\":\"k8s_get_memory_utilization_of_services\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "services",
                "namespace",
                "threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get K8s offline nodes",
            "id": "48c0e0b93cb4f0e9f3f8d5a42d86f18b24f2a8bf4f3c8d00828ca75601ecc489",
            "index": 77,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_offline_nodes"
            ],
            "currentVersion": "0.1.0",
            "description": "This action checks if any node in the Kubernetes cluster is offline.",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Tuple",
                "from pydantic import BaseModel",
                "from kubernetes.client.rest import ApiException",
                "import json",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_offline_nodes_printer(output):",
                "    if output is None:",
                "        return",
                "    print(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_offline_nodes(handle) -> Tuple:",
                "    \"\"\"",
                "    k8s_get_offline_nodes checks if any node in the Kubernetes cluster is offline.",
                "",
                "    :type handle: object",
                "    :param handle: Object returned from the Task validate method",
                "",
                "    :rtype: tuple",
                "    :return: Status, List of offline nodes",
                "    \"\"\"",
                "",
                "    if handle.client_side_validation is not True:",
                "        print(f\"K8S Connector is invalid: {handle}\")",
                "        return (False, [\"Invalid Handle\"])",
                "",
                "    # Getting nodes details in json format",
                "    cmd = \"kubectl get nodes -o json\"",
                "    result = handle.run_native_cmd(cmd)",
                "",
                "    if result.stderr:",
                "        raise ApiException(f\"Error occurred while executing command {cmd} {result.stderr}\")",
                "",
                "    nodes = json.loads(result.stdout)['items']",
                "    offline_nodes = []",
                "",
                "    for node in nodes:",
                "        name = node['metadata']['name']",
                "        conditions = node['status']['conditions']",
                "",
                "        node_ready = next((item for item in conditions if item[\"type\"] == \"Ready\"), None)",
                "",
                "        if node_ready and node_ready['status'] == \"False\":",
                "            offline_nodes.append(name)",
                "",
                "    if len(offline_nodes) != 0:",
                "        return (False, offline_nodes)",
                "    return (True, None)",
                "",
                "",
                "",
                "",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_offline_nodes, lego_printer=k8s_get_offline_nodes_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{},\"title\":\"k8s_get_offline_nodes\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_NODE"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes PODS with high restart",
            "id": "feb60351fb3290f22855cc68f4741e24cd930debb326724e977ad9e450c49c74",
            "index": 54,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pods_with_high_restart"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes PODS with high restart",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pods_with_high_restart_printer(output):",
                "    if output is None:",
                "        return",
                "",
                "    print(output)",
                "",
                "@beartype",
                "def k8s_get_pods_with_high_restart(handle, namespace: str = '', threshold: int = 10) -> Tuple:",
                "    \"\"\"k8s_get_pods_with_high_restart This function finds out PODS that have",
                "       high restart count and returns them as a list of dictionaries",
                "",
                "       :type handle: Object",
                "       :param handle: Object returned from the task.validate(...) function",
                "",
                "       :type namespace: str",
                "       :param namespace: K8S Namespace",
                "",
                "       :type threshold: int",
                "       :param threshold: int Restart Threshold Count value",
                "",
                "       :rtype: Tuple Result in tuple format.",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    if not namespace :",
                "        kubectl_command = \"kubectl get pods --all-namespaces --no-headers  | \" + \\",
                "            f\"awk '$5 > {threshold} \" + \" {print $0}' | awk '{print $1,$2}'\"",
                "    else:",
                "        kubectl_command = f\"kubectl get pods -n {namespace}\" + \" --no-headers  | \" + \\",
                "            f\"awk '$4 > {threshold} \" + \" {print $0}' | awk '{print $1,$2}'\"",
                "",
                "    result = handle.run_native_cmd(kubectl_command)",
                "    if result.stderr:",
                "        raise ApiException(f\"Error occurred while executing command {result.stderr}\")",
                "",
                "    retval = []",
                "    if result.stdout:",
                "        for line in result.stdout.split('\\n'):",
                "            if not line:",
                "                continue",
                "            n,p = line.split(' ')",
                "            if not namespace:",
                "                retval.append({'name': p, 'namespace': n})",
                "            else:",
                "                retval.append({'name': n, 'namespace': namespace})",
                "    if retval:",
                "        return (False, retval)",
                "",
                "    return (True, [])",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pods_with_high_restart, lego_printer=k8s_get_pods_with_high_restart_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"K8S Namespace\",\"title\":\"K8S Namespace\",\"type\":\"string\"},\"threshold\":{\"default\":10,\"description\":\"Restart Threshold Value\",\"title\":\"Restart Threshold\",\"type\":\"integer\"}},\"title\":\"k8s_get_pods_with_high_restart\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace",
                "threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes Error PODs from All Jobs",
            "id": "d7a1da167d056a912739fce8c4571c6863050f52d6e19495971277057e709857",
            "index": 56,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_error_pods_from_all_jobs"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes Error PODs from All Jobs",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "",
                "import pprint",
                "from typing import Tuple, Optional",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "from kubernetes import client, watch",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_error_pods_from_all_jobs_printer(output):",
                "    if output is None:",
                "        return",
                "    pprint.pprint(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_error_pods_from_all_jobs(handle, namespace:str=\"\") -> Tuple:",
                "    \"\"\"k8s_get_error_pods_from_all_jobs This check function uses the handle's native command",
                "       method to execute a pre-defined kubectl command and returns the output of list of error pods",
                "       from all jobs.",
                "",
                "       :type handle: Object",
                "       :param handle: Object returned from the task.validate(...) function",
                "",
                "       :rtype: Tuple Result in tuple format.",
                "    \"\"\"",
                "    result = []",
                "    coreApiClient = client.CoreV1Api(api_client=handle)",
                "    BatchApiClient = client.BatchV1Api(api_client=handle)",
                "    # If namespace is provided, get jobs from the specified namespace",
                "    if namespace:",
                "        jobs = BatchApiClient.list_namespaced_job(namespace,watch=False, limit=200).items",
                "    # If namespace is not provided, get jobs from all namespaces",
                "    else:",
                "        jobs = BatchApiClient.list_job_for_all_namespaces(watch=False, limit=200).items",
                "",
                "    for job in jobs:",
                "        # Fetching all the pods associated with the current job",
                "        pods = coreApiClient.list_namespaced_pod(job.metadata.namespace, label_selector=f\"job-name={job.metadata.name}\",watch=False, limit=200).items",
                "",
                "        # Checking the status of each pod",
                "        for pod in pods:",
                "            # If the pod status is 'Failed', print its namespace and name",
                "            if pod.status.phase != \"Succeeded\":",
                "                result.append({\"namespace\":pod.metadata.namespace,\"pod_name\":pod.metadata.name})",
                "    if len(result) != 0:",
                "        return (False, result)",
                "    else:",
                "        return (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_error_pods_from_all_jobs, lego_printer=k8s_get_error_pods_from_all_jobs_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"k8s Namespace\",\"title\":\"Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_error_pods_from_all_jobs\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_TROUBLESHOOTING",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S",
                "CATEGORY_TYPE_K8S_POD"
            ],
            "actionNextHopParameterMapping": {
                "88e97c46ad944d2f0541cd1f87e3ec5b8a4619f6093e89b55cec53b2a47e45aa": {
                    "actionNextHopDetails": {
                        "name": "IP Exhaustion Mitigation: Failing K8s Pod Deletion from Jobs",
                        "namespace": ".[0].namespace",
                        "pod_names": "map(.pod_name)"
                    }
                }
            },
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes PODs in not Running State",
            "id": "bf0dad12a041d356406d77f967c2ff2ed31e1bfd47088c0844b629d792fb28ca",
            "index": 90,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_pods_in_not_running_state"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes PODs in not Running State",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_pods_in_not_running_state_printer(output):",
                "    if output is None:",
                "        return",
                "",
                "    print(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_pods_in_not_running_state(handle, namespace: str = '') -> Tuple:",
                "    \"\"\"k8s_get_pods_in_not_running_state This check function uses the handle's native command",
                "       method to execute a pre-defined kubectl command and returns the output of list of pods",
                "       not in running state.",
                "",
                "       :type handle: Object",
                "       :param handle: Object returned from the task.validate(...) function",
                "",
                "       :rtype: Tuple Result in tuple format.",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    if not namespace:",
                "        kubectl_command =(\"kubectl get pods --all-namespaces --field-selector=status.phase!=Running\"",
                "                           \" -o jsonpath=\\\"{.items[*]['metadata.name', 'metadata.namespace']}\\\"\")",
                "    else:",
                "        kubectl_command = f\"kubectl get pods -n {namespace}\" + \\",
                "              \" --field-selector=status.phase!=Running -o jsonpath=\\\"{.items[*]['metadata.name', 'metadata.namespace']}\\\"\"",
                "    result = handle.run_native_cmd(kubectl_command)",
                "",
                "    if result.stderr:",
                "        raise ApiException(f\"Error occurred while executing command {kubectl_command} {result.stderr}\")",
                "",
                "    if result.stdout:",
                "        return (False, [{'name': result.stdout.split()[0], 'namespace': result.stdout.split()[-1]}])",
                "",
                "    return (True, [])",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_pods_in_not_running_state, lego_printer=k8s_get_pods_in_not_running_state_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"K8S Namespace\",\"title\":\"K8S Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_pods_in_not_running_state\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes Nodes that have insufficient resources",
            "id": "588e9f61ddf3343d359958ae195a3d912a7fe4d4341d098c62c2ffa0c6a1814f",
            "index": 49,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_nodes_with_insufficient_resources"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes Nodes that have insufficient resources",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "import pprint",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from tabulate import tabulate",
                "from kubernetes import client",
                "from kubernetes.client.rest import ApiException",
                "",
                "try:",
                "    from unskript.legos.kubernetes.k8s_utils import normalize_cpu, normalize_memory, normalize_storage",
                "except Exception:",
                "    pass",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_nodes_with_insufficient_resources_printer(output):",
                "    if output is None:",
                "        return",
                "",
                "    res_hdr = [\"Name\", \"Resource\"]",
                "    data = []",
                "    for o in output[1]:",
                "        if isinstance(o, dict) is True:",
                "            res_hdr = [\"Name\", \"Allocatable\", \"Capacity\"]",
                "            data.append([",
                "                o.get('name'),",
                "                pprint.pformat(o.get('allocatable')),",
                "                pprint.pformat(o.get('capacity'))",
                "                ])",
                "    print(tabulate(data, headers=res_hdr, tablefmt='fancy_grid'))",
                "",
                "",
                "@beartype",
                "def k8s_get_nodes_with_insufficient_resources(handle, threshold: int = 85) -> Tuple:",
                "    \"\"\"k8s_get_failed_deployments Returns the list of all failed deployments across all namespaces",
                "",
                "    :type handle: Object",
                "    :param handle: Object returned from task.validate(...) function",
                "",
                "    :type threshold: int",
                "    :param threshold: Threshold in Percentage. Default value being 85.",
                "    Any node resource exceeding that threshold",
                "                      is flagged as having insufficient resource.",
                "",
                "    :rtype: Tuple of the result",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    api_client = client.CoreV1Api(api_client=handle)",
                "    retval = []",
                "    nodes = api_client.list_node().items",
                "    for node in nodes:",
                "        cpu_allocatable = normalize_cpu(node.status.allocatable.get('cpu'))",
                "        cpu_capacity = normalize_cpu(node.status.capacity.get('cpu'))",
                "        mem_allocatable = normalize_memory(node.status.allocatable.get('memory'))",
                "        mem_capacity = normalize_memory(node.status.capacity.get('memory'))",
                "        storage_allocatable = normalize_storage(node.status.allocatable.get('ephemeral-storage'))",
                "        storage_capacity = normalize_storage(node.status.capacity.get('ephemeral-storage'))",
                "        cpu_usage_percent = (cpu_capacity - cpu_allocatable)/cpu_capacity * 100",
                "        mem_usage_percent = (mem_capacity - mem_allocatable)/mem_capacity * 100",
                "        storage_usage_percent = (storage_capacity - storage_allocatable)/storage_capacity * 100",
                "        if cpu_usage_percent >= threshold \\",
                "            or mem_usage_percent >= threshold \\",
                "            or storage_usage_percent >= threshold:",
                "            retval.append({",
                "                'name': node.metadata.name,",
                "                'allocatable': node.status.allocatable,",
                "                'capacity': node.status.capacity",
                "                })",
                "",
                "    if  retval:",
                "        return(False, retval)",
                "",
                "    return (True, [])",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_nodes_with_insufficient_resources, lego_printer=k8s_get_nodes_with_insufficient_resources_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"threshold\":{\"default\":85,\"description\":\"Threshold in %age. Default is 85%\",\"title\":\"Threshold\",\"type\":\"integer\"}},\"title\":\"k8s_get_nodes_with_insufficient_resources\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "threshold"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes Failed Deployments",
            "id": "059bb102d1ddb77bf3425f2cb5e5d1acf76d29541c6e7f47031038d1573fb4cf",
            "index": 69,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_failed_deployments"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes Failed Deployments",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes.client.rest import ApiException",
                "import json",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_failed_deployments_printer(output):",
                "    if output is None:",
                "        return",
                "    print(output)",
                "",
                "",
                "@beartype",
                "def k8s_get_failed_deployments(handle, namespace: str = '') -> Tuple:",
                "    \"\"\"k8s_get_failed_deployments Returns all failed deployments across all namespaces",
                "    or within a specific namespace if provided. The deployments are considered",
                "    failed if the 'Available' condition is set to 'False'.",
                "",
                "    :type handle: Object",
                "    :param handle: Object returned from task.validate(...) function",
                "",
                "    :type namespace: str",
                "    :param namespace: The specific namespace to filter the deployments. Defaults to ''.",
                "",
                "    :rtype: Status of result, list of dictionaries, each containing the 'name' and 'namespace' of the failed deployments.",
                "    \"\"\"",
                "    # Construct the kubectl command based on whether a namespace is provided",
                "    kubectl_command = \"kubectl get deployments --all-namespaces -o json\"",
                "    if namespace:",
                "        kubectl_command = \"kubectl get deployments -n \" + namespace + \" -o json\"",
                "    # Execute kubectl command",
                "    response = handle.run_native_cmd(kubectl_command)",
                "    # Check if the response is None, which indicates an error",
                "    if response is None:",
                "        print(f\"Error while executing command ({kubectl_command}) (empty response)\")",
                "    if response.stderr:",
                "        raise ApiException(f\"Error occurred while executing command {kubectl_command} {response.stderr}\")",
                "",
                "    result = []",
                "    try:",
                "        deployments = json.loads(response.stdout)",
                "        # Iterate over each item in the deployments",
                "        for item in deployments[\"items\"]:",
                "            # Check each condition of the deployment",
                "            for condition in item[\"status\"][\"conditions\"]:",
                "                # If the 'Available' condition is set to 'False', add the deployment to the result",
                "                if condition[\"type\"] == \"Available\" and condition[\"status\"] == \"False\":",
                "                    result.append({",
                "                        'name': item[\"metadata\"][\"name\"],",
                "                        'namespace': item[\"metadata\"][\"namespace\"]",
                "                    })",
                "    except Exception as e:",
                "        raise e",
                "",
                "    return (False, result) if result else (True, None)",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_failed_deployments, lego_printer=k8s_get_failed_deployments_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"K8S Namespace\",\"title\":\"K8S Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_failed_deployments\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        },
        {
            "name": "Get Kubernetes Unbound PVCs",
            "id": "04477a3e600b67ac96bcc2430a7202c50babd0fee6dd78804a18551631a06287",
            "index": 63,
            "type": "LEGO_TYPE_K8S",
            "accessType": "ACCESS_TYPE_UNSPECIFIED",
            "tags": [
                "k8s_get_unbound_pvcs"
            ],
            "currentVersion": "0.1.0",
            "description": "Get Kubernetes Unbound PVCs",
            "input": [],
            "output": {
                "type": ""
            },
            "code": [
                "#",
                "# Copyright (c) 2023 unSkript.com",
                "# All rights reserved.",
                "#",
                "from typing import Tuple",
                "from pydantic import BaseModel, Field",
                "from kubernetes import client",
                "from kubernetes.client.rest import ApiException",
                "",
                "",
                "from beartype import beartype",
                "@beartype",
                "def k8s_get_unbound_pvcs_printer(output):",
                "    if output is None:",
                "        return",
                "    print(output)",
                "",
                "@beartype",
                "def k8s_get_unbound_pvcs(handle, namespace:str = '') -> Tuple:",
                "    \"\"\"k8s_get_unbound_pvcs This function all unbound PVCS and returns them back",
                "",
                "       :type handle: Object",
                "       :param handle: Object returned from the task.validate(...) function",
                "",
                "       :type namespace: str",
                "       :param namespace: Kubernetes Namespace",
                "",
                "       :rtype: Tuple Result in tuple format.",
                "    \"\"\"",
                "    if handle.client_side_validation is not True:",
                "        raise ApiException(f\"K8S Connector is invalid {handle}\")",
                "",
                "    v1 = client.CoreV1Api(api_client=handle)",
                "",
                "    # Get all PVCs in the cluster",
                "    if not namespace:",
                "        pvc_list = v1.list_persistent_volume_claim_for_all_namespaces().items",
                "        pod_list = v1.list_pod_for_all_namespaces().items",
                "    else:",
                "        pvc_list = v1.list_namespaced_persistent_volume_claim(namespace).items",
                "        pod_list = v1.list_namespaced_pod(namespace).items",
                "",
                "    retval = []",
                "    mounted_volume = []",
                "    list_all_volumes = []",
                "    # Iterate through each PVC",
                "    for pvc in pvc_list:",
                "        list_all_volumes.append([pvc.metadata.name, pvc.metadata.namespace])",
                "",
                "    for pod in pod_list:",
                "        for volume in pod.spec.volumes:",
                "                if volume.persistent_volume_claim is not None:",
                "                    mounted_volume.append([",
                "                        volume.persistent_volume_claim.claim_name,",
                "                        pod.metadata.namespace",
                "                        ])",
                "",
                "    if len(mounted_volume) != len(list_all_volumes):",
                "        unmounted_volumes = {x[0] for x in list_all_volumes} - {x[0] for x in mounted_volume}",
                "        for um in unmounted_volumes:",
                "            n = [x for x in list_all_volumes if x[0] == um][0]",
                "            unmounted_pvc_name = n[0]",
                "            unmounted_pvc_namespace = n[1]",
                "            retval.append({'name': unmounted_pvc_name, 'namespace': unmounted_pvc_namespace})",
                "",
                "    if retval:",
                "        return (False, retval)",
                "",
                "    return (True, [])",
                "",
                "",
                "task = Task(Workflow())",
                "task.configure(credentialsJson='''{\\\"credential_type\\\": \\\"CONNECTOR_TYPE_K8S\\\"}''')",
                "(err, hdl, args) = task.validate(vars=vars())",
                "if err is None:",
                "    task.execute(k8s_get_unbound_pvcs, lego_printer=k8s_get_unbound_pvcs_printer, hdl=hdl, args=args)"
            ],
            "inputSchema": "[{\"properties\":{\"namespace\":{\"default\":\"\",\"description\":\"K8S Namespace\",\"title\":\"K8S Namespace\",\"type\":\"string\"}},\"title\":\"k8s_get_unbound_pvcs\",\"type\":\"object\"}]",
            "createTime": "1970-01-01T00:00:00Z",
            "orderProperties": [
                "namespace"
            ],
            "nouns": [],
            "verbs": [],
            "actionNeedsCredential": true,
            "actionSupportsPoll": true,
            "actionSupportsIteration": true,
            "actionBashCommand": false,
            "actionRequiredLinesInCode": [],
            "checkEnabled": false,
            "actionIsCheck": true,
            "actionCategories": [
                "CATEGORY_TYPE_CLOUDOPS",
                "CATEGORY_TYPE_DEVOPS",
                "CATEGORY_TYPE_SRE",
                "CATEGORY_TYPE_K8S"
            ],
            "actionNextHopParameterMapping": {},
            "actionOutputType": "",
            "isUnskript": false
        }
    ],
    "nextPageToken": "0",
    "pageCount": 1,
    "totalCount": 19,
    "suggested": []
}