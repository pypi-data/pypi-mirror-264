# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_util.ipynb.

# %% auto 0
__all__ = ['addz', 'catx', 'negcats', 'npxy', 'addx', 'dfxy', 'rotmat', 'rotate', 'ntheta', 'ctheta', 'catrad', 'rad2pnt',
           'chord']

# %% ../nbs/04_util.ipynb 6
from functools import singledispatch

# %% ../nbs/04_util.ipynb 8
from typing import Iterable

# %% ../nbs/04_util.ipynb 11
#| export

# %% ../nbs/04_util.ipynb 13
try: import numpy as np
except ImportError: ...

try: import pandas as pd
except ImportError: ...

# %% ../nbs/04_util.ipynb 15
#| export


# %% ../nbs/04_util.ipynb 17
#| export


# %% ../nbs/04_util.ipynb 19
from quac import intq, dim1, real, nparray
from utrc.atyp import XYArray, RotationMatrix, LabelArray
from utrc.seed import seedall
from utrc.data import catdists

# %% ../nbs/04_util.ipynb 21
#| export


# %% ../nbs/04_util.ipynb 23
#| export


# %% ../nbs/04_util.ipynb 26
def addz(data: XYArray = None, zscale: float = 0.02, seed: int = 3) -> XYArray:
    '''Add noize to data.'''
    seedall(seed)
    # add Gaussian noise
    return data + np.random.normal(0, zscale, np.array(data).shape)

# %% ../nbs/04_util.ipynb 28
def catx(data: XYArray = None, i: int = 0, ncats: intq = 1, distcats: bool = True) -> LabelArray:
    '''Categorize data'''
    return catdists(data, ncats) if distcats else np.full(data.shape[0], i)

# %% ../nbs/04_util.ipynb 30
def negcats(df: pd.DataFrame, label: str = 'label') -> pd.DataFrame:
    idx = ((df.x <= 0) & (0 < df.y)) | ((df.y <= 0) & (0 < df.x))
    df[label] += 1
    df.loc[idx, label] *= -1
    df[label] += df[label].min()
    df[label] *= -1
    return df

# %% ../nbs/04_util.ipynb 32
def npxy(data: XYArray = None, cats: LabelArray = None, seed: int = 3) -> tuple[XYArray, LabelArray]:
    seedall(seed)
    if data is None: data = np.empty((0, 2))
    if cats is None: cats = np.empty(0, dtype=int)
    return data, cats

# %% ../nbs/04_util.ipynb 34
def addx(
    i: int, newx: XYArray, data: XYArray = None, cats: LabelArray = None,
    zscale: float = 0.02, distcats: bool = True, ncats: intq = 1, seed: int = 3,
) -> tuple[XYArray, LabelArray]:
    data, cats = npxy(data, cats, seed)
    newx = addz(newx, zscale, seed)
    newy = catx(newx, i, ncats, distcats)
    data, cats = np.vstack((data, newx)), np.hstack((cats, newy))
    return data, cats

# %% ../nbs/04_util.ipynb 36
def dfxy(x: XYArray, y: LabelArray, label: str = 'label', use_index: bool = True) -> pd.DataFrame:
    '''Generates a dataset from 2D coordinates (`x`) and labels (`y`)'''
    index = pd.CategoricalIndex(y, name=label)
    df = pd.DataFrame(x, columns=['x', 'y'], index=index)
    if not use_index: df.reset_index(inplace=True)
    return df

# %% ../nbs/04_util.ipynb 39
def rotmat(theta: real) -> RotationMatrix:
    '''Create the rotation matrix for `theta`.'''
    return np.array([[np.cos(theta), -np.sin(theta)], 
                     [np.sin(theta),  np.cos(theta)]])

def rotate(m: XYArray, theta: real) -> XYArray:
    '''Rotate a matrix of 2D points by a given angle.'''
    return np.matmul(m, rotmat(theta).T)

# %% ../nbs/04_util.ipynb 41
def ntheta(n: int) -> nparray:
    '''Get n equidistant angles (thetas) from the unit circle.'''
    return np.linspace(0, 2 * np.pi, n, endpoint=False)

def ctheta(n: int = 1) -> float:
    '''Categorical theta. Calculate the degree of rotation per category for a given number of categories.'''
    if n < 2: return 0
    return ntheta(n)[1] - ntheta(n)[0]

def catrad(i: int, n: int = 1) -> float:
    '''Categorical theta for category i of n categories.'''
    return ctheta(n) * i

# %% ../nbs/04_util.ipynb 43
# Define a generic function with a single dispatch
@singledispatch
def rad2pnt(theta: real, sx: real = 1, sy: real = 1):
    '''Polar (radians) --> Cartesian (x, y) coordinates.'''
    raise NotImplementedError('Unsupported type')

# Register the function for handling np.ndarray
@rad2pnt.register(np.ndarray)
@rad2pnt.register(list)
@rad2pnt.register(tuple)
def _(theta: np.ndarray, sx: float = 1, sy: float = 1):
    coord = np.column_stack([sx * np.cos(theta), sy * np.sin(theta)])
    return coord

# Register the function for handling numeric types (float, int, num)
@rad2pnt.register(float)
@rad2pnt.register(int)
@rad2pnt.register(real)
def _(theta: float, sx: float = 1, sy: float = 1):
    return rad2pnt.dispatch(np.ndarray)(theta, sx, sy)[0]

# %% ../nbs/04_util.ipynb 45
# Define a generic function with a single dispatch
@singledispatch
def chord(a: real, b: real, *args, sx: real = 1, sy: real = 1, **kwargs, ):
    '''Calculate the chord length between two angles.'''
    raise NotImplementedError('Unsupported type')

@chord.register(np.ndarray)
def _(thetas: np.ndarray, y: np.ndarray = None, *args, sx: real = 1, sy: real = 1, **kwargs):
    shape = np.asarray(thetas).shape        
    if isinstance(y, np.ndarray) and y.shape == shape: 
        return chord.dispatch(np.ndarray)(np.stack((thetas, y)), sx=sx, sy=sy)
    if len(shape) == 1 and shape[0] >= 2: return chord.dispatch(dim1)(thetas, sx=sx, sy=sy)
    if len(shape) >= 2 and shape[1] >= 2: x, y, *_ = thetas[:2]
    return np.linalg.norm(x - y) 
   
@chord.register(list)
def _(thetas: dim1, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(np.asarray(thetas), sx=sx, sy=sy)

@chord.register(dim1)
def _(thetas: dim1, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(rad2pnt(thetas, sx, sy)[:2], sx=sx, sy=sy)
   
@chord.register(float)
@chord.register(int)
@chord.register(real)
def _(x: real, y: real, *args, sx: real = 1, sy: real = 1, **kwargs):
    return chord.dispatch(np.ndarray)(rad2pnt([x, y], sx, sy), sx=sx, sy=sy)

# %% ../nbs/04_util.ipynb 47
#| export
