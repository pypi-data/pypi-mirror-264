# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from frequenz.api.microgrid.v1 import microgrid_pb2 as frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2


class MicrogridStub(object):
    """The Frequenz Microgrid API
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetMicrogridMetadata = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',
                request_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,
                )
        self.ListComponents = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/ListComponents',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,
                )
        self.ListSensors = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/ListSensors',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,
                )
        self.ListConnections = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/ListConnections',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,
                )
        self.ReceiveComponentDataStream = channel.unary_stream(
                '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,
                )
        self.ReceiveSensorDataStream = channel.unary_stream(
                '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,
                )
        self.AddComponentExclusionBounds = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,
                )
        self.AddComponentInclusionBounds = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,
                )
        self.SetComponentPowerActive = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveResponse.FromString,
                )
        self.SetComponentPowerReactive = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString,
                response_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveResponse.FromString,
                )
        self.StartComponent = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/StartComponent',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.PutComponentInStandby = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.StopComponent = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/StopComponent',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )
        self.AckComponentError = channel.unary_unary(
                '/frequenz.api.microgrid.v1.Microgrid/AckComponentError',
                request_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                )


class MicrogridServicer(object):
    """The Frequenz Microgrid API
    """

    def GetMicrogridMetadata(self, request, context):
        """Returns the microgrid metadata
        The metadata consists of information that describes the overall
        microgrid, as opposed to its electrical components or sensors,
        e.g., the microgrid ID, location.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListComponents(self, request, context):
        """List electrical components in the local microgrid, optionally filtered by a
        given list of component IDs and component categories.

        Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        If provided, the filters for component IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
        `ComponentCategory::COMPONENT_CATEGORY_INVERTER`,
        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories `ComponentCategory::COMPONENT_CATEGORY_INVERTER` OR
        `ComponentCategory::COMPONENT_CATEGORY_BATTERY`.

        If a filter list is empty, then that filter is not applied.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListSensors(self, request, context):
        """Returns a list of sensors in the local microgrid, optionally filtered by a
        given list of sensor IDs and sensor categories.

        Sensors measure physical metrics in the microgrid's surroundings, and are
        not classified as electrical components.

        If provided, the filters for sensor IDs and categories have an `AND`
        relationship with one another, meaning that they are applied serially,
        but the elements within a single filter list have an `OR` relationship with
        each other.
        E.g., if `ids` = [1, 2, 3], and `categories` = [
        `SensorCategory::SENSOR_CATEGORY_THERMOMETER`,
        `SensorCategory::SENSOR_CATEGORY_HYGROMETER`],
        then the results will consist of elements that
        have the IDs 1, OR 2, OR 3,
        AND
        are of the categories `SensorCategory::SENSOR_CATEGORY_THERMOMETER` OR
        `SensorCategory::SENSOR_CATEGORY_HYGROMETER`.

        If a filter list is empty, then that filter is not applied.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListConnections(self, request, context):
        """Electrical components are a part of a microgrid's electrical infrastructure
        are can be connected to each other to form an electrical circuit, which can
        then be represented as a graph.

        This RPC return a list of the connections between two components, denoted
        by `(start, end)`. The direction of a connection is always away from the
        grid endpoint, i.e. aligned with the direction of positive current
        according to the passive sign convention:
        https://en.wikipedia.org/wiki/Passive_sign_convention

        The request may be filtered by `start`/`end` component(s) of individual
        connections.  If provided, the `start` and `end` filters have an `AND`
        relationship between each other, meaning that they are applied serially,
        but an `OR` relationship with other elements in the same list.
        For example, if `start` = `[1, 2, 3]`, and `end` = `[4, 5, 6]`, then the
        result should have all the connections where
        * each `start` component ID is either `1`, `2`, OR `3`,
        AND
        * each `end` component ID is either `4`, `5`, OR `6`.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReceiveComponentDataStream(self, request, context):
        """Returns a stream containing data from a component with a given ID.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ReceiveSensorDataStream(self, request, context):
        """Returns a stream containing data from a sensor with a given ID.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AddComponentExclusionBounds(self, request, context):
        """Adds exclusion bounds for a given metric of a given component, and returns
        the UTC timestamp until which the given exclusion bounds will stay in
        effect.

        Exclusion bounds refer to the range of values that are disallowed for the
        metric. If these bounds for a metric are [`lower`, `upper`], then this
        metric's `value` needs to comply with the constraints
        `value <= lower` OR `upper <= value`.

        Exclusion bounds are a useful tool for enhancing the performance of a
        system. They can be used to restrict the acceptance of commands that fall
        below a certain threshold, which can help ensure the smooth functioning of
        the system.
        E.g., exclusion bounds can be set to limit the minimum charging power to a
        sufficiently high level, preventing a peak-shaver client from sending
        charge powers that are too low when a DC heater client is executing a
        charge pulse. This can significantly improve the overall performance of the
        DC heating mechanism.


        If multiple exclusion bounds have been provided bor a metric, then the
        aggregated lower and upper exclusion bounds are calculated as follows:
        lower: the minimum of all lower exclusion bounds
        upper: the maximum of all upper exclusion bounds

        It is important to note that these bounds work together with
        `system_inclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
        inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
        exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and will be rejected
        ==== vales here are allowed and will be accepted
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AddComponentInclusionBounds(self, request, context):
        """Adds inclusion bounds for a given metric of a given component, and returns
        the UTC timestamp until which the given inclusion bounds will stay in
        effect.

        Inclusion bounds refer to the range of values that are allowed for the
        metric. If these bounds for a metric are [`lower`, `upper`], then this
        metric's `value` needs to comply with the constraint
        `lower <= value <= upper`.

        If multiple inclusion bounds have been provided bor a metric, then the
        aggregated lower and upper inclusion bounds are calculated as follows:
        lower: the maximum of all lower inclusion bounds
        upper: the minimum of all upper inclusion bounds

        It is important to note that these bounds work together with
        `system_exclusion_bounds`.

        E.g., for the system to accept a charge command,
        clients need to request power values within the bounds
        `[system_inclusion_bounds.lower, system_exclusion_bounds.lower]`.
        This means that clients can only request charge commands with values that
        are within the `system_inclusion_bounds`, but not within
        `system_exclusion_bounds`.
        Similarly, for the system to accept a discharge command,
        clients need to request power values within the bounds
        `[system_exclusion_bounds.upper, system_inclusion_bounds.upper]`.

        The following diagram illustrates the relationship between the bounds.
        ```
        inclusion.lower                              inclusion.upper
        <-------|============|------------------|============|--------->
        exclusion.lower    exclusion.upper
        ```
        ---- values here are disallowed and will be rejected
        ==== vales here are allowed and will be accepted
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetComponentPowerActive(self, request, context):
        """Sets the active power output of a component with a given ID, provided the
        component supports it. The power output is specified in watts.

        The power output can be -ve or +ve, depending on whether the component is
        supposed to be discharging or charging, respectively.

        The return value is the timestamp until which the given power command will
        stay in effect. After this timestamp, the component's active power will be
        set to 0, if the API receives no further command to change it before then.
        By default, this timestamp will be set to the current time plus 60 seconds.

        Note that the target component may have a resolution of more than 1 W.
        E.g., an inverter may have a resolution of 88 W.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Sends the discharge command to the inverter, making it deliver
        AC power.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SetComponentPowerReactive(self, request, context):
        """Sets the reactive power output of a component with a given ID, provided the
        component supports it. The power output is specified in VAr.

        The power output can be -ve or +ve, depending on whether the component is
        supposed to be delivering inductive or capacitive power, respectively.

        The return value is the timestamp until which the given power command will
        stay in effect. After this timestamp, the component's reactive power will
        be set to 0, if the API receives no further command to change it before
        then.
        By default, this timestamp will be set to the current time plus 60 seconds.

        Note that the target component may have a resolution of more than 1 VAr.
        E.g., an inverter may have a resolution of 88 VAr.
        In such cases, the magnitude of power will be floored to the nearest
        multiple of the resolution.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StartComponent(self, request, context):
        """Starts the component, and brings it into a state where it is immediately
        operational.

        Performs the following sequence of actions for the following component
        categories:

        * Inverter:
        * closes DC relays, if the feature is available
        * closes AC relays
        * sets power output to 0

        * Battery: Checks if DC relays are open, then
        * closes DC relays

        * Relays:
        * closes relays

        * Precharge Modules:
        * starts the precharge process, and eventually closes the DC relays.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def PutComponentInStandby(self, request, context):
        """Sets the given component into a standby state, from which it can take a
        few minutes to return to an operational state. A transition to an
        operational state can be triggered by calling the `StartComponent` RPC, or
        the `SetComponentPowerActive` RPC.

        Performs the following sequence actions for the following component
        categories:

        * Inverter: Checks if AC and DC relays are closed, then
        * sets power to 0, and
        * opens AC relays

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call efffectively skips that action.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StopComponent(self, request, context):
        """Stops the component completely, potentially disengaging its power
        electronics controller(s).

        Performs the following sequence actions for the following component
        categories:

        * Inverter:
        * Brings component to the cold-standby state
        * opens DC relays

        * Battery: Checks if the power output is 0, then
        * opens DC relays

        * Relays:
        * opens relays

        * Precharge Modules:
        * opens the DC relays.

        If any of the checks mentioned above fails, then the method call returns an
        error.

        If any of the above mentioned actions for a given component has already
        been performed, then this method call effectively skips that action.

        If a feature required to perform an action is missing, then that action is
        skipped.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AckComponentError(self, request, context):
        """Acknowledges any recoverable error reported by the component, and brings it
        back to the stopped or cold-standby state.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MicrogridServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GetMicrogridMetadata': grpc.unary_unary_rpc_method_handler(
                    servicer.GetMicrogridMetadata,
                    request_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.SerializeToString,
            ),
            'ListComponents': grpc.unary_unary_rpc_method_handler(
                    servicer.ListComponents,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.SerializeToString,
            ),
            'ListSensors': grpc.unary_unary_rpc_method_handler(
                    servicer.ListSensors,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.SerializeToString,
            ),
            'ListConnections': grpc.unary_unary_rpc_method_handler(
                    servicer.ListConnections,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.SerializeToString,
            ),
            'ReceiveComponentDataStream': grpc.unary_stream_rpc_method_handler(
                    servicer.ReceiveComponentDataStream,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.SerializeToString,
            ),
            'ReceiveSensorDataStream': grpc.unary_stream_rpc_method_handler(
                    servicer.ReceiveSensorDataStream,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.SerializeToString,
            ),
            'AddComponentExclusionBounds': grpc.unary_unary_rpc_method_handler(
                    servicer.AddComponentExclusionBounds,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.SerializeToString,
            ),
            'AddComponentInclusionBounds': grpc.unary_unary_rpc_method_handler(
                    servicer.AddComponentInclusionBounds,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.SerializeToString,
            ),
            'SetComponentPowerActive': grpc.unary_unary_rpc_method_handler(
                    servicer.SetComponentPowerActive,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveResponse.SerializeToString,
            ),
            'SetComponentPowerReactive': grpc.unary_unary_rpc_method_handler(
                    servicer.SetComponentPowerReactive,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.FromString,
                    response_serializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveResponse.SerializeToString,
            ),
            'StartComponent': grpc.unary_unary_rpc_method_handler(
                    servicer.StartComponent,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'PutComponentInStandby': grpc.unary_unary_rpc_method_handler(
                    servicer.PutComponentInStandby,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'StopComponent': grpc.unary_unary_rpc_method_handler(
                    servicer.StopComponent,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'AckComponentError': grpc.unary_unary_rpc_method_handler(
                    servicer.AckComponentError,
                    request_deserializer=frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'frequenz.api.microgrid.v1.Microgrid', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Microgrid(object):
    """The Frequenz Microgrid API
    """

    @staticmethod
    def GetMicrogridMetadata(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/GetMicrogridMetadata',
            google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.GetMicrogridMetadataResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ListComponents(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListComponents',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListComponentsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ListSensors(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListSensors',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListSensorsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ListConnections(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/ListConnections',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ListConnectionsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ReceiveComponentDataStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveComponentDataStream',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveComponentDataStreamResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def ReceiveSensorDataStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/frequenz.api.microgrid.v1.Microgrid/ReceiveSensorDataStream',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.ReceiveSensorDataStreamResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def AddComponentExclusionBounds(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentExclusionBounds',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentExclusionBoundsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def AddComponentInclusionBounds(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AddComponentInclusionBounds',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AddComponentInclusionBoundsResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetComponentPowerActive(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerActive',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerActiveResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def SetComponentPowerReactive(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/SetComponentPowerReactive',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveRequest.SerializeToString,
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.SetComponentPowerReactiveResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StartComponent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/StartComponent',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StartComponentRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def PutComponentInStandby(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/PutComponentInStandby',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.PutComponentInStandbyRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StopComponent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/StopComponent',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.StopComponentRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def AckComponentError(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/frequenz.api.microgrid.v1.Microgrid/AckComponentError',
            frequenz_dot_api_dot_microgrid_dot_v1_dot_microgrid__pb2.AckComponentErrorRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
