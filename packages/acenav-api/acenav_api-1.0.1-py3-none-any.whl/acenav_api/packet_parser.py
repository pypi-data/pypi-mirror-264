from typing import Listfrom .message_protocol import (MessageProtocol,OutputConf)from .field_parser import(encode_field,decode_field)class PacketParser:    __device_type = ''    __config = None    __decoder = {}    __encoder = {}    def __init__(self, device_type:str, config: MessageProtocol):        self.__device_type = device_type        self.__config = config    def __build_decoder(self, packet_type:str):        exist_output = next((output for output in self.__config.outputs if output.name==packet_type), None)        if exist_output != None:            return self.__build_output_payload_decoder(exist_output, self.__config.scalings)                #TODO: may need decoder for commands        return lambda payload: payload    def __build_output_payload_decoder(self, output: OutputConf, scalings: dict):        def decoder(payload: bytes)->dict:            result = {}            start = 0            for field in output.fields:                value, data_len = decode_field(field.type, field.endian, payload, start)                if field.scaling in scalings:                    value = value * eval(scalings[field.scaling])                result[field.name] = value                start = start + data_len            return result        return decoder    def __build_encoder(self, packet_type:str):        exist_output = next((output for output in self.__config.outputs if output.name==packet_type), None)        if exist_output != None:            return self.__build_output_payload_encoder(exist_output, self.__config.scalings)                #TODO: may need encoder for commands        return lambda payload: None    def __build_output_payload_encoder(self, output: OutputConf, scalings: dict):        def encoder(packet_value: List[int])->bytes:            result = bytearray()            for idx, field in enumerate(output.fields):                value = 0                if idx < len(packet_value):                    value = packet_value[idx]                    if field.name in scalings:                        value = value / eval(scalings[field.scaling])                                result.extend(encode_field(field.type, field.endian, value))            return bytes(result)        return encoder    @property    def device_type(self):        return self.__device_type    def decode(self, packet_type:str, payload: bytes)->dict:        if packet_type not in self.__decoder:            decoder = self.__build_decoder(packet_type)            if decoder == None:                raise Exception('No decoder for packet type: ' + packet_type)            self.__decoder[packet_type] = decoder        else:            decoder = self.__decoder[packet_type]        return decoder(payload)    def encode(self, packet_type:str, packet_value: dict)->bytes:        if packet_type not in self.__encoder:            encoder = self.__build_encoder(packet_type)            if encoder == None:                raise Exception('No encoder for packet type: ' + packet_type)            self.__encoder[packet_type] = encoder        else:            encoder = self.__encoder[packet_type]                return encoder(packet_value)