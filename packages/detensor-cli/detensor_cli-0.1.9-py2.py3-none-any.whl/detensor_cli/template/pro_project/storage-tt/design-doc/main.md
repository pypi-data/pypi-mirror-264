# 设计文档

储存层的任务是把数据交换与计算相关的持久化状态储存在区块链和本地数据库中.

考虑到拓展性, 我们使用了基于对象的储存方法, 将持久化状态封装成对象,
储存在区块链上.

由于区块链提供的储存接口通常是基于kv的.所以我们在设计存储结构的时候,
也是要利用kv结构. 使用kv结构来储存对象和索引等.

对于kv结构的利用, 我们参考了
[TiDB的实现](https://book.tidb.io/session1/chapter3/tidb-kv-to-relation.html), 
利用了kv存储键有序的性质来表达对象和索引的存储.

持久化状态按照控制权,可以分为两部分,由多方控制的
持久化状态,我们称之为公开状态, 由单方控制的持久化
状态,我们称之为私有状态.

由于控制权的不同,公开状态储存在区块链上,私有状态
储存在本地数据库中.

## 提议的处理

由于公开状态的更改涉及到地位原则上对等的多方.
所以不能直接对链上状态进行更改.
所以公开状态的变更要按照以下的流程进行.

1. 创建提议. 提议中包括了对于公开状态的更改.
2. 根据提议或提议所属的命名空间的配置,
   决定提议的批准条件
3. 各个参与方,对于提议进行审核和批准.
4. 如果提议的批准达到了批准条件, 那么提议生效,
   区块链按照提议更改链上状态. 最终删除提议.
5. 提议可以被提出者撤回



## 储存中存在的全局状态
全局状态主要是为了保证储存中的各种约束能够维持,
全局状态统一储存在表`global`中,`global`表的`tableID`是0.

### UID序列号
为了保证UID是唯一的, 我们在全局状态中维持一个名为`next_uid`的键.
这个键标识了下一个创建的对象的uid, next_uid的值我们使用无符号的64位整数.

## 关于对象的描述

储存层上,使用基于对象的储存方式,为了实现不同的功能,可能会添加各种对象.
为了规范对象的访问与储存, 所有的对象都要服从对象的基本规范.

所有的对象都能使用JSON进行编码. 所有的对象都有它所属的类型.

所有的对象均由以下的几个部分组成.
1. 类型元数据, 说明对象的类型和所属的API组.
    - 字段 `apiVersion`, 对象所属的API组, 使用 `core/v1`这样的格式, 必须是合法的URL路径部分.
    - 字段 `kind`, 对象的类型, 必须是一个合法的DNS label. 通常使用一个小写英文字母的单词, 一般不使用连字符.
2. 元数据, 说明对象的名称, UID, 版本, 所属的命名空间, 元数据对象放置在对象的`metadata`字段下.
    - 字段 `name`, 对象的名称, 由于长安链的限制, 对象的名字必须是一个合法的DNS label
      如果对象不使用版本, 那么在一个命名空间下的同类型对象中, 名称应该是唯一的.
    - 字段 `version`, 对象的版本, 可选字段, 如果对象不使用版本, 那么对象没有这个字段.
      如果对象使用版本, 那么在一个命名空间下的同类型对象中, 元组(名称, 版本)应该是唯一的.
      由于长安链的限制, 对象的名字必须是一个合法的DNS label
3. 定义, 说明对象的实际内容, 对象的定义包括了对象的主要内容, 在运行时不常改变或不可变.
   定义对象放置在对象的`spec`字段下.
4. 状态, 说明对象在系统运行时的状态, 状态包括了对象的实际状态, 在运行时可以改变.
   状态对象放置在对象的`status`字段下.

综上, 从对象的类型的角度来说, 可以将每个对象类型必须说明是否是命名空间控制的, 是否使用版本.


## 目前涉及的对象

### 公有存储
#### 命名空间 core/v1 namespace (namespaces)

放在链上的公开对象. 定义放在 contract_rust/object中.

命名空间的命名必须为规范的DNS label, 即最长63个字符,
只能包括小写英文字母和连字符`'-'`. 
必须以数字或字母开头,必须以字母或数字结尾.

#### 提议 core/v1 proposal (proposals)

放在链上的公开对象. 定义放在 contract_rust/object中.

#### 计算合约 core/v1 contract (contracts)

放在链上的公开对象. 定义放在 contract_rust/object中.

一个计算合约. 包含了计算合约的源代码.

#### 数据声明 core/v1 datadeclare (datadeclares)

放在链上的公开对象. 定义放在 contract_rust/object中.

#### 函数声明  core/v1 functiondeclare (functiondeclares)

放在链上的公开对象. 定义放在 contract_rust/object中.

### 私有存储

#### 数据 core/v1 data (data)

放在私有数据库里的私有对象. 结构体定义放在后端的golang里.

#### 函数 core/v1 function (functions)

放在私有数据库里的私有对象. 结构体定义放在后端的golang里.

#### 数据绑定 core/v1 databinding (databindings)

放在私有数据库里的私有对象. 结构体定义放在后端的golang里.

把一个私有数据绑定在计算合约上.

#### 函数绑定 core/v1 functionbinding (functionbindings)

放在私有数据库里的私有对象. 结构体定义放在后端的golang里.

把一个私有函数绑定在计算合约上.

## 需要的表结构

链上的每个对象,在这条链上,有唯一的对象ID, 即`UID`. 我们目前使用的`UID`
是一个无符号的64位整数,即`u64`.

我们的储存结构中, 由两个部分组成, 表和索引. 表储存实际的对象或数据.
每个对象或数据项包含一个唯一的主键. 索引则是为了加快特定查询设计的,
其键值对中,值储存的一般是对象的主键.
为了区分不同的表和索引, 在每条链上, 每个表和索引都有唯一的表ID和索引ID,
称为`TABLE_ID`和`INDEX_ID`.

为了区分表和索引, 表储存的键值对的键使用字节`'t'`开头. 这个字节在下文使用常量`TABLE_PREFIX`指代.
索引储存的键值对的键使用字节`'i'`开头. 这个字节在下文使用常量`INDEX_PREFIX`指代.

在长安链中, 由于只能使用字符串作为键,为了保证前缀扫描的正确性和扫描按照数值大小的正确顺序,
有时需要对整数进行定长编码, 为了尽量利用储存空间,同时满足长安链对于键值内容的限制,
我们使用base62编码,为了覆盖64位的整数范围, 我们使用11位的base62编码对64位无符号整数进行编码,
使用字符`'0'`进行填充.
这里需要注意的是, 为了保证编码后的字符串的比较顺序与整数的比较顺序相同, 
base62的使用的字符顺序需要控制.应该按照ASCII码大小的顺序来使用.

表的键的编码我们规定如下 `{TABLE_PREFIX}{TABLE_ID}_{TABLE_KEY}`.

这里的`TABLE_ID`是base62编码的整数, 不需要进行填充, 因为后面有字符`'_'`, 
所以不会在导致不同的表的键之间成为前缀. 我们在下文中会用表的键来指代
编码中的`TABLE_KEY`部分.

索引的编码我们规定如下 `{INDEX_PREFIX}{INDEX_ID}_{INDEX_KEY}`.
同样的,这里的`INDEX_ID`是base62编码的整数, 不需要进行填充, 因为后面有字符`'_'`.
所以不会导致不同的索引的键之间称为前缀.


由于`UID`的唯一性, 我们使用`UID`作为对象的主键.
考虑到某些对象可能保存在私有数据库中.
如果再考虑到物理隔离的可能性, 我们仅保证在一条链上`UID`是唯一的.
私有对象的`UID`仅在同类型的私有对象之间唯一,
这也比较符合常用的数据库的储存模型. 可以避免进行跨表的唯一主键.

这张对象总表, 称为`objects`, 表ID为`100`. 表的键是base62编码的u64整数.
表的键值对的值, 是JSON编码后的对象内容.

对象按照索引可以分为以下的几种
1. 需要按照命名空间隔离的
    - 需要按照版本进行命名的, 即每个对象有唯一的(名称,版本)对.
    - 不需要按照版本进行命名的, 即每个对象在命名空间下有唯一的名称.
2. 不需要按照命名空间隔离的, 即全局对象
    - 需要按照版本命名的, 即每个对象有唯一的(名称,版本)对.
    - 不需要按照版本进行命名的, 即每个对象在全局中有唯一的名称.

注意,上述的唯一,是指在同类型对象中, 不同类型对象的命名空间是隔离的.
对象类型只能使用标准域名,且只能包含ASCII字符.所以对象类型中不允许含有下划线.

出于以上的考虑, 为了所有通用的对象, 我们需要添加以下的索引.

对于不按照命名空间隔离的且不需要版本命名的, 
需要添加从(对象类型, 对象名称)到对象UID的索引.
这个索引要支持由(对象类型, 对象名称)到UID的直接查询.
同时还要支持由(对象类型,)直接扫描得到所有对象UID的范围查询.

对于不按照命名空间隔离的且需要版本命名的, 
需要添加从(对象类型, 对象名称, 对象版本)到对象UID的索引.
这个索引要支持由(对象类型, 对象名称, 对象版本)到UID的直接查询.
同时还要支持由(对象类型,)直接扫描得到所有对象UID的范围查询.

对于按照命名空间隔离的且不需要版本命名的,
需要添加从(命名空间, 对象类型, 对象名称)到对象UID的索引.
这个索引要支持由(命名空间, 对象类型, 对象名称)到UID的直接查询.
同时还要支持由(命名空间, 对象类型)直接扫描得到所有对象UID的范围查询.

对于按照命名空间隔离且,且需要版本命名的
需要添加从(命名空间, 对象类型, 对象名称, 对象版本)到对象UID的索引.
这个索引要支持由(命名空间, 对象类型, 对象名称, 对象版本)到UID的直接查询.
同时还要支持由(命名空间, 对象类型)直接扫描得到所有对象UID的范围查询.
和由(命名空间, 对象类型, 对象名称)直接扫描得到该名称所有版本的范围查询.

上面的四个索引的需求, 可以统合为一个索引. `objects_names_index`, 索引ID是`100`.

在长安链中, 为了配合长安链的数据库结构.
这个索引的键的组成方式是 `{INDEX_PREFIX}{INDEX_ID}_{OBJECT_KIND}_{NAMESPACE_NAME}_{OBJECT_NAME}`
键的field是对象的版本. 索引的键值对的值是UID. 这里的UID使用简单的大端编码.
如果是全局对象, 那么`NAMESPACE_NAME`为空字符串.
如果不需要版本, 将field设置为空字符串.
由于命名空间的名称不能包含下划线, 所以这个键不会导致不同命名空间的对象之间成为前缀.

为了满足计算节点注册地址的需求, 我们添加一张节点表`nodes`, 表ID是`101`.
表的键是`{TABLE_PREFIX}{TABLE_ID}_{ORG_ID}`, 表的值是该组织注册的计算节点地址.
这里的`ORG_ID`直接使用原始的字符串.


## 提议

提议是提供链上状态更改的机制. 对于关键的,公共的链上状态, 必须通过提议的方式进行更改.

提议分为两种, 全局提议和普通提议, 我们通常在不致歧义的情况下, 称普通提议为提议.
一个提议有一系列动作组成. 提议的执行是原子性的, 一个提议中所有动作要么都执行, 要么都不执行.

提议的动作由以下的几种组成:
- 创建对象 `Create`, 根据提供的JSON, 在链上创建对象
- 更新对象 `Update`, 
  根据提供的JSON, 和UID, 更新链上的对象.
  注意,我们要求更新对象时, 保证对象类型不变, 
  同时,不是每一种对象都支持更新, 
  也不是所有的更新都被允许.
- 删除对象 `Delete`, 根据提供的UID, 删除对象

全局提议所涉及的对象, 必须全部是全局对象.
普通提议所涉及的对象,必须全部是命名空间内的对象,且全部与提议在同一命名空间中.

### 提议的生命周期

- 创建 (动作), 由用户提出创建提议, 普通提议需要指明所在的命名空间.
  系统接收到请求后, 对提议进行正确性检查. 提议必须满足以下的条件才能被创建
  1. 提议涉及的对象类型必须正确, 全局提议所涉及的对象, 必须全部是全局对象,
     不同提议所涉及的对象,必须全部是与提议在同一命名空间中的对象.
  2. 提议所涉及的动作, 必须被相应的对象类型支持. 主要是`Update`动作,
     每种对象,需要提供相应的检查函数.
  3. 更新和删除动作所涉及的对象, 必须要存在, 必须保证对应的UID下存在对象.
  4. 更新对象所更新的对象与原有对象应该是同一类型.
  5. 待创建的对象的UID应当都是0, 这个操作可以由系统代为设置.

  创建完成的提议, 进入待审批状态

- 待审批 (状态)
  合约进入待审批状态后, 等待各个组织进行审批, 当审批成功后, 可以由创建提议的用户
  进行提交. 提交成功后, 合约进入完成状态. 如果提交不成功, 合约仍处于待审批状态.

  合约在审批状态, 可以由创建合约的组织进行撤回. 撤回的合约将进入已撤回状态.
  提议在待审批阶段可以修改, 修改后, 合约的同意状态要清空, 并继续在待审批状态.

- 审批 (动作)
  合约在审批状态可以接收审批, 审批由某个组织发起, 表示该组织对于该提议是否同意.
  组织可以对这个提议表示同意,并留下一条注释, 注释仅起说明作用.
  组织也可以随时撤回对于提议的同意.
  同意提议的组织与该组织留下的注释将保存在提议的`status`字段下.

  记录同意状态时, 需要对根据每个动作进行检查, 每种对象对于支持的动作,
  应该提供一个检查相关性的函数`is_relavent`. 只有在至少一个动作返回
  真的情况下,这个同意状态才会被记录. 
  这主要是为了防止出现无关人员对提议进行审批.

- 提交 (动作)
  进行提交时, 首先要对每个动作, 调用这个动作的对应对象的`is_commitable`函数,
  检查动作是否满足提交条件. 如果存在至少一个动作不满足提交条件, 返回错误.

  如果所有的动作都满足提交条件, 那么对提议进行与提议创建时完全一致的检查,
  如果检查失败, 表明链上状态已经不再适合提议提交, 报错返回.
  如果检查成功, 那么按照提议的动作说明, 执行动作.

- 完成 (状态)
  提交完成, 合约执行完成, 合约进入完成状态. 完成状态的合约不再接收任何更改.
  仅起保存证据作用.

- 已撤回 (状态)
  合约进入已撤回状态后, 将不再接收任何更改, 仅起保存证据作用.




