# coding: utf-8

"""
    Kubernetes

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: release-1.29
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional, Union
from pydantic import BaseModel, Field, StrictStr, conbytes, constr, validator
from .apiextensions_v1_service_reference import ApiextensionsV1ServiceReference

class ApiextensionsV1WebhookClientConfig(BaseModel):
    """
    WebhookClientConfig contains the information to make a TLS connection with the webhook.  # noqa: E501
    """
    ca_bundle: Optional[Union[conbytes(strict=True), constr(strict=True)]] = Field(default=None, alias="caBundle", description="caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate. If unspecified, system trust roots on the apiserver are used.")
    service: Optional[ApiextensionsV1ServiceReference] = None
    url: Optional[StrictStr] = Field(default=None, description="url gives the location of the webhook, in standard URL form (`scheme://host:port/path`). Exactly one of `url` or `service` must be specified.  The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address.  Please note that using `localhost` or `127.0.0.1` as a `host` is risky unless you take great care to run this webhook on all hosts which run an apiserver which might need to make calls to this webhook. Such installs are likely to be non-portable, i.e., not easy to turn up in a new cluster.  The scheme must be \"https\"; the URL must begin with \"https://\".  A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the webhook, for example, a cluster identifier.  Attempting to use a user or basic auth e.g. \"user:password@\" is not allowed. Fragments (\"#...\") and query parameters (\"?...\") are not allowed, either.")
    __properties = ["caBundle", "service", "url"]

    @validator('ca_bundle')
    def ca_bundle_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$", value):
            raise ValueError(r"must validate the regular expression /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ApiextensionsV1WebhookClientConfig:
        """Create an instance of ApiextensionsV1WebhookClientConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of service
        if self.service:
            _dict['service'] = self.service.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ApiextensionsV1WebhookClientConfig:
        """Create an instance of ApiextensionsV1WebhookClientConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ApiextensionsV1WebhookClientConfig.parse_obj(obj)

        _obj = ApiextensionsV1WebhookClientConfig.parse_obj({
            "ca_bundle": obj.get("caBundle"),
            "service": ApiextensionsV1ServiceReference.from_dict(obj.get("service")) if obj.get("service") is not None else None,
            "url": obj.get("url")
        })
        return _obj


